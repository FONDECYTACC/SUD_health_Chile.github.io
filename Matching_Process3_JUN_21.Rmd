---
title: "Ambulatory or residential? a multi-state analysis of treatments for substance use disorders (Step 3)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide  
    toc: true # table of content true
    toc_depth: 5  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
---

```{css zoom-lib-src, echo = FALSE}
script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"
```

```{js zoom-jquery, echo = FALSE}
 $(document).ready(function() {
    $('body').prepend('<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>');
    // onClick function for all plots (img's)
    $('img:not(.zoomImg)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src')).css({width: '100%'});
      $('.zoomDiv').css({opacity: '1', width: 'auto', border: '1px solid white', borderRadius: '5px', position: 'fixed', top: '50%', left: '50%', marginRight: '-50%', transform: 'translate(-50%, -50%)', boxShadow: '0px 0px 50px #888888', zIndex: '50', overflow: 'auto', maxHeight: '100%'});
    });
    // onClick function for zoomImg
    $('img.zoomImg').click(function() {
      $('.zoomDiv').css({opacity: '0', width: '0%'}); 
    });
  });
```

```{=html}
<style type="text/css">
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid black;
        }
.centrado {
    text-align: center;
}
.table.center {
    margin-left:auto; 
    margin-right:auto;
  }
.table_wrapper{
    display: block;
    overflow-x: auto;
    white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
      text-align: justify;
  }
.superbigimage{
    overflow-y:scroll;
    white-space: nowrap;
}
.superbigimage img{
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>
```
```{=html}
<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px; text-align: justify;}
</style>
```
```{r prev_setup, include = FALSE, cache=T}
rm(list=ls());gc()
path<-rstudioapi::getSourceEditorContext()$path
#load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_carla.RData")
if (grepl("CISS Fondecyt",path)==T){
    setwd("C:/Users/CISS Fondecyt/OneDrive/Escritorio/SUD_CL/");load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2_jun.RData")
  } else if (grepl("andre",path)==T){
    setwd('C:/Users/andre/Desktop/SUD_CL/');load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2_jun.RData")
  } else if (grepl("E:",path)==T){
    setwd("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/");load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2_jun.RData")
  } else {
    setwd("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/");load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2_jun.RData")
  }

#getwd()
#knitr::opts_knit$get()
#devtools::install_github("hputter/mstate")

```

```{r setup, include = FALSE, cache=T}
#Libraries used in the routine. Dont change the order
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})
copiar_nombres <- function(x,row.names=FALSE,col.names=TRUE,dec=",",...) {
  if(class(ungroup(x))[1]=="tbl_df"){
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)    
        }
  } else {
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)       
  }
 }
}  
#packageVersion("codebook")
#https://github.com/RevolutionAnalytics/checkpoint
#if(!require(checkpoint)){install.packages("checkpoint")}
#if(!require(here)){install.packages("here")}
#checkpoint::checkpoint("2020-02-19",project=here::here(),checkpointLocation=paste0(here::here(),"/dedup"), use.lock=F, use.knitr=T, auto.install.knitr = T,scan.rnw.with.knitr=T, forceInstall=T,scanForPackages = TRUE)
#checkpointArchives(tempdir(), full.names = TRUE)

#if(!require(tidyr)){install.packages("tidyr")}
#if(!require(DataExplorer)){install.packages("DataExplorer")}
#if(!require(stringi)){install.packages("stringi")}
#if(!require(stringr)){install.packages("stringr")}
#if(!require(ggplot2)){install.packages("ggplot2")}
#if(!require(Hmisc)){install.packages("Hmisc")}
#if(!require(kableExtra)){install.packages("kableExtra")}
#if(!require(plotly)){install.packages("plotly")}
#if(!require(rbokeh)){install.packages("rbokeh")}
#if(!require(altair)){install.packages("altair")}
#if(!require(zoo)){install.packages("zoo")}
#if(!require(codebook)){install.packages("codebook")}
#if(!require(broom)){install.packages("broom")}
#if(!require(sqldf)){install.packages("sqldf")} 
#if(!require(devtools)){install.packages("devtools")}
#if(!require(Statamarkdown)){install_github("hemken/Statamarkdown")}
#if(!require(data.table)){install.packages("data.table")}
#if(!require(dplyr)){install.packages("dplyr")}

#if(!require(boot)){install.packages("boot")}
#if(!require(plyr)){install.packages("plyr")}
#if(!require(matrixStats)){install.packages("matrixStats")}
#if(!require(radiant)){install.packages("radiant", repos = "https://radiant-rstats.github.io/minicran/")}

try(library(boot))
library(matrixStats)
library(knitr)
library(tidyr)
library(stringi)
library(stringr)
library(ggplot2)
library(Hmisc)
library(kableExtra)
library(plotly)
library(janitor)
library(rbokeh)
library(zoo)
library(broom)
library(sqldf)
library(devtools)
library(codebook)
library(data.table)
library(panelr)
library(RColorBrewer)
library(lsmeans)
library(finalfit)
suppressPackageStartupMessages(library(ggiraph))
suppressPackageStartupMessages(library(sf))
library(treemapify)
library(dplyr)
library(tidyverse)
library(epiR)
library(survminer)
library(ggfortify)
library(survMisc)

library(foreign)
library(Hmisc)
library(gridExtra)
library(reshape2)
library(stargazer)
library(tableone)
library(MatchIt)
library(cobalt)
library(eha)
library(igraph)
library(Amelia)
library(DiagrammeR) 
library(mstate)
library(flexsurv)
library(muhaz)
library(Metrics)
library(hesim)
#library(mstateutils)
#remotes::install_github("chjackson/flexsurv-dev", upgrade = "never")
#devtools::install_github("stulacy/multistateutils", build_vignettes=TRUE, upgrade = "never")
#devtools::install_github("hputter/mstate", upgrade = "never")
#unlink("C:/Users/CISS Fondecyt/OneDrive/Documentos/R/win-library/4.0/mstate", recursive=T, force=T)

if(!require(radiant.update)){install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")}
#install.packages( repos = "https://radiant-rstats.github.io/minicran/")
#install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")

#tryCatch(source("https://raw.githubusercontent.com/radiant-rstats/minicran/gh-pages/update.R"), error = function(e) print("updated package, radiant"))

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

try_with_time_limit <- function(expr, cpu = Inf, elapsed = Inf)
{
  y <- try({setTimeLimit(cpu, elapsed); expr}, silent = TRUE) 
  if(inherits(y, "try-error")) NULL else y 
}
eval_fork <- function(..., timeout=60){

  #this limit must always be higher than the timeout on the fork!
  setTimeLimit(timeout+5);      

  #dispatch based on method
  ##NOTE!!!!! Due to a bug in mcparallel, we cannot use silent=TRUE for now.
  myfork <- parallel::mcparallel({
    eval(...)
  }, silent=FALSE);

  #wait max n seconds for a result.
  myresult <- parallel::mccollect(myfork, wait=FALSE, timeout=timeout);

  #try to avoid bug/race condition where mccollect returns null without waiting full timeout.
  #see https://github.com/jeroenooms/opencpu/issues/131
  #waits for max another 2 seconds if proc looks dead 
  while(is.null(myresult) && totaltime < timeout && totaltime < 2) {
     Sys.sleep(.1)
     enddtime <- Sys.time();
     totaltime <- as.numeric(enddtime - starttime, units="secs")
     myresult <- parallel::mccollect(myfork, wait = FALSE, timeout = timeout);
  }

  #kill fork after collect has returned
  tools::pskill(myfork$pid, tools::SIGKILL);    
  tools::pskill(-1 * myfork$pid, tools::SIGKILL);  

  #clean up:
  parallel::mccollect(myfork, wait=FALSE);

  #timeout?
  if(is.null(myresult)){
    stop("R call did not return within ", timeout, " seconds. Terminating process.", call.=FALSE);      
  }

  #move this to distinguish between timeout and NULL returns
  myresult <- myresult[[1]];

  #reset timer
  setTimeLimit();     

  #forks don't throw errors themselves
  if(inherits(myresult,"try-error")){
    #stop(myresult, call.=FALSE);
    stop(attr(myresult, "condition"));
  }

  #send the buffered response
  return(myresult);  
}
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#GET LOCAL
#dir.create(paste0(getwd(),"/renv_local"))
#Sys.setenv(RENV_PATHS_LOCAL = paste0(getwd(),"/renv_local"))
#install.packages(paste0(getwd(),"/renv_local/gurobi_9.1-0.zip"), repos = NULL, type="source")
#install.packages(paste0("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/renv_local/gurobi_9.1-0.zip"), repos = NULL, type="source")
library(gurobi)
#"G:/Mi unidad/Alvacast/SISTRAT 2019 (github)"
#Sys.getenv("R_LIBS_USER")
```

<br>

# Cumulative Transition Hazards of Joint Models

Cumulative baseline hazard can be estimated non-parametrically through a Breslow estimator. Must take note that we are assuming a semimarkov process in these transitions.

<br>

```{r msfit2.0, eval=T, echo=T, paged.print=T, error=T}
# Semi-parametric models
#Since there are tied event times, we need to specify ties="breslow" in order to obtain the Aalen-Johansen estimator of
#the transition probability

formula3<-
as.formula(paste0("Surv(time, status) ~", paste0(fitform2," + arrival + strata(trans)")[[3]]))


#_time tipo_de_plan_res_1 TD_1 TD_2 TD_3 TD_4 _start#

formula3_mstate<-
as.formula(paste0("Surv(time, status) ~", paste0(fitform2," + factor(TD_1)+ factor(TD_2)+ factor(TD_3)+ factor(TD_4)+ arrival + strata(trans)")[[3]]))


formula3_mstate_stratified<-
as.formula(paste0("Surv(time, status) ~", paste0(fitform2," + factor(TD_1)+ factor(TD_2)+ factor(TD_3)+ factor(TD_4)+ arrival")[[3]]))

formula3_mstate_stratified_arr<-
as.formula(paste0("Surv(time, status) ~", paste0(fitform2," + factor(TD_1)+ factor(TD_2)+ factor(TD_3)+ factor(TD_4)+ arrival")[[3]]))


#2021-06-03, I changed the regression to Surv(Tstart, Tstop, status) format, but with arrival time.

paste0("For the first transition, we introduced the following Formula: ")
formula3_mstate_stratified

paste0("For the second and further transition, we introduced the following Formula: ")
formula3_mstate_stratified_arr
```

<br>

As seen in the formula above, we included the transition-specific covariables regarding the time that arrived to the state into the models.

<br>

<div style="border: 1px solid #ddd; padding: 5px; overflow-y: scroll; height:350px; overflow-x: scroll; width:100%">
```{r fit3_wcov_pre, eval=T, echo=T, error= T, paged.print=TRUE, warnings =T}
fits_c_wei2 <- vector(mode = "list", length = n_trans2)
fits_c_weiph2 <- vector(mode = "list", length = n_trans2)
fits_c_llogis2 <- vector(mode = "list", length = n_trans2)
fits_c_gomp2 <- vector(mode = "list", length = n_trans2)
fits_c_logn2 <- vector(mode = "list", length = n_trans2)
fits_c_exp2 <- vector(mode = "list", length = n_trans2)
fits_c_gam2 <- vector(mode = "list", length = n_trans2)
fits_c_ggam2 <- vector(mode = "list", length = n_trans2)
fits_c_genf2 <- vector(mode = "list", length = n_trans2)
fits_c_genf_orig2 <- vector(mode = "list", length = n_trans2)
fits_c_ggam_orig2 <- vector(mode = "list", length = n_trans2)
fits_c_rp022 <- vector(mode = "list", length = n_trans2)
fits_c_rp032 <- vector(mode = "list", length = n_trans2)
fits_c_rp042 <- vector(mode = "list", length = n_trans2)
fits_c_rp052 <- vector(mode = "list", length = n_trans2)
fits_c_rp062 <- vector(mode = "list", length = n_trans2)
fits_c_rp072 <- vector(mode = "list", length = n_trans2)
fits_c_rp082 <- vector(mode = "list", length = n_trans2)
fits_c_rp092 <- vector(mode = "list", length = n_trans2)
fits_c_rp102 <- vector(mode = "list", length = n_trans2)

dists_w_covs_4s_w_arrival<-cbind.data.frame(covs=c(rep("fits_c_",(20)*n_trans2)),
              formal=rep(c("Weibull (AFT)", "Weibull (PH)", "Gompertz", "Log-logistic", "Gamma",
                "Generalized gamma", "Generalized gamma (original)", "Lognormal", "Exponential", "Generalized F", "Generalized F(original)", paste0("RP0",2:9),"RP10"),1*n_trans2),
              dist=c("weibull", "weibullph", "llogis", "gamma", "gengamma","gengamma.orig", "gompertz", "lnorm", "exp", "genf","genf.orig",rep("no dist",9)),
              model=rep(c("wei2", "weiph2", "gomp2", "llogis2", "gam2","ggam2", "ggam_orig2", "logn2", "exp2", "genf2","genf_orig2", paste0("rp0",2:9,2),"rp102"),1*n_trans2),
              trans=rep(1:n_trans2, each=20))

ms_d_match_surv$arrival<-ms_d_match_surv$Tstart
ms_d_match_surv_exp<-mstate::expand.covs(ms_d_match_surv, "TD", append = TRUE, longnames =F)
#ms_d_match_surv_exp$TD<-ms_d_match_surv_res$TD

ms_d_match_surv_res2<-
  #El arrival y el número al lado del arrival repreenta el número de la transición
  mstate::expand.covs(ms_d_match_surv, "TD", append = TRUE, longnames =F)
  ms_d_match_surv %>% 
  data.frame() %>%
  dplyr::mutate(tipo_de_plan_res=dplyr::case_when(tipo_de_plan_res_1==1 & trans==1~1,
                                                  tipo_de_plan_res_2==1 & trans==2~1,
                                                  tipo_de_plan_res_3==1 & trans==3~1,
                                                  tipo_de_plan_res_4==1 & trans==4~1,
                                                  T~0)) %>% 
    dplyr::mutate(TD=dplyr::case_when(TD_1==1 & trans==1~1,
                                      TD_2==1 & trans==2~1,
                                      TD_3==1 & trans==3~1,
                                      TD_4==1 & trans==4~1,
                                      T~0))

#ms_d_match_surv_exp <- expand.covs(ms_d_match_surv_exp, "TD", append = TRUE, longnames =F)

#ms_d_match_surv_exp[is.na(ms_d_match_surv_exp$TD_2),"TD_2"]<-0  
#ms_d_match_surv_exp[is.na(ms_d_match_surv_exp$TD_3),"TD_3"]<-0
#ms_d_match_surv_exp[is.na(ms_d_match_surv_exp$TD_4),"TD_4"]<-0

  #mstate::expand.covs(ms_d_match_surv, "arrival", append = TRUE, longnames = FALSE)

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
no_attempts <- 30

fits_cox2<-list()
fits_c_cox2<-list()

form<-
  function(i=1){
  f<-dplyr::case_when(i==4~paste0("Surv(time, status) ~ ",fitform2," + factor(TD_1)+ factor(TD_2)+ factor(TD_3)+ factor(TD_4)+ arrival")[[3]],i==3~paste0("Surv(time, status) ~ ",fitform2," + factor(TD_1)+ factor(TD_2)+ factor(TD_3)+ arrival")[[3]],i==2~paste0("Surv(time, status) ~ ",fitform2," + factor(TD_1)+ factor(TD_2)+ arrival")[[3]],T~paste0("Surv(time, status) ~ ",fitform2," + factor(TD_1)")[[3]])
  return(f)
}

for (i in 1:n_trans2){
  r <- NULL
  attempt <- 0
  while( is.null(r) && attempt <= no_attempts ) {
    attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                 data = subset(ms_d_match_surv_exp, trans == i),
                                 dist = "weibull")
    )
  } 
  fits_c_wei2[[i]] <- r
}

for (i in 3:n_trans2){
  r <- NULL
  attempt <- 0
  while( is.null(r) && attempt <= no_attempts ) {
    attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                 data = subset(ms_d_match_surv_exp, trans == i),
                                 dist = "weibullph")
    )
  } 
  fits_c_weiph2[[i]] <- r
}

for (i in 1:n_trans2){
  r <- NULL
  attempt <- 0
  while( is.null(r) && attempt <= no_attempts ) {
    attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                 data = subset(ms_d_match_surv_exp, trans == i),
                                 dist = "llogis")
    )
  } 
  fits_c_llogis2[[i]] <- r
}

for (i in 1:n_trans2){
  r <- NULL
  attempt <- 0
  while( is.null(r) && attempt <= no_attempts ) {
    attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                 data = subset(ms_d_match_surv_exp, trans == i),
                                 dist = "gamma")
    )
  } 
  fits_c_gam2[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                   data = subset(ms_d_match_surv_exp, trans == i),
                                   dist = "gengamma")
      )
    }
    fits_c_ggam2[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                   data = subset(ms_d_match_surv_exp, trans == i), 
                                   dist = "gompertz")
      )
    }
    fits_c_gomp[[i]] <- r
}  

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                   data = subset(ms_d_match_surv_exp, trans == i),
                                   dist = "lnorm")
      )
    }
    fits_c_logn2[[i]] <- r
}  

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                   data = subset(ms_d_match_surv_exp, trans == i),
                                   dist = "exp")
      )
    }
    fits_c_exp2[[i]] <- r
}  


for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                                   data = subset(ms_d_match_surv_exp, trans == i),
                                   dist = "genf")
      )
    }
    fits_c_genf2[[i]] <- r
}  

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
        attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                             data = subset(ms_d_match_surv_exp, trans == i),
                             dist = "gengamma.orig")
        )
    }
    fits_c_ggam_orig2[[i]] <- r
}  

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
        attempt <- attempt + 1
    try(
      r <- flexsurvreg(formula=as.formula(form(i)),
                             data = subset(ms_d_match_surv_exp, trans == i),
                             dist = "genf.orig")
        )
    }
    fits_c_genf_orig2[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=1,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp022[[i]] <- r
}  

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=2,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp032[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=3,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp042[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=4,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp052[[i]] <- r
}
for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=5,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp062[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=6,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp072[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=7,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp082[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=8,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp092[[i]] <- r
}

for (i in 1:n_trans2){
    r <- NULL
    attempt <- 0
    while( is.null(r) && attempt <= no_attempts ) {
      attempt <- attempt + 1
    try(
      r <- flexsurvspline(formula=as.formula(form(i)),
                            k=9,
                               data = subset(ms_d_match_surv_exp, trans == i))
      )
    }
    fits_c_rp102[[i]] <- r
}

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
```
</div>

<div style="border: 1px solid #ddd; padding: 5px; overflow-y: scroll; height:550px; overflow-x: scroll; width:100%">
```{r msfit2.0.5, eval=T, echo=T, paged.print=T, error=T}
  #formula3_mstate_stratified
  #ms_d_match_surv_exp2

#> ### First fix a patient with reference values for the covariates
#> ### and 0 for all the time-dependent covariates; this will give the
#> ### baseline hazards

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_    
# Database to contrast adjustments
newdat_a <- data.table::data.table(tipo_de_plan_res_1= factor(c(rep(1,1*n_trans2))),
  #comp_status= factor(rep(c("Therapeutic discharge","Discharge without clinical advice"),2)),
  TD_1=rep(0,), 
  TD_2=rep(0,), 
  TD_3=rep(0,),
  TD_4=rep(0,),
  arrival=rep(0,),
  strata= rep(1:n_trans2,1)
                       )
newdat_b <- data.table::data.table(tipo_de_plan_res_1= factor(c(rep(0,1*n_trans2))),
  #comp_status= factor(rep(c("Therapeutic discharge","Discharge without clinical advice"),2)),
  TD_1=rep(0,), 
  TD_2=rep(0,), 
  TD_3=rep(0,),
  TD_4=rep(0,),
  arrival=rep(0,),
  strata= rep(1:n_trans2,1)
                       )
newdat_c <- data.table::data.table(tipo_de_plan_res_1= factor(c(rep(1,1*n_trans2))),
  #comp_status= factor(rep(c("Therapeutic discharge","Discharge without clinical advice"),2)),
    TD_1=rep(0,), 
  TD_2=rep(0,), 
  TD_3=rep(0,),
  TD_4=rep(0,),
  arrival.2=rep(90,),
  strata= rep(1:n_trans2,1)
                       )
newdat_d <- data.table::data.table(tipo_de_plan_res_1= factor(c(rep(0,1*n_trans2))),
  #comp_status= factor(rep(c("Therapeutic discharge","Discharge without clinical advice"),2)),
    TD_1=rep(0,), 
  TD_2=rep(0,), 
  TD_3=rep(0,),
  TD_4=rep(0,),
  arrival.2=rep(90,),
  strata= rep(1:n_trans2,1)
                       )
newdat_e <- data.table::data.table(tipo_de_plan_res_1= factor(c(rep(1,1*n_trans2))),
  #comp_status= factor(rep(c("Therapeutic discharge","Discharge without clinical advice"),2)),
    TD_1=rep(0,), 
  TD_2=rep(0,), 
  TD_3=rep(0,),
  TD_4=rep(0,),
  arrival.2=rep(1095,),
  strata= rep(1:n_trans2,1)
                       )
newdat_f <- data.table::data.table(tipo_de_plan_res_1= factor(c(rep(0,1*n_trans2))),
  #comp_status= factor(rep(c("Therapeutic discharge","Discharge without clinical advice"),2)),
    TD_1=rep(0,), 
  TD_2=rep(0,), 
  TD_3=rep(0,),
  TD_4=rep(0,),
  arrival.2=rep(1095,),
  strata= rep(1:n_trans2,1)
                       )

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

fitted_flexsurvreg2<-data.frame()
fit_flexsurvreg2<-data.frame()

for (i in 1:nrow(dists_w_covs_4s_w_arrival)){  #
  
cat(paste0("#### Flexible Survival Model (w/ covs): ",
             dists_w_covs_4s_w_arrival[i,"formal"], "; transition: ",dists_w_covs_4s_w_arrival[i,"trans"], "\n \n"))  
  
model<-paste0("fits_c_",dists_w_covs_4s_w_arrival[i,"model"])
      #_#_#_#_#_#_
      #se queda pegado en la fila 62, modelo: fits_c_weiph2
      #_#_#_#_#_#_

invisible(c("Test"))
#   fitted_flexsurvreg2_prueba_out<-  data.table::data.table(summary(fits_c_wei2[[2]], newdata= newdat_a, newtime=unique(fitted_km$time), type = "survival", tidy=T)) 
#    fitted_flexsurvreg2_prueba_res<- data.table::data.table(summary(fits_c_wei2[[2]], newdata= newdat_b, newtime=unique(fitted_km$time), type = "survival", tidy=T))
   #t=newtime0, 
   
    # Generate fit indices
 #   fit_flexsurvreg2_prueba<-cbind(dist= "wei",
#             transition=2,
#             fitstats.flexsurvreg(fits_c_wei2[[2]]))

invisible(c("Real"))
tryCatch(
  if(!is.null(get(model)[[dists_w_covs_4s_w_arrival[i,"trans"]]])){  
  #Generate databases
   fitted_flexsurvreg2<- dplyr::bind_rows(fitted_flexsurvreg2,cbind.data.frame(dist=rep(dists_w_covs_4s_w_arrival[i,"formal"],), 
                              trans=rep(dists_w_covs_4s_w_arrival[i,"trans"],),
                              residential=rep(1,),
                              data.table::data.table(summary(get(model)[[dists_w_covs_4s_w_arrival[i,"trans"]]], newdata= newdat_a, newtime=unique(fitted_km$time), type = "survival", tidy=T)))) 
    fitted_flexsurvreg2<- dplyr::bind_rows(fitted_flexsurvreg2,cbind.data.frame(dist=rep(dists_w_covs_4s_w_arrival[i,"formal"],), 
                              trans=rep(dists_w_covs_4s_w_arrival[i,"trans"],),
                              residential=rep(0,),
                              data.table::data.table(summary(get(model)[[dists_w_covs_4s_w_arrival[i,"trans"]]], newdata= newdat_b,  newtime=unique(fitted_km$time), type = "survival", tidy=T)))) 
   #t=newtime0, 
    # Generate fit indices
    fit_flexsurvreg2<-rbind(fit_flexsurvreg2,
       cbind(dist= dists_w_covs_4s_w_arrival[i,"formal"],
             transition=dists_w_covs_4s_w_arrival[i,"trans"],
             fitstats.flexsurvreg(get(model)[[dists_w_covs_4s_w_arrival[i,"trans"]]])))
    #the BIC may not be appropriate if none of the candidate models are considered to be close to the ‘true’ model.     
    } else {
    cat(paste0("The model that assumed a ",dists_w_covs_4s_w_arrival[i,"formal"]," distribution for the transition number ",dists_w_covs_4s_w_arrival[i,"trans"]," did not converge \n\n"))
    }, error=function(e) {
      cat(paste0("The model that assumed a ",dists_w_covs_4s_w_arrival[i,"formal"]," distribution for the transition number ",dists_w_covs_4s_w_arrival[i,"trans"]," did not converge (empty) \n\n"))    
  })
}  

fit_flexsurvreg22<-
  fit_flexsurvreg2 %>% 
  data.frame() %>% 
  dplyr::mutate(across(c("n2ll", "AIC", "AICc", "BIC"),~as.numeric(ifelse(abs(.)>1e7,NA,format(round(.,2), scientific = FALSE))))) %>% 
  data.frame()
#Generalized gamma  RP03/Lognormal RP02/Lognormal  Generalized F/RP02 
# fits_c_ggam2 fits_c_rp032/fits_c_logn2 fits_c_rp022/fits_c_logn2 fits_c_genf2/fits_c_rp022

distribution_by_trans_valid_cis<-
fitted_flexsurvreg2 %>% 
    dplyr::filter(!is.na(lcl)) %>% 
    group_by(trans) %>% distinct(dist)
invisible(c("No hay intervalos de confianza en TDs "))
```
</div>

```{r sel_model, eval=T, echo=T, paged.print=T, error=T}
fitted_flexsurvreg %>% 
    dplyr::left_join(fitted_km, by=c("time", "trans", "residential")) %>% 
    group_by(trans,dist,residential) %>% 
    tidyr::fill(surv,.direction="down") %>% 
    ungroup() %>% 
    dplyr::mutate(abs((est-surv)/surv)) %>% 
    group_by(trans,dist,residential) %>% 
    dplyr::mutate(cumsum_error=cumsum(replace_na(`abs((est - surv)/surv)`, 0))) %>% 
    dplyr::ungroup() %>%  
    group_by(trans, residential) %>% 
    dplyr::slice_max(time) %>% 
    mutate(rank = dense_rank(cumsum_error)) %>% 
    dplyr::ungroup() %>% 
    dplyr::arrange(trans,rank) %>%
    dplyr::select(dist, trans, residential,time, lcl, cumsum_error,rank) %>% 
    dplyr::filter(residential==1) %>% 
    copiar_nombres()

fitted_flexsurvreg %>% 
    dplyr::left_join(fitted_km, by=c("time", "trans", "residential")) %>% 
    group_by(trans,dist,residential) %>% 
    tidyr::fill(surv,.direction="down") %>% 
    ungroup() %>% 
    dplyr::mutate(abs((est-surv)/surv)) %>% 
    group_by(trans,dist,residential) %>% 
    dplyr::mutate(cumsum_error=cumsum(replace_na(`abs((est - surv)/surv)`, 0))) %>% 
    dplyr::ungroup() %>%  
    group_by(trans, residential) %>% 
    dplyr::slice_max(time) %>% 
    mutate(rank = dense_rank(cumsum_error)) %>% 
    dplyr::ungroup() %>% 
    dplyr::arrange(trans,rank) %>%
    dplyr::select(dist, trans, residential,time, lcl, cumsum_error,rank) %>% 
    dplyr::filter(residential==0) %>% 
    copiar_nombres()


fitted_flexsurvreg %>% 
    dplyr::left_join(fitted_km, by=c("time", "trans", "residential")) %>% 
    group_by(trans,dist,residential) %>% 
    tidyr::fill(surv,.direction="down") %>% 
    ungroup() %>% 
    dplyr::mutate(abs((est-surv)/surv)) %>% 
    group_by(trans,dist,residential) %>% 
    dplyr::mutate(cumsum_error=cumsum(replace_na(`abs((est - surv)/surv)`, 0))) %>% 
    dplyr::ungroup() %>%  
    dplyr::filter(time>=365.25*3) %>% 
    group_by(trans, residential) %>% 
    dplyr::slice_min(time) %>% 
    mutate(rank = dense_rank(cumsum_error)) %>% 
    dplyr::ungroup() %>% 
    dplyr::arrange(trans,rank) %>%
    dplyr::select(dist, trans, residential,time, lcl, cumsum_error,rank) %>% 
    dplyr::filter(residential==1) %>% 
    copiar_nombres()

fitted_flexsurvreg %>% 
    dplyr::left_join(fitted_km, by=c("time", "trans", "residential")) %>% 
    group_by(trans,dist,residential) %>% 
    tidyr::fill(surv,.direction="down") %>% 
    ungroup() %>% 
    dplyr::mutate(abs((est-surv)/surv)) %>% 
    group_by(trans,dist,residential) %>% 
    dplyr::mutate(cumsum_error=cumsum(replace_na(`abs((est - surv)/surv)`, 0))) %>% 
    dplyr::ungroup() %>%  
    dplyr::filter(time>=365.25*3) %>% 
    group_by(trans, residential) %>% 
    dplyr::slice_min(time) %>% 
    mutate(rank = dense_rank(cumsum_error)) %>% 
    dplyr::ungroup() %>% 
    dplyr::arrange(trans,rank) %>%
    dplyr::select(dist, trans, residential,time, lcl, cumsum_error,rank) %>% 
    dplyr::filter(residential==0) %>% 
    copiar_nombres


```

```{r msfit2.1, eval=T, echo=T, paged.print=T, error=T}
# Semi-parametric models
#Since there are tied event times, we need to specify ties="breslow" in order to obtain the Aalen-Johansen estimator of
#the transition probability

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

cox_fits <- survival::coxph(formula3_mstate, 
                            data = ms_d_match_surv_exp, method = "breslow") 

cox.zph(cox_fits)
invisible(c("Not-proportional hazards"))

# fits_c_ggam2 fits_c_rp032/fits_c_logn2 fits_c_rp022/fits_c_logn2 fits_c_genf2/fits_c_rp022

sel_param_fits_a <- vector(length = n_trans, mode = "list") 
    sel_param_fits_a[[1]]<- fits_c_ggam2[[1]] #fits_c_genf2[[1]] 
    sel_param_fits_a[[2]]<- fits_c_logn2[[2]]
    sel_param_fits_a[[3]]<- fits_c_logn2[[3]]
    sel_param_fits_a[[4]]<- fits_c_logn2[[4]]

sel_param_fits_a2 <- vector(length = n_trans, mode = "list") 
    sel_param_fits_a2[[1]]<- fits_c_ggam2[[1]] #fits_c_genf2[[1]] 
    sel_param_fits_a2[[2]]<- fits_c_rp032[[2]]
    sel_param_fits_a2[[3]]<- fits_c_rp022[[3]]
    sel_param_fits_a2[[4]]<- fits_c_genf2[[4]]

sel_param_fits_b <- vector(length = n_trans, mode = "list") 
    sel_param_fits_b[[1]]<- fits_c_genf2[[1]] 
    sel_param_fits_b[[2]]<- fits_c_genf2[[2]]
    sel_param_fits_b[[3]]<- fits_c_rp062[[3]]
    sel_param_fits_b[[4]]<- fits_c_rp052[[4]]
```

```{r msfit2.2.1, eval=T, echo=T, paged.print=TRUE, error=T}
#Example by https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5868723/
#library(mstate)
# Semi-parametric 
cox_cumhaz_a <- mstate::msfit(cox_fits, 
                            newdata = newdat_a,
                            trans = trans_matrix, variance = T)
```
```{r msfit2.2.2, eval=T, echo=T, paged.print=TRUE, error=T}
cox_cumhaz_b <- mstate::msfit(cox_fits, 
                            newdata = newdat_b,
                            trans = trans_matrix, variance = T)
```
```{r msfit2.2.3, eval=T, echo=T, paged.print=TRUE, error=T}
cox_cumhaz_c <- mstate::msfit(cox_fits, 
                            newdata = newdat_c,
                            trans = trans_matrix, variance = T)
```
```{r msfit2.2.4, eval=T, echo=T, paged.print=TRUE, error=T}
cox_cumhaz_d <- mstate::msfit(cox_fits, 
                            newdata = newdat_d,
                            trans = trans_matrix, variance = T)
```
```{r msfit2.2.5, eval=T, echo=T, paged.print=TRUE, error=T}
cox_cumhaz_e <- mstate::msfit(cox_fits, 
                            newdata = newdat_e,
                            trans = trans_matrix, variance = T)
```
```{r msfit2.2.6, eval=T, echo=T, paged.print=TRUE, error=T}
cox_cumhaz_f <- mstate::msfit(cox_fits, 
                            newdata = newdat_f,
                            trans = trans_matrix, variance = T)
```

```{r msfit2.3.1, eval=T, echo=T, paged.print=TRUE, error=T}

#https://rdrr.io/cran/flexsurv/man/msfit.flexsurvreg.html
# Parametric

flexsurv_cumhaz_a <- flexsurv::msfit.flexsurvreg(sel_param_fits_a,#sel_param_fits, 
                                             newdata = newdat_a,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)

flexsurv_cumhaz_b <- flexsurv::msfit.flexsurvreg(sel_param_fits_a,#sel_param_fits_4s_b,#sel_param_fits_4s, #Alternatively, if the parameters (including covariate effects) are assumed to be different between different transitions, then a list of transition-specific models can be formed. This list has one component for each permitted transition in the multi-state model. This is more computationally efficient, particularly for larger models and datasets. See the example below, and the vignette.
                                             newdata = newdat_b, #A data frame specifying the values of covariates in the fitted model, other than the transition number. This must be specified if there are other covariates. The variable names should be the same as those in the fitted model formula. There must be either one value per covariate (the typical situation) or n values per covariate, a different one for each of the n allowed transitions.
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01), #Vector of times. These do not need to be the same as the observed event times, and since the model is parametric, they can be outside the range of the data. A grid of more frequent times will provide a better approximation to the cumulative hazard trajectory for prediction with probtrans or mssample, at the cost of greater computational expense.
                                             B = n_iter,#Number of simulations from the normal asymptotic distribution used to calculate variances. Decrease for greater speed at the expense of accuracy.
                                             trans = trans_matrix, 
                                             variance = T)#Calculate the variances and covariances of the transition cumulative hazards (TRUE or FALSE). This is based on simulation from the normal asymptotic distribution of the estimates, which is computationally-expensive.


flexsurv_cumhaz_c <- flexsurv::msfit.flexsurvreg(sel_param_fits_a,#sel_param_fits, 
                                             newdata = newdat_c,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)


flexsurv_cumhaz_d <- flexsurv::msfit.flexsurvreg(sel_param_fits_a,#sel_param_fits, 
                                             newdata = newdat_d,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)

flexsurv_cumhaz_e <- flexsurv::msfit.flexsurvreg(sel_param_fits_a,#sel_param_fits, 
                                             newdata = newdat_e,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)


flexsurv_cumhaz_f <- flexsurv::msfit.flexsurvreg(sel_param_fits_a,#sel_param_fits, 
                                             newdata = newdat_f,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)
```


```{r msfit2.3.2, eval=T, echo=T, paged.print=TRUE, error=T}

#https://rdrr.io/cran/flexsurv/man/msfit.flexsurvreg.html
# Parametric

flexsurv_cumhaz_a2 <- flexsurv::msfit.flexsurvreg(sel_param_fits_a2,#sel_param_fits, 
                                             newdata = newdat_a,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)

flexsurv_cumhaz_b2 <- flexsurv::msfit.flexsurvreg(sel_param_fits_a2,#sel_param_fits_4s_b,#sel_param_fits_4s, #Alternatively, if the parameters (including covariate effects) are assumed to be different between different transitions, then a list of transition-specific models can be formed. This list has one component for each permitted transition in the multi-state model. This is more computationally efficient, particularly for larger models and datasets. See the example below, and the vignette.
                                             newdata = newdat_b, #A data frame specifying the values of covariates in the fitted model, other than the transition number. This must be specified if there are other covariates. The variable names should be the same as those in the fitted model formula. There must be either one value per covariate (the typical situation) or n values per covariate, a different one for each of the n allowed transitions.
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01), #Vector of times. These do not need to be the same as the observed event times, and since the model is parametric, they can be outside the range of the data. A grid of more frequent times will provide a better approximation to the cumulative hazard trajectory for prediction with probtrans or mssample, at the cost of greater computational expense.
                                             B = n_iter,#Number of simulations from the normal asymptotic distribution used to calculate variances. Decrease for greater speed at the expense of accuracy.
                                             trans = trans_matrix, 
                                             variance = T)#Calculate the variances and covariances of the transition cumulative hazards (TRUE or FALSE). This is based on simulation from the normal asymptotic distribution of the estimates, which is computationally-expensive.


flexsurv_cumhaz_c2 <- flexsurv::msfit.flexsurvreg(sel_param_fits_a2,#sel_param_fits, 
                                             newdata = newdat_c,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)


flexsurv_cumhaz_d2 <- flexsurv::msfit.flexsurvreg(sel_param_fits_a2,#sel_param_fits, 
                                             newdata = newdat_d,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)

flexsurv_cumhaz_e2 <- flexsurv::msfit.flexsurvreg(sel_param_fits_a2,#sel_param_fits, 
                                             newdata = newdat_e,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)


flexsurv_cumhaz_f2 <- flexsurv::msfit.flexsurvreg(sel_param_fits_a2,#sel_param_fits, 
                                             newdata = newdat_f,
                                             t = seq(.001, max(ms_d_match_surv$time,na.rm=T), by = .01),
                                             B = n_iter,
                                             trans = trans_matrix, variance = T)

```


```{r msfit2.4, eval=T, echo=T, paged.print=TRUE, error=T}
trans_lab_ten_st<-
cbind.data.frame(transition_label,trans_nmb=sprintf("%02d",1:n_trans2)) %>% 
    dplyr::mutate(paste=paste0(trans_nmb,") ",transition_label))
trans_lab_ten_st_vec<-trans_lab_ten_st$paste
attr(trans_lab_ten_st_vec, "names")<-1:15


# Definition of the database to Plot to compare
#rbind(cbind.data.frame(msf0$Haz,setting="Outpatient"), 
#      cbind.data.frame(msf1$Haz,setting="Residential")) %>%
# 
cumhaz_data_a <- rbind(data.frame(msf1$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_a$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_a$Haz,
                                model = "Parametric"))
cumhaz_data_a$trans <- factor(cumhaz_data_a$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
cumhaz_data_b <- rbind(data.frame(msf0$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_b$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_b$Haz,
                                model = "Parametric"))
cumhaz_data_b$trans <- factor(cumhaz_data_b$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)

cumhaz_data_c <- rbind(data.frame(msf1$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_c$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_c$Haz,
                                model = "Parametric"))
cumhaz_data_c$trans <- factor(cumhaz_data_c$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
cumhaz_data_d <- rbind(data.frame(msf0$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_d$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_d$Haz,
                                model = "Parametric"))
cumhaz_data_d$trans <- factor(cumhaz_data_d$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)

cumhaz_data_e <- rbind(data.frame(msf1$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_e$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_e$Haz,
                                model = "Parametric"))
cumhaz_data_e$trans <- factor(cumhaz_data_e$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
cumhaz_data_f <- rbind(data.frame(msf0$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_f$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_f$Haz,
                                model = "Parametric"))
cumhaz_data_f$trans <- factor(cumhaz_data_f$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
cumhaz_data_a2 <- rbind(data.frame(msf1$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_a$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_a2$Haz,
                                model = "Parametric"))
cumhaz_data_a2$trans <- factor(cumhaz_data_a2$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
cumhaz_data_b2 <- rbind(data.frame(msf0$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_b$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_b2$Haz,
                                model = "Parametric"))
cumhaz_data_b2$trans <- factor(cumhaz_data_b2$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)

cumhaz_data_c2 <- rbind(data.frame(msf1$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_c$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_c2$Haz,
                                model = "Parametric"))
cumhaz_data_c2$trans <- factor(cumhaz_data_c2$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
cumhaz_data_d2 <- rbind(data.frame(msf0$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_d$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_d2$Haz,
                                model = "Parametric"))
cumhaz_data_d2$trans <- factor(cumhaz_data_d2$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)

cumhaz_data_e2 <- rbind(data.frame(msf1$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_e$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_e2$Haz,
                                model = "Parametric"))
cumhaz_data_e2$trans <- factor(cumhaz_data_e2$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
cumhaz_data_f2 <- rbind(data.frame(msf0$Haz,
                                model = "NP Cox"),
                      data.frame(cox_cumhaz_f$Haz,
                                model = "Cox"),
                      data.frame(flexsurv_cumhaz_f2$Haz,
                                model = "Parametric"))
cumhaz_data_f2$trans <- factor(cumhaz_data_f2$trans,
                            levels = seq(1, 15),
                            labels = trans_lab_ten_st$paste)
```


```{r haz_df, eval=T, echo=T, paged.print=TRUE, error=T}

#states_trans_lab
fig_diff_mod_ab<-
ggplot()+
  geom_step(data=reshape2::melt(cumhaz_data_a,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="dashed"),size=1, alpha=.65) + 
  geom_step(data=reshape2::melt(cumhaz_data_b,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="solid"),size=1, alpha=.65) + 
  facet_wrap(trans~., ncol=1, scales="free_y") + 
  scale_color_manual(name ="Model",values=c("#0E53A7","#200772","#BF8830"),labels= c("Cox","NP Cox","Par"))+
  scale_linetype_manual(name= "Modality",values=c("dashed","solid"), labels=c("Residential","Outpatient"))+
  scale_x_continuous(breaks=seq(0, 365.25*11, by = 365.25), labels=seq(0, 11, by = 1), minor_breaks = seq(0, 365.25*11, by = 365.25*.5))+
  xlab("Years") + 
  ylab("Cumulative hazards") + 
  theme_minimal()+
  theme(legend.position=c(.9,.59),
        legend.background = element_rect(fill="white",
                                  size=0.5, linetype="solid", 
                                  colour ="black"))
fig_diff_mod_cd<-
ggplot()+
  geom_step(data=reshape2::melt(cumhaz_data_c,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="dashed"),size=1, alpha=.65) + 
  geom_step(data=reshape2::melt(cumhaz_data_d,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="solid"),size=1, alpha=.65) + 
  facet_wrap(trans~., ncol=1, scales="free_y") + 
  scale_color_manual(name ="Model",values=c("#0E53A7","#200772","#BF8830"),labels= c("Cox","NP Cox","Par"))+
  scale_linetype_manual(name= "Modality",values=c("dashed","solid"), labels=c("Residential","Outpatient"))+
  scale_x_continuous(breaks=seq(0, 365.25*11, by = 365.25), labels=seq(0, 11, by = 1), minor_breaks = seq(0, 365.25*11, by = 365.25*.5))+
  xlab("Years") + 
  ylab("Cumulative") + 
  theme_minimal()+
  theme(legend.position=c(.9,.6),
        legend.background = element_rect(fill="white",
                                  size=0.5, linetype="solid", 
                                  colour ="black"))
fig_diff_mod_ef<-
ggplot()+
  geom_step(data=reshape2::melt(cumhaz_data_e,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="dashed"),size=1, alpha=.65) + 
  geom_step(data=reshape2::melt(cumhaz_data_f,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="solid"),size=1, alpha=.65) + 
  facet_wrap(trans~., ncol=1, scales="free_y") + 
  scale_color_manual(name ="Model",values=c("#0E53A7","#200772","#BF8830"),labels= c("Cox","NP Cox","Par"))+
  scale_linetype_manual(name= "Modality",values=c("dashed","solid"), labels=c("Residential","Outpatient"))+
  scale_x_continuous(breaks=seq(0, 365.25*11, by = 365.25), labels=seq(0, 11, by = 1), minor_breaks = seq(0, 365.25*11, by = 365.25*.5))+
  xlab("Years") + 
  ylab("Cumulative") + 
  theme_minimal()+
  theme(legend.position=c(.9,.6),
        legend.background = element_rect(fill="white",
                                  size=0.5, linetype="solid", 
                                  colour ="black"))

fig_diff_mod_ab2<-
ggplot()+
  geom_step(data=reshape2::melt(cumhaz_data_a2,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="dashed"),size=1, alpha=.65) + 
  geom_step(data=reshape2::melt(cumhaz_data_b2,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="solid"),size=1, alpha=.65) + 
  facet_wrap(trans~., ncol=1, scales="free_y") + 
  scale_color_manual(name ="Model",values=c("#0E53A7","#200772","#BF8830"),labels= c("Cox","NP Cox","Par"))+
  scale_linetype_manual(name= "Modality",values=c("dashed","solid"), labels=c("Residential","Outpatient"))+
  scale_x_continuous(breaks=seq(0, 365.25*11, by = 365.25), labels=seq(0, 11, by = 1), minor_breaks = seq(0, 365.25*11, by = 365.25*.5))+
  xlab("Years") + 
  ylab("Cumulative") + 
  theme_minimal()+
  theme(legend.position=c(.9,.59),
        legend.background = element_rect(fill="white",
                                  size=0.5, linetype="solid", 
                                  colour ="black"))
fig_diff_mod_cd2<-
ggplot()+
  geom_step(data=reshape2::melt(cumhaz_data_c2,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="dashed"),size=1, alpha=.65) + 
  geom_step(data=reshape2::melt(cumhaz_data_d2,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="solid"),size=1, alpha=.65) + 
  facet_wrap(trans~., ncol=1, scales="free_y") + 
  scale_color_manual(name ="Model",values=c("#0E53A7","#200772","#BF8830"),labels= c("Cox","NP Cox","Par"))+
  scale_linetype_manual(name= "Modality",values=c("dashed","solid"), labels=c("Residential","Outpatient"))+
  scale_x_continuous(breaks=seq(0, 365.25*11, by = 365.25), labels=seq(0, 11, by = 1), minor_breaks = seq(0, 365.25*11, by = 365.25*.5))+
  xlab("Years") + 
  ylab("Cumulative") + 
  theme_minimal()+
  theme(legend.position=c(.9,.6),
        legend.background = element_rect(fill="white",
                                  size=0.5, linetype="solid", 
                                  colour ="black"))
fig_diff_mod_ef2<-
ggplot()+
  geom_step(data=reshape2::melt(cumhaz_data_e2,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="dashed"),size=1, alpha=.65) + 
  geom_step(data=reshape2::melt(cumhaz_data_f2,id.vars=c("time","trans","model")), aes(time, value, color= model,linetype="solid"),size=1, alpha=.65) + 
  facet_wrap(trans~., ncol=1, scales="free_y") + 
  scale_color_manual(name ="Model",values=c("#0E53A7","#200772","#BF8830"),labels= c("Cox","NP Cox","Par"))+
  scale_linetype_manual(name= "Modality",values=c("dashed","solid"), labels=c("Residential","Outpatient"))+
  scale_x_continuous(breaks=seq(0, 365.25*11, by = 365.25), labels=seq(0, 11, by = 1), minor_breaks = seq(0, 365.25*11, by = 365.25*.5))+
  xlab("Years") + 
  ylab("Cumulative") + 
  theme_minimal()+
  theme(legend.position=c(.9,.6),
        legend.background = element_rect(fill="white",
                                  size=0.5, linetype="solid", 
                                  colour ="black"))

if(no_mostrar==1){
jpeg(paste0(dta_path,"_mult_state_ags/cum_haz_pat1.jpg"), height=30, width= 10, res= 600, units = "in")
fig_diff_mod_ab
  dev.off()
jpeg(paste0(dta_path,"_mult_state_ags/cum_haz_pat2.jpg"), height=30, width= 10, res= 600, units = "in")
fig_diff_mod_cd
  dev.off()
jpeg(paste0(dta_path,"_mult_state_ags/cum_haz_pat3.jpg"), height=30, width= 10, res= 600, units = "in")
fig_diff_mod_ef
  dev.off()
jpeg(paste0(dta_path,"_mult_state_ags/cum_haz2_pat1.jpg"), height=30, width= 10, res= 600, units = "in")
fig_diff_mod_ab2
  dev.off()
jpeg(paste0(dta_path,"_mult_state_ags/cum_haz2_pat2.jpg"), height=30, width= 10, res= 600, units = "in")
fig_diff_mod_cd2
  dev.off()
jpeg(paste0(dta_path,"_mult_state_ags/cum_haz2_pat3.jpg"), height=30, width= 10, res= 600, units = "in")
fig_diff_mod_ef2
  dev.off()
}
```

```{r cum_haz21, eval=T, echo=T, paged.print=TRUE, fig.height=30, fig.width=10, fig.cap="Figure 1b. Estimate of Cumulative Hazards, Ten States Model, 1st Patient", fig.align="center", error=T}
fig_diff_mod_ab2+ theme(legend.position=c(.9,.585))
```

```{r cum_haz22, eval=T, echo=T, paged.print=TRUE, fig.height=30, fig.width=10, fig.cap="Figure 1b. Estimate of Cumulative Hazards, Ten States Model, 2nd Patient", fig.align="center", error=T}
fig_diff_mod_cd2+ theme(legend.position=c(.9,.585))
```

```{r cum_haz23, eval=T, echo=T, paged.print=TRUE, fig.height=30, fig.width=10, fig.cap="Figure 1b. Estimate of Cumulative Hazards, Ten States Model, 3rd Patient", fig.align="center", error=T}
fig_diff_mod_ef2+ theme(legend.position=c(.9,.485))#+ ylim(0,2)
```

<br>

# Transition Probabilites of the Joint Model

We also want to know the probability to be in each of the three states over time, not only the instantaneous transition rate reflected by the cumulative hazard. We need to create a data frame that represents an individual with Low risk score for reference. We need to compute the probability of readmission after being admitted to a treatment, with or without a therapeutic discharge, for the different periods.

For mstate package, it is possible to use simulation to calculate transition probabilities through `mssample`.

In semi-Markov models, solving the Kolmogorov forward equation numerically is not feasible because the transition is no longer a deterministic function of t, depending on the transition history to estimate differences. Considering the abovementioned, we calculated the transition probabilities not through a deterministic approach, but following a probabilistic one through resamples.

The cumulative hazards obtained are used to simulate the times at which patients transition between health states,  that is,  state occupancy probabilities with a “clock-reset” model at the times specified by 500 points.

We used a number of `r format(n_iter/2, big.mark=",")` resamples of trajectories.

<br>

```{r pat1_pmatrix,eval=T, echo=T, paged.print=TRUE, error=T}

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#_#_#_#_#_#_#_#_#_#_PMATRIX
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

#n_iter=10

for(i in c(.25,.5,1,3)){
  set.seed(1234)
  flexsurv::pmatrix.simfs(x = sel_param_fits_a,
                        t = i, #Must be a single number unlike pmatrix.fs
                        ci = T,
                        B= n_iter/2, #Increasing B is usually more expensive than increasing M. NUmber of simulations from the normal asymptotic distribution. MOre, more accuracy
                        newdat= newdat_a,
                        tvar="trans",
                        #tcovs= "arrival",# Predicatable time-dependent covariates such as age
                        cores= 8,
                        M = 1e5,#Number of individual trajectories to simulate.
                        trans = trans_matrix) %>% 
  assign(paste0("pmatrix1_t_a_",i),.,envir=.GlobalEnv)
}

for(i in c(.25,.5,1,3)){
  set.seed(1234)
  flexsurv::pmatrix.simfs(x = sel_param_fits_a2,
                        t = i,
                        ci = T,
                       # B= n_iter/5000,
                        newdat= newdat5b_2,
                        tvar="trans",
                        #tcovs= "arrival",
                        #M = 1,#Number of individual trajectories to simulate.
                        cores= 8,#N of processor cores
                        trans = trans_matrix) %>% 
  assign(paste0("pmatrix1_t_b_",i),.,envir=.GlobalEnv)
}
```

<br>

# Session Info

```{r session_info, echo=T, error=T, paged.print=TRUE}
Sys.getenv("R_LIBS_USER")

rstudioapi::getSourceEditorContext()
#save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_carla.RData")

if (grepl("CISS Fondecyt",rstudioapi::getSourceEditorContext()$path)==T){
    save.image("C:/Users/CISS Fondecyt/OneDrive/Escritorio/SUD_CL/mult_state_2.RData")
  } else if (grepl("andre",rstudioapi::getSourceEditorContext()$path)==T){
    save.image("C:/Users/andre/Desktop/SUD_CL/mult_state_2.RData")
  } else if (grepl("E:",rstudioapi::getSourceEditorContext()$path)==T){
    save.image("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2.RData")
  } else {
    save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2.RData")
  }

sessionInfo()
```
