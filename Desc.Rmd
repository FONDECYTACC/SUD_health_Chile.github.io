---
title: "Descriptive Statistics"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide  
    toc: true # table of content true
    toc_depth: 5  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
---

<style type="text/css">
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid black;
        }
.centrado {
    text-align: center;
}
.table.center {
    margin-left:auto; 
    margin-right:auto;
  }
.table_wrapper{
    display: block;
    overflow-x: auto;
    white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
      text-align: justify;
  }
.superbigimage{
    overflow-y:scroll;
    white-space: nowrap;
}
.superbigimage img{
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px; text-align: justify;}
</style>

```{r prev_setup, include = FALSE, cache=T}
rm(list=ls());gc()
load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/8.Rdata")

if(isTRUE(getOption('knitr.in.progress'))==T){
    nn_size= 1:5 # size= 1:5
    nn_seq=seq(0, 1, .5)
    nn_K= 10
} else {
  input <- readline('¿Are you gonna run the results seriously? (Si/No): ')
  if(input=="Si"){
    nn_size= 1:5 # size= 1:5
    nn_seq=seq(0, 1, .5)
    nn_K= 10
  } else {
    nn_size= 1 # size= 1:5
    nn_seq=1
    nn_K= 1
  }
}
```

```{r setup, include = FALSE, cache=T}
#Libraries used in the routine. Dont change the order

#setwd("H:/")
#rm(list=c("")

local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})
copiar_nombres <- function(x,row.names=FALSE,col.names=TRUE,dec=",",...) {
  if(class(ungroup(x))[1]=="tbl_df"){
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)    
        }
  } else {
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)       
  }
 }
}  
#packageVersion("codebook")
#https://github.com/RevolutionAnalytics/checkpoint
#if(!require(checkpoint)){install.packages("checkpoint")}
#if(!require(here)){install.packages("here")}
#checkpoint::checkpoint("2020-02-19",project=here::here(),checkpointLocation=paste0(here::here(),"/dedup"), use.lock=F, use.knitr=T, auto.install.knitr = T,scan.rnw.with.knitr=T, forceInstall=T,scanForPackages = TRUE)
#checkpointArchives(tempdir(), full.names = TRUE)

#if(!require(tidyr)){install.packages("tidyr")}
#if(!require(DataExplorer)){install.packages("DataExplorer")}
#if(!require(stringi)){install.packages("stringi")}
#if(!require(stringr)){install.packages("stringr")}
#if(!require(ggplot2)){install.packages("ggplot2")}
#if(!require(Hmisc)){install.packages("Hmisc")}
#if(!require(kableExtra)){install.packages("kableExtra")}
#if(!require(plotly)){install.packages("plotly")}
#if(!require(rbokeh)){install.packages("rbokeh")}
#if(!require(altair)){install.packages("altair")}
#if(!require(zoo)){install.packages("zoo")}
#if(!require(codebook)){install.packages("codebook")}
#if(!require(broom)){install.packages("broom")}
#if(!require(sqldf)){install.packages("sqldf")} 
#if(!require(devtools)){install.packages("devtools")}
#if(!require(Statamarkdown)){install_github("hemken/Statamarkdown")}
#if(!require(data.table)){install.packages("data.table")}
#if(!require(dplyr)){install.packages("dplyr")}

#if(!require(boot)){install.packages("boot")}
#if(!require(plyr)){install.packages("plyr")}
#if(!require(matrixStats)){install.packages("matrixStats")}
#if(!require(radiant)){install.packages("radiant", repos = "https://radiant-rstats.github.io/minicran/")}

try(library(boot))
library(matrixStats)
library(knitr)
library(tidyr)
library(stringi)
library(stringr)
library(ggplot2)
library(Hmisc)
library(kableExtra)
library(plotly)
library(janitor)
library(rbokeh)
library(altair)
library(zoo)
library(broom)
library(sqldf)
library(devtools)
library(Statamarkdown)
library(codebook)
library(data.table)
library(dplyr)
library(panelr)
library(RColorBrewer)
library(choroplethr)
library(choroplethrMaps)
library(choroplethrAdmin1)
library(lsmeans)
library(finalfit)
library(chilemapas)
suppressPackageStartupMessages(library(ggiraph))
suppressPackageStartupMessages(library(sf))
library(treemapify)
library(dplyr)
library(choroplethr)
library(choroplethrMaps)
library(choroplethrAdmin1)
library(tidyverse)

if(!require(radiant.update)){install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")}
#install.packages( repos = "https://radiant-rstats.github.io/minicran/")
#install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")

#tryCatch(source("https://raw.githubusercontent.com/radiant-rstats/minicran/gh-pages/update.R"), error = function(e) print("updated package, radiant"))
```


## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r tab3_surv_diff_bet_treat_motivodeegreso,eval=T, echo=T, paged.print=TRUE}                                                       

```
```{r tab3_surv_diff_bet_treat_motivodeegreso,eval=T, echo=T, paged.print=TRUE}                                                       
#http://rstudio-pubs-static.s3.amazonaws.com/316989_83cbe556125645b698c9ff6cf88c4c1a.html
#https://thriv.github.io/biodatasci2018/r-survival.html
#http://si.biostat.washington.edu/sites/default/files/modules/SISCR_2018_11_all-2pp_0.pdf
#https://www.researchgate.net/profile/Claudia_Castro-Kuriss/publication/325390160_Analisis_de_Supervivencia_mediante_el_empleo_de_R/links/5b0aba27a6fdcc8c25333860/Analisis-de-Supervivencia-mediante-el-empleo-de-R.pdf?origin=publication_detail
#http://www.sthda.com/english/wiki/survival-analysis-basics

#SURVIVAL= Explores factors that are thought to influence the chance that the event occurs
#Datos censurados= pueden ser por distintas causas:
    #- El paciente no refirió un evento (la readmissión) durante el estudio, y no sabemos si el evento ocurrió después. ESTOS SON LOS QUE TENGO QUE DARLES UN DIFF TREAT HASTA EL DIA DE HOY. SIEMPRE Y CUANDO TENGAN MENOS DE 1095 DIAS PARA PERDIDOS EN FECHA DE EGRESO, Y NO ESTÉN TRUNCADOS A LA DERECHA PORQUE NO SE LES TERMINÓ EL PRIMER TRAT.
    #Esta censura puede ocurrir cuando un usuario abandona un estudio, se pierde el seguimiento o no experimenta el evento una vez finaliza el estudio
    #- Truncado a la derecha: quien se perdió por una razón. Truncado a la derecha
    #Las muestras con censura aleatoria se consideran generalmente censuradas por derecha debido a que se van incorporando progresivamente los tiempos de fallas de distintas unidades
    #Los eventos que no experimentaron el evento en el tiempo de estudio se les censurará hasta el último tiempo de registro
    # Una suposición menos restrictiva que la suposición de independencia entre Ci y Ti, pero que alcanza para que los métodos sean válidos, es “la censura independiente” o “censura no informativa”:la probabilidad de que un individuo sea censurado en el instante t0 no depende de que ese individuo tenga inusualmente alto (o bajo) riesgo de evento.
    #Censoring may arise in the following ways:
    ###a patient has not (yet) experienced the event of interest, such as relapse or death, within the study time period;
    ###a patient is lost to follow-up during the study period;
    ###a patient experiences a different event that makes further follow-up impossible.
    #This type of censoring, named right censoring, is handled in survival analysis.

#– Recurrence rate
survfit_days_new_treat<-survfit(Surv(diff_bet_treat, status) ~ motivodeegreso_mod_imp, 
                                data=CONS_C1_df_dup_JUN_2020%>% 
                                  dplyr::mutate(diff_nas_fech_egres= as.numeric(difftime(lubridate::ymd("2019-11-13"),fech_ing, units = "days")))%>%
                                  #dplyr::filter(is.na(fech_egres_imp))%>% dplyr::select(fech_ing,fech_egres_imp,diff_nas_fech_egres)
                                  dplyr::mutate(perdi_seguimiento=dplyr::case_when(is.na(fech_egres_imp)&diff_nas_fech_egres>=1095~1,TRUE~0))%>% 
                                  dplyr::filter(perdi_seguimiento==0)%>% #NI SIQUIERA TERMINARON EL PIMER EVNTO, Y LO MAS PROBABLE ES QUE NUNCA REGISTRARON FECHA DE TÉRMINO. ESTPS SI QUE SI DEBO SACARLOS.
                                  dplyr::mutate(no_tienen_ni_el_primer_evento=dplyr::case_when(is.na(fech_egres_imp)&diff_nas_fech_egres<1095~1,
                                                                                     TRUE~0))%>% 
                                 # dplyr::filter(no_tienen_ni_el_primer_evento==0)%>%#NO HAN TERMINADO EL TRATAMIENTO. CENSURA SIMPLE TIPO 1, PERO SE DIFERENCIA DE LOS QUE NUNCA LLEGARON SIQUIERA A TENER EL PRIMER EVENTO. POR ESO A ESOS CASOS DEBO SACARLOS. AUNQUE NO ESTOY SEGURO, PORQUE PUEDE QUE ESTOS CASOSO TAMBIÉN FORMEN PARTE ED LA CENSURA AUTOMATICA QUE HACE R.
                                  #LOS QUE TIENEN 
                                  dplyr::mutate(status=dplyr::case_when(!is.na(diff_bet_treat)~1,TRUE~0)), #censurar si no tienen fechas entre trat porque no tienen un siguiente
                                    #mutate(status=dplyr::case_when(!is.na(fech_egres_imp)~1,TRUE~0)), #censurar fechas de egreso ##se supone q este es más puro, no sé
                                type = "kaplan-meier", #The Kaplan-Meier curve is a nonparametric estimator of the survival distribution (i.e. the “estimation” component of the “test/estimation” approach to analysis of time-to-event data)
                                error = "tsiatis", conf.type = "log-log", conf.int = 0.95)
#So we only know that the patient survived AT LEAST 13 months, but we have no other information available about the patient's status.  This type of censoring (also known as "right censoring") makes linear regression an inappropriate way to analyze the data due to censoring bias.

#simple
#survfit_days_new_treat_simple<-survfit(Surv(diff_bet_treat, status) ~ motivodeegreso_mod_imp, 
#                                data=CONS_C1_df_dup_JUN_2020%>% mutate(status=dplyr::case_when(!is.na(diff_bet_treat)~1,TRUE~0))%>% data.frame())

#Utilizando esta información se compara si existe alguna diferencia de las curvas de supervivencia entre los estados 
#In order to determine if there is a statistically significant difference between the survival curves, we perform what is known as a log-rank test, which tests the following hypothesis:
##H0: There is no difference in the survival function between those who were on maintenance chemotherapy and those who weren't on maintenance chemotherapy.
##Ha: There is a difference in the survival function between those who were on maintenance chemotherapy and those who weren't on maintenance chemotherapy.
#También con la orden “survdiff”, podemos realizar un test de hipótesis no paramétrico que nos diga si la diferencia de la probabilidad de supervivencia entre subgrupos es significativa o no. En este caso lo sería, al obtener un p-value < 0,05, experimentando esas diferencias en las zonas Centro y Sur, que sería en donde deberíamos de realizar un estudio más en profundidad.
  invisible(  
  survdiff(Surv(diff_bet_treat, status) ~ motivodeegreso_mod_imp, data=CONS_C1_df_dup_JUN_2020%>% mutate(status=dplyr::case_when(!is.na(diff_bet_treat)~1,TRUE~0)), rho = 0)  
  )
  #Prueba log-rank
  invisible(  
  survdiff(Surv(diff_bet_treat, status) ~ motivodeegreso_mod_imp, data=CONS_C1_df_dup_JUN_2020%>% mutate(status=dplyr::case_when(!is.na(diff_bet_treat)~1,TRUE~0)), rho = 1) 
  )

#survfit_days_new_treat_simple
survfit_days_new_treat_dataframe<-summary(survfit_days_new_treat, times=seq(0, 3500, 100), print.rmean=T,digits=2)
#
data.table(survfit_days_new_treat_dataframe$table,keep.rownames = T)%>%
  knitr::kable(format= "html", format.args= list(decimal.mark= ".", big.mark= ","),
               caption="Table 2. Estimates related to the probability that an entry kept free of a posterior one",
               align= c("l",rep('c', 5)), col.names = c("Cause of Discharge","Records","n.max", "n.start","events","rmean","se(rmean)","median", "95%CI Lower","95%CI Upper"))%>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size= 8)%>%
        kableExtra::add_footnote(paste0("Note= Treatments that did not finished their first treatment were discarded (n=",CONS_C1_df_dup_JUN_2020%>% 
    dplyr::mutate(diff_nas_fech_egres= as.numeric(difftime(lubridate::ymd("2019-11-13"),fech_ing, units = "days")))%>%dplyr::mutate(perdi_seguimiento=dplyr::case_when(is.na(fech_egres_imp)&diff_nas_fech_egres>=1095~1,TRUE~0))%>%dplyr::filter(perdi_seguimiento==1)%>% nrow()%>% formatC(big.mark=","),"); Excluded cases with no cause of discharge (n=",CONS_C1_df_dup_JUN_2020%>% dplyr::mutate(diff_nas_fech_egres= as.numeric(difftime(lubridate::ymd("2019-11-13"),fech_ing, units = "days")))%>% dplyr::mutate(perdi_seguimiento=dplyr::case_when(is.na(fech_egres_imp)&diff_nas_fech_egres>=1095~1,TRUE~0))%>%  dplyr::filter(perdi_seguimiento==0)%>% dplyr::mutate(status=dplyr::case_when(!is.na(diff_bet_treat)~1,TRUE~0))%>% dplyr::filter(!is.na(diff_bet_treat),is.na(motivodeegreso_mod_imp))%>% nrow() %>% formatC(big.mark=","),")"), notation = "none")%>%
  kableExtra::scroll_box(width= "100%", height = "250x")

#median time to event (the time when half the records have an event).
#Even if median survival has been reached in a group, it might not be possible to calculate complete confidence intervals for those median values,
# just knowing the difference in median survival values doesn't necessarily tell you which is better for prognosis--then you have to specify which prognosis time you care about.
#The restricted mean (rmean) and its standard error se(rmean) are based on a truncated estimator. When the last censoring time is not random this quantity is occasionally of interest.
```

```{r fig2_survplot_motivoegreso,fig.width = 13, fig.width = 7, dpi = 96, warning=F,message=F,fig.align='center', fig.cap="Figure 2. Recurrence-free interval of a treatment according to cause of discharge of the first treatment", error=T}

#El estimador de S es lo que se llama curva de supervivencia (“survival curve”). 
event="no"
if(event=="si"){
plot(mfit2, col=c(1,2,1,2), lty=c(2,2,1,1),
     mark.time=FALSE, lwd=2, xscale=12,
     xlab="Years post diagnosis", ylab="Probability in State")
legend(3000, .6, c("death:female", "death:male", "pcm:female", "pcm:male"),
         col=c(1,2,1,2), lty=c(1,1,2,2), lwd=2, bty='n')
}
plot(survfit_days_new_treat,
         xlab = "Days of difference with a posterior treatment",  conf.int = T,mark.time = F,
     ylab = "Ssurvival probability",
     col=c("yellow4","thistle","cornflowerblue","violetred3","gray20"), lwd=2) # 
legend("topright", c("Late Withdrawal", "Early Withdrawal", "Administrative Discharge", "Therapeutic Discharge","Referral"),
         col=c("yellow4","thistle","cornflowerblue","violetred3","gray20"), lty=c(1,1,1,1), lwd=2, bty='n')
mtext("Note. Users who did not finish their first treatment or did not show recurrence have been censored", side=1,size=.5,cex=.7,outer=F,at=1500,4)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
