---
title: "Duplicated/ Repeated Cases in SISTRAT C1 (part 2)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide  
    toc: true # table of content true
    toc_depth: 5  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
---

<style type="text/css">
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid black;
        }
.centrado {
    text-align: center;
}
.table.center {
    margin-left:auto; 
    margin-right:auto;
  }
.table_wrapper{
    display: block;
    overflow-x: auto;
    white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
      text-align: justify;
  }
.superbigimage{
    overflow-y:scroll;
    white-space: nowrap;
}
.superbigimage img{
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>

```{r setup, include = FALSE, cache=T}
#Libraries used in the routine. Dont change the order
rm(list=ls());gc()
#rm(list=c("")
unlink('SUD_CL/Duplicates2_cache', recursive = TRUE)
load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/4.Rdata")
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})
#packageVersion("codebook")
#https://github.com/RevolutionAnalytics/checkpoint
#if(!require(checkpoint)){install.packages("checkpoint")}
#if(!require(here)){install.packages("here")}
#checkpoint::checkpoint("2020-02-19",project=here::here(),checkpointLocation=paste0(here::here(),"/dedup"), use.lock=F, use.knitr=T, auto.install.knitr = T,scan.rnw.with.knitr=T, forceInstall=T,scanForPackages = TRUE)
#checkpointArchives(tempdir(), full.names = TRUE)

#if(!require(tidyr)){install.packages("tidyr")}
#if(!require(DataExplorer)){install.packages("DataExplorer")}
#if(!require(stringi)){install.packages("stringi")}
#if(!require(stringr)){install.packages("stringr")}
#if(!require(ggplot2)){install.packages("ggplot2")}
#if(!require(Hmisc)){install.packages("Hmisc")}
#if(!require(kableExtra)){install.packages("kableExtra")}
#if(!require(plotly)){install.packages("plotly")}
#if(!require(rbokeh)){install.packages("rbokeh")}
#if(!require(altair)){install.packages("altair")}
#if(!require(zoo)){install.packages("zoo")}
#if(!require(codebook)){install.packages("codebook")}
#if(!require(broom)){install.packages("broom")}
#if(!require(sqldf)){install.packages("sqldf")} 
#if(!require(devtools)){install.packages("devtools")}
#if(!require(Statamarkdown)){install_github("hemken/Statamarkdown")}
#if(!require(data.table)){install.packages("data.table")}
#if(!require(dplyr)){install.packages("dplyr")}
library(knitr)
library(tidyr)
library(stringi)
library(stringr)
library(ggplot2)
library(Hmisc)
library(kableExtra)
library(plotly)
library(janitor)
library(rbokeh)
library(altair)
library(zoo)
library(broom)
library(sqldf)
library(devtools)
library(Statamarkdown)
library(codebook)
library(data.table)
library(dplyr)
library(panelr)
```

<!--- SÍ O SÍ, HACER LA LIMPIEZA DE LOS SENDA NO, PRINCIPALMENTE DE LOS QUE SE SUPERPONGAN, TAMBIÉN PREGUNTAR A ACC SI LOS CON 0 DÍAS DE TRATAMIENTO SE BORRARÁN O NO; DE AHI EMPEZAR A NORMALIZAR LOS PROGRAMAS Y PLANES DE ACUERDO CON CRITERIOS MAUREEN, PARA NO GENERAR DIFERENCIAS AHI Y PODER DEDUPLICAR TRANQUILO --->

<!--- tipo_centro, convertir en factor 1. Privado, 2. Público; DataExplorer::create_report(CONS_1_4)  --->

## 0. Raw Deduplication

&nbsp;
<br>
For the purpose of this page, we use the terms "rows" and "cases" as equal to refer to the entries of the dataset. In many of the processes made along the deduplication of entries in C1 dataset, we used unstandardized columns or many other data that was in fact duplicated by HASHs, that did not depend on events related to treatment. In order to find and delete duplicated data that does not add information relevant for the purposes of the study, we now may **use these standardized variables as a criteria to achieve the goal of having a unique event per HASH, by reducing its complexity based on irrelevant differences**.
<br>

### Deduplication based on standardized columns of interest for the study

First, we selected the following standardized variables as a criteria to identify duplicated treatments per user:

- Masked Identifier (HASH_KEY)
- Date of Admission to Treatment (fech_ing)
- Center ID (ID.centro)
- Main Substance of Consumption (sus_principal)
- Other Substances (1) (otras_sus1)
- Other Substances (2) (otras_sus2)
- Other Substances (3) (otras_sus3)
- Starting Substance (sus_ini)
- Age of Onset of Drug Use (edad_ini_cons)
- Marital Status (estado_conyugal)
- Occupational Status (estatus_ocupacional)
- Occupational Category (cat_ocupacional)
- Age in groups (Edad_grupos)
- Motive of Admission to Treatment (origen_ingreso)
- Education Attainment (escolaridad)
- Route of Administration of the Main Substance (via_adm_sus_prin)
- Frequency of Consumption of the Main Substance (freq_cons_sus_prin)

```{r dedup_manual, echo=T, paged.print=TRUE}
require(data.table)
names_c1_stage3 <- c("HASH_KEY","fech_ing", "ID.centro", "sus_principal", "otras_sus1","otras_sus2","otras_sus3","sus_ini","edad_ini_cons", "estado_conyugal","estatus_ocupacional","cat_ocupacional","Edad_grupos","origen_ingreso", "escolaridad","via_adm_sus_prin", "freq_cons_sus_prin")

require(dplyr)
CONS_C1_df_dup_ENE_2020 %>%
  dplyr::arrange(desc(ano_bd),HASH_KEY, desc(fech_ing), desc(fech_egres),dias_trat_inv) %>%
  dplyr::distinct_(.dots = names_c1_stage3, .keep_all = TRUE) %>%
#  dplyr::select(concat,dup_todo) %>%
#  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd)) %>%
 # dplyr::select(row) %>%  summarise(mean(row), sd(row)) #, lo mismo que en STATA. Se supone que una row es sensible a cambios distintos.
  assign("CONS_C1_df_dup_FEB_2020_prev1",.,envir = .GlobalEnv)
#Lo mismo que en STATA: Ahora hay 118,072. Una vez que introduje 
#Ahora, 118035
#  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd), desc(fech_egres)) %>% criterio anterior
```

<br>

Once exact matches were discarded, we ended having `r nrow(CONS_C1_df_dup_FEB_2020_prev1) %>% formatC(, format="f", big.mark=",", digits=0)` cases.

<br>

An analysis based on the following criteria, ended with an index of how many differences within cases with the same HASH and date of admission, and in which variables can be tolerable to have differences. For example, if two or more cases share the same date of admission and hash, but most of the variables are different, it is possible to think that information may be lost if one of them is deleted. In another example, if two or more cases share the same date of admission and hash, but the only differences are observed in the days of treatment, one may think that only the case with more treatment days must be preserved.

- HASH_KEY=	Masked Identifier (RUT)
- Región.del.Centro=	Chilean Region of the Center
- dias_trat=	Days of Treatment
- Edad=	Year (Discrete Number)
- fech_ing=	Date of Admission to Treatment
- fech_egres=	Date of Discharge from Treatment
- ID.centro	Center ID
- id_mod=	SENDAs ID (mask characters 5 & 6)
- ano_nac=	Year of Birth (numeric)
- Edad_al_ing=	Age at Admission to Treatment
- edad_ini_cons=	Age of Onset of Drug Use
- edad_ini_sus_prin= Age of Onset of Drug Use Principal Substance
- tipo_centro= Type of Center
- Nacionalidad= Nationallity
- Etnia= Ethnicity
- Diagnóstico.Trs..Psiquiátrico.DSM.IV= Diagnosis of Psychiatric Disorders, DSM-IV criteria
- Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV= Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification)
- X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV= Diagnosis of Psychiatric Disorders, DSM-IV criteria (2)
- X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV= Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (2)
- X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV= Diagnosis of Psychiatric Disorders, DSM-IV criteria (3)
- X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV= Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (3)
- Diagnóstico.Trs..Psiquiátrico.CIE.10= Diagnosis of Psychiatric Disorders, CIE-10 criteria
- Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10= Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification)
- X2.Diagnóstico.Trs..Psiquiátrico.CIE.10= Diagnosis of Psychiatric Disorders, CIE-10 criteria (2)
- X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10= Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (2)
- X3.Diagnóstico.Trs..Psiquiátrico.CIE.10= Diagnosis of Psychiatric Disorders, CIE-10 criteria (3)
- X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10= Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (3)
- motivodeegreso= Cause of Discharge
- identidad.de.genero= Gender Identity
- sexo= Sex of User
- embarazo= Pregnant
- tipo_de_plan= Type of Plan
- tipo_de_programa= Type of Program
- dias_trat_alta_temprana= Less than 90 days in treatment
- motivodeegreso_mod= Cause of Discharge (with late and early withdrawal)
- sus_principal= Main Substance of Consumption
- otras_sus1= Other Substances (1)
- otras_sus2= Other Substances (2)
- otras_sus3= Other Substances (3)
- sus_ini= Starting Substance
- estado_conyugal= Marital Status
- estatus_ocupacional= Occupational Status
- cat_ocupacional= Occupational Category
- Edad_grupos= Age in groups
- origen_ingreso= Motive of Admission to Treatment
- escolaridad= Educational Attainment
- via_adm_sus_prin= Route of Administration of the Main Substance
- freq_cons_sus_prin= Frequency of Consumption of the Main Substance

```{r dedup_analisis_manual, echo=T, paged.print=TRUE}
criterios_show<-c('HASH_KEY', 'tipo_centro', 'Región.del.Centro', 'dias_trat', 
  'Edad', 'Nacionalidad', 'Etnia', 'Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
  'X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
  'X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
  'Diagnóstico.Trs..Psiquiátrico.CIE.10', 'Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
  'X2.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
  'X3.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 'fech_ing', 'fech_egres', 
  'motivodeegreso', 'ID.centro', 'identidad.de.genero', 'sexo', 'embarazo', 'tipo_de_plan', 'tipo_de_programa', 
  'id_mod', 'ano_nac', 'Edad_al_ing', 'edad_ini_cons', 'edad_ini_sus_prin', 'dias_trat_alta_temprana', 
  'motivodeegreso_mod', 'sus_principal', 'otras_sus1', 'otras_sus2', 'otras_sus3', 'sus_ini', 'estado_conyugal', 
  'estatus_ocupacional', 'cat_ocupacional', 'Edad_grupos', 'origen_ingreso', 'escolaridad', 
  'via_adm_sus_prin', 'freq_cons_sus_prin')

CONS_C1_df_dup_FEB_2020_prev1 %>%
  dplyr::group_by(HASH_KEY, fech_ing) %>% #primero genero la variable
  dplyr::mutate(HASH_fech_ing_reps = n(), HASH_fech_ing_apariciones=row_number()) %>%  #number of different variables by HASH.
  dplyr::ungroup() %>% #desagrupo
  dplyr::filter(HASH_fech_ing_reps>1) %>% #names() %>% copiar_nombres() #para rescatar nombres de la base de datos
  dplyr::group_by(HASH_KEY, fech_ing) %>% #primero genero la variable
  dplyr::mutate_at(vars(c('HASH_KEY', 'id', 'tipo_centro', 'Región.del.Centro', 'dias_trat', 
                   'Edad', 'Nacionalidad', 'Etnia', 'Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'Diagnóstico.Trs..Psiquiátrico.CIE.10', 'Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 'fech_ing', 'fech_egres', 
                   'motivodeegreso', 'ID.centro', 'identidad.de.genero', 'sexo', 'embarazo', 'tipo_de_plan', 'tipo_de_programa', 
                   'id_mod', 'ano_nac', 'Edad_al_ing', 'edad_ini_cons', 'edad_ini_sus_prin', 'dias_trat_alta_temprana', 
                   'motivodeegreso_mod', 'sus_principal', 'otras_sus1', 'otras_sus2', 'otras_sus3', 'sus_ini', 'estado_conyugal', 
                   'estatus_ocupacional', 'cat_ocupacional', 'Edad_grupos', 'origen_ingreso', 'escolaridad', 
                   'via_adm_sus_prin', 'freq_cons_sus_prin')), .funs = funs(`dups_hash_ing`=ifelse(n_distinct(.)>1,as.character(.),""))) %>% #el ptaje no depende de 
#cuantos duplicados tenga
    dplyr::mutate_at(vars(c('HASH_KEY', 'id', 'tipo_centro', 'Región.del.Centro', 'dias_trat', 
                   'Edad', 'Nacionalidad', 'Etnia', 'Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'Diagnóstico.Trs..Psiquiátrico.CIE.10', 'Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 'fech_ing', 'fech_egres', 
                   'motivodeegreso', 'ID.centro', 'identidad.de.genero', 'sexo', 'embarazo', 'tipo_de_plan', 'tipo_de_programa', 
                   'id_mod', 'ano_nac', 'Edad_al_ing', 'edad_ini_cons', 'edad_ini_sus_prin', 'dias_trat_alta_temprana', 
                   'motivodeegreso_mod', 'sus_principal', 'otras_sus1', 'otras_sus2', 'otras_sus3', 'sus_ini', 'estado_conyugal', 
                   'estatus_ocupacional', 'cat_ocupacional', 'Edad_grupos', 'origen_ingreso', 'escolaridad', 
                   'via_adm_sus_prin', 'freq_cons_sus_prin')), .funs = list(dups_hash_ing2 = ~n_distinct(.))) %>%
    dplyr::ungroup() %>%
    dplyr::mutate_at(vars(contains('_dups_hash_ing2')), .funs = list(~ifelse(.>1,1,0))) %>% #el ptaje no depende de cuantos duplicados tenga
    dplyr::mutate(n_of_diffs_within = rowSums(dplyr::select(., contains("_dups_hash_ing2")))) %>% 
#   janitor::tabyl(n_of_matches) #para ver cómo se distirbuye
#   dplyr::select(-contains("_dups_hash_ing")) %>% 
#   dplyr::select(,contains("_dups_hash_ing")) %>%
    dplyr::select("row", "ano_bd","HASH_fech_ing_reps","HASH_fech_ing_apariciones","n_of_diffs_within","id_mod", c(criterios_show, ends_with("_dups_hash_ing"), "SENDA")) %>%
  dplyr::arrange(n_of_diffs_within, HASH_KEY, desc(ano_bd)) %>% as.data.frame() %>%  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 1. Cases with the same date of admission and HASH, for visual analysis",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::add_footnote( c("Note. HASH_fech_ing_reps= Times that HASH and Date of Admission is repeated;", "HASH_fech_ing_apariciones= Ordered number of registries with the same HASH and Date of Admission;", "n_of_diffs_within= Sum of the differences in each selected variable (0 if there is a difference, 1 if not) within cases that share the same HASH and Date of Admission, of a total of 49 selected variables"), notation = "none") %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
```

&nbsp;

The process applied is shown in Figure 1. We must recognize that the election of the word "consider" is not arbitrary, principally because this stage required a more careful analysis of each case. So, more than the application of strict partial rules, we applied these criteria as the combination of the whole.

<br>

```{r image-decision_tree_duplicated_entries, echo=FALSE, fig.align='center', fig.pos='H', fig.cap= "Figure 1. Decision Tree for the Discard of Duplicated Cases", message=FALSE}
knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/Duplicated_entries_decision_tree.svg")
```

```{r dedup_analisis_manual_export, echo=T, include=F, paged.print=TRUE}
#Tengo que llegar a este número
###117,619
criterios<-c('HASH_KEY', 'id', 'tipo_centro', 'Región.del.Centro', 'dias_trat', 
  'Edad', 'Nacionalidad', 'Etnia', 'Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
  'X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
  'X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
  'Diagnóstico.Trs..Psiquiátrico.CIE.10', 'Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
  'X2.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
  'X3.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 'fech_ing', 'fech_egres', 
  'motivodeegreso', 'ID.centro', 'identidad.de.genero', 'sexo', 'embarazo', 'tipo_de_plan', 'tipo_de_programa', 
  'id_mod', 'ano_nac', 'Edad_al_ing', 'edad_ini_cons', 'edad_ini_sus_prin', 'dias_trat_alta_temprana', 
  'motivodeegreso_mod', 'sus_principal', 'otras_sus1', 'otras_sus2', 'otras_sus3', 'sus_ini', 'estado_conyugal', 
  'estatus_ocupacional', 'cat_ocupacional', 'Edad_grupos', 'origen_ingreso', 'escolaridad', 
  'via_adm_sus_prin', 'freq_cons_sus_prin')

CONS_C1_df_dup_FEB_2020_prev1 %>%
  dplyr::group_by(HASH_KEY, fech_ing) %>% #primero genero la variable
  dplyr::mutate(HASH_fech_ing_reps = n(), HASH_fech_ing_apariciones=row_number()) %>%  #number of different variables by HASH.
  dplyr::ungroup() %>% #desagrupo
  dplyr::filter(HASH_fech_ing_reps>1) %>% #names() %>% copiar_nombres() #para rescatar nombres de la base de datos
  dplyr::group_by(HASH_KEY, fech_ing) %>% #primero genero la variable
   dplyr::mutate_at(vars(c('HASH_KEY', 'id', 'tipo_centro', 'Región.del.Centro', 'dias_trat', 
                   'Edad', 'Nacionalidad', 'Etnia', 'Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'Diagnóstico.Trs..Psiquiátrico.CIE.10', 'Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 'fech_ing', 'fech_egres', 
                   'motivodeegreso', 'ID.centro', 'identidad.de.genero', 'sexo', 'embarazo', 'tipo_de_plan', 'tipo_de_programa', 
                   'id_mod', 'ano_nac', 'Edad_al_ing', 'edad_ini_cons', 'edad_ini_sus_prin', 'dias_trat_alta_temprana', 
                   'motivodeegreso_mod', 'sus_principal', 'otras_sus1', 'otras_sus2', 'otras_sus3', 'sus_ini', 'estado_conyugal', 
                   'estatus_ocupacional', 'cat_ocupacional', 'Edad_grupos', 'origen_ingreso', 'escolaridad', 
                   'via_adm_sus_prin', 'freq_cons_sus_prin')), .funs = funs(`dups_hash_ing`=ifelse(n_distinct(.)>1,as.character(.),""))) %>%
  dplyr::mutate_at(vars(c('HASH_KEY', 'id', 'tipo_centro', 'Región.del.Centro', 'dias_trat', 
                   'Edad', 'Nacionalidad', 'Etnia', 'Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV', 
                   'Diagnóstico.Trs..Psiquiátrico.CIE.10', 'Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X2.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 
                   'X3.Diagnóstico.Trs..Psiquiátrico.CIE.10', 'X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10', 'fech_ing', 'fech_egres', 
                   'motivodeegreso', 'ID.centro', 'identidad.de.genero', 'sexo', 'embarazo', 'tipo_de_plan', 'tipo_de_programa', 
                   'id_mod', 'ano_nac', 'Edad_al_ing', 'edad_ini_cons', 'edad_ini_sus_prin', 'dias_trat_alta_temprana', 
                   'motivodeegreso_mod', 'sus_principal', 'otras_sus1', 'otras_sus2', 'otras_sus3', 'sus_ini', 'estado_conyugal', 
                   'estatus_ocupacional', 'cat_ocupacional', 'Edad_grupos', 'origen_ingreso', 'escolaridad', 
                   'via_adm_sus_prin', 'freq_cons_sus_prin')), .funs = list(dups_hash_ing2 = ~n_distinct(.))) %>%
  ##DE 49 VARIABLES, CUENTA LAS QUE HAY MAS DE UN VALOR DISTINTO ENRE EL GRUPO  
  dplyr::ungroup() %>%
    dplyr::mutate_at(vars(contains('_dups_hash_ing2')), .funs = list(~ifelse(.>1,1,0))) %>% #el ptaje no depende de cuantos duplicados tenga
    dplyr::mutate(n_of_diffs_within = rowSums(dplyr::select(., contains("_dups_hash_ing2")))) %>% 
#  janitor::tabyl(n_of_matches) #para ver cómo se distirbuye
#  dplyr::select(-contains("_dups_hash_ing")) %>% 
#  dplyr::select(,contains("_dups_hash_ing")) %>%
  dplyr::select("row", "ano_bd","HASH_fech_ing_reps","HASH_fech_ing_apariciones","n_of_diffs_within", c(criterios, ends_with("_dups_hash_ing"), "SENDA")) %>%
  dplyr::arrange(n_of_diffs_within, HASH_KEY, desc(ano_bd)) %>% as.data.frame() %>% guardar_tablas("_matches_feb_2020")
#anyDuplicated returns the index i of the first duplicated entry if there is one, and 0 otherwise.
 #anyDuplicated(CONS_C1_df_dup_FEB_2020_prev1_dt, by=c("HASH_KEY", "fech_ing"))
```

<br>

Of the `r length(criterios)` variables, we seen that many cases had different sexes, others are registries mostly from 2010 to 2015. Additionally, some diagnostics did not appear previously in the last registry. Other programs specific for women are changed in the next case for the general population. In general, we keeped most recent cases, excepting for a few rows, such as "4118", that came from the same year of the row "4842" and share almost the same information but underestimated the frequency of consumption of the principal substance. Another case is row "38147", that share almost every characteristic with row "38755", excepting that this row lacked the occupational status and underestimated the frequency of consumption of the principal substance. Same with row "9875", that shared almost every variable with row "7161", but had less information about diagnostics related to mental health, despite they had distinct information regarding to drug use (other substances 2 and 3).

<br>

```{r filter_cases_duplicated, echo=T, include=T, paged.print=TRUE}
dup_rows_by_obs_an <-c('44441', '59632', '4118', '83870', '33668', '38147', '13748', '24327', '7161', '6547', '37013', '96781', '57407', '15363', '63133', '196', '93528', '30670', '58550', '72253', '54650', '25716', '70547', '8320', '22332', '25251', '79519', '59842', '30734', '1105', '53959', '37294', '24936', '49352', '61282', '28687', '13729', '59555', '21165', '28500', '61274', '74897', '22331', '36731', '80950', '54760', '48977', '15410', '14641', '71758', '15744', '15526', '9099', '29791', '22330', '61287', '60502', '59556', '4739', '46724', '30276', '21166', '41795', '60507', '54776', '21574', '18237', '22228', '23061', '74444', '72556', '39592', '450', '54383', '35913', '30644', '23062', '3874', '3957', '72933', '8590', '13236', '30717', '54745', '31417', '23949', '24776', '9433', '45379', '53402', '71735', '37885', '21664', '14645', '25817', '9092', '31514', '2682', '37166', '57409', '38288', '18774', '6331', '67013', '34282', '77761', '2038', '84270', '22347', '41793', '30178', '22307', '57171', '27222', '25562', '39361', '3702', '28830', '14291', '137746', '20396', '4530', '53672', '42633', '29792', '15480', '55412', '57056', '89084', '59799', '57052', '6943', '61275', '14280', '17704', '45685', '9006', '35723', '23583', '83762', '4490', '57391', '7328', '15237', '14664', '77874', '12979', '36160', '62447', '121921', '3854', '66842', '15235', '46461', '74484', '15412', '5497', '25123', '47029', '45781', '6332', '13945', '52207', '45018', '44514', '2665', '52774', '8159', '37243', '13482', '31500', '26528', '549', '39944', '15386', '70295', '45306', '30352', '15688', '4735', '3191', '61079', '42627', '40610', '12495', '62097', '46463', '22612', '44794', '25013', '2284', '32219', '61281', '64011', '9318', '135017', '16319', '23355', '20118', '18281', '41599', '63035', '5493', '23280', '7698', '21397', '8352', '31750', '58055', '25429', '22249', '18952', '4984', '40210', '27202', '31341', '35645', '57410', '68566', '77886', '15416', '13309', '20154', '37926', '7250', '34556', '76210', '30713', '322', '20041', '18232', '14457', '1866', '59271', '25117', '31743', '26552', '58187', '28481', '18099', '16185', '1798', '23372', '57885', '46333', '6508', '16275', '27262', '17379', '10900', '14656', '7581', '11641', '39151', '78898', '24269', '5072', '21080', '63034', '20479', '15278', '70927', '7604', '6799', '34933', '14814', '340', '26721', '31621', '23299', '462', '12510', '7160', '46351', '5074', '12839', '4713', '6864', '4976', '37220', '23362', '11969', '37722', '35729', '441', '16189', '5536', '24449', '77163', '46455', '8767', '36167', '30552', '14616', '13956', '30568', '31424', '29523', '20704', '132268', '6346', '14051', '12484', '25164', '13276', '1618', '18713', '10495', '18468', '13128', '12838', '7182', '2523', '9719', '18651', '23586', '74757', '6334', '5571', '26424', '6794', '4801', '35841', '35831', '29608', '41005', '18712', '18649', '18934', '18170', '27956', '37271', '29885', '6202', '32299', '16172', '3865', '2319', '11163', '27214', '11552', '29380', '28514', '11365', '1794', '429', '61631', '12540', '21363', '23326', '38864', '11300', '14040', '9473', '36039', '27721', '63525', '43722', '19448', '18950', '8403', '22188', '3862', '2629', '15904', '15256', '8765', '23581', '16082', '74024', '14096', '75750', '1789', '27712', '25180', '21231', '17566', '72221', '31361', '16212', '8334', '17664', '11117', '31628', '31558', '23842', '16836', '27226', '16326', '57544', '30563', '54953', '22028', '11465', '7623', '27964', '23588', '31266', '16173', '11837', '6867', '4641', '15768', '23437', '16807', '11807', '3974', '14057', '12517', '8752', '8013', '23300', '12516', '8153', '5031', '582')
###igual creo que si uno quisiese automatizar el proceso, sólo necesitaría sacar el primero de cada fila con slice row number grouped by hash fech ing y no se complica más.
CONS_C1_df_dup_FEB_2020_prev1 %>%
  dplyr::filter(!row %in% dup_rows_by_obs_an) %>%
  clean_names() %>%
  assign("CONS_C1_df_dup_FEB_2020_prev2",.,envir = .GlobalEnv)
#117,619
```

<br>

Once done the manual discard of duplicated cases, we ended having `r nrow(CONS_C1_df_dup_FEB_2020_prev2) %>% formatC(, format="f", big.mark=",", digits=0)` cases.

<br>

### Deduplication from the Overlap Between Dates of Admission & Discharge

&nbsp;
<br>
Once discarded duplicated cases, we searched for cases in which dates ranges were overlapped with other treatments for the same user (HASH).This required to temporarily replace those cases that did not have a date of dischage, with the date of retrieval of the datasets, that is "2019-11-13". 

<br>

```{r  overlap1,echo=T, paged.print=TRUE}
CONS_C1_df_dup_intervals_FEB_2020<- CONS_C1_df_dup_FEB_2020_prev2 %>%
  #as.numeric(as.Date("2019-11-13")) #18213
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(fech_egres_num2=ifelse(is.na(fech_egres),18213,fech_egres_num2)) %>% #equivalente a 2019-11-13
  dplyr::rename("hash_key_2"="hash_key", "row2"="row") %>%
  dplyr::select(row2,hash_key_2, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,edad, dias_trat,id_centro, motivodeegreso, senda) %>% 
  #dplyr::filter(motivodeegreso!="Derivación") %>%
  data.table::as.data.table()
require(sqldf)
require(gridExtra)
  overlap_dates_C1_FEB_2020 <- janitor::clean_names(sqldf("SELECT *
                 FROM CONS_C1_df_dup_intervals_FEB_2020 AS x  
                 INNER JOIN CONS_C1_df_dup_intervals_FEB_2020 AS y 
                 ON x.hash_key_2 == y.hash_key_2 AND 
                 x.fech_ing_num2 < y.fech_egres_num2 AND x.fech_egres_num2 > y.fech_ing_num2 AND x.row2 != y.row2"))  
  
  #busca mismo hash, distinto row,pero fecha de ingreso menor o igual a la fecha de egreso del otro, y fecha de egreso mayor o igual a la fecha de ingreso del otro. lo del row ES PARA DESCARTAR CASOS QUE SE SUPERPONEN CONSIGMO MISMO.
overlap_dates_C1_FEB_2020 %>%
  as.data.table() %>%
  dplyr::rename("row_1"="row2", "row_2"="row2_2", "fech_ing_num_1"="fech_ing_num2", "fech_ing_num_2"="fech_ing_num2_2") %>%
  dplyr::mutate(caso_2_mas_reciente=ifelse(as.numeric(fech_ing_num_2)>as.numeric(fech_ing_num_1),1,0)) %>% #ver si el dato de la izq es más aniguo
  dplyr::arrange(desc(caso_2_mas_reciente)) %>% #NO AFECTA PORQUE SIEMPRE COMPARATIVAMENTE UNO SERÁ MÁS RECIENTE QUE EL OTRO. además no lo hace con variable número sino con fecha.
  dplyr::select(row_1, row_2) %>%
  dplyr::mutate(prod_row=as.numeric(row_1)*as.numeric(row_2), sum_row=as.numeric(row_1)+as.numeric(row_2), filter_row=paste0(prod_row,"_",sum_row)) %>%
  dplyr::filter(!duplicated(filter_row)) %>% #dejé sólo los casos que son más recientes. Se supone q no perdí casos, sino que saqué los duplicados
  dplyr::select(row_1, row_2) %>%
  panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
    as.data.table() %>%
  assign("CONS_C1_df_dup_FEB_2020_overlaps",.,envir = .GlobalEnv)

#EL DE LA IZQUIERDA TIENDE A SER MÁS ANTIGUO QUE EL DE LA DERECHA, CONSTE
CONS_C1_df_dup_FEB_2020_overlaps %>%
  dplyr::left_join(dplyr::select(CONS_C1_df_dup_FEB_2020_prev2,row,ano_bd, hash_key,id_mod, fech_egres, fech_ing, id_centro,dias_trat,id_centro,motivodeegreso,senda), by="row") %>%   
  dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(fech_egres_num=ifelse(is.na(fech_egres),18213,fech_egres_num)) %>% #equivalente a 2019-11-13
reshape(idvar="id", timevar="wave", direction="wide",sep="_") %>%
  dplyr::mutate(mismo_id_centro=ifelse(id_centro_1==id_centro_2,1,0)) %>%
  dplyr::mutate(bd_2_mas_reciente=ifelse(ano_bd_2>ano_bd_1,1,0)) %>% #es el dato de la derecha de una base de datos mas reciente.
  dplyr::mutate(senda= ifelse(senda_1=="Si" & senda_2=="Si","Si Ambos",
                        ifelse(senda_1=="No" & senda_2=="No","No Ambos",
                              ifelse(senda_1=="No" & senda_2=="Si","Si 2",
                                     ifelse(senda_1=="Si" & senda_2=="No","No 2",NA))))) %>%
  dplyr::mutate(Derivacion= ifelse(motivodeegreso_1=="Derivación",1,0)) %>%
  dplyr::mutate(days_overlapped=fech_egres_num_1-fech_ing_num_2) %>% # para que hayan dias positivos. Se supone que la fecha de egreso es más reciente que la fecha de ingreso del evento que superpone.
  dplyr::mutate(mas_dias_trat=ifelse(dias_trat_2>dias_trat_1,1,0)) %>% #más días tratado en 2
  dplyr::select(-hash_key_2) %>%
    assign("CONS_C1_df_dup_FEB_2020_overlaps_COMP",.,envir = .GlobalEnv)
####
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 2. Cases with overlapped treatment ranges",
                 align =rep('c', 101))  %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::add_footnote( c("Note.Each row represents an overlap. Variables ending with '_1' are the first case, and variables ending with '_2' correspond to the second case;", "mismo_id_centro= If both cases share the same Center ID", "bd_2_mas_reciente= Year of the yearly dataset is more recent in the second case;", "senda= If both cases are financed by SENDA;", "Derivación= If the cause of discharge is the referral from another center (1= Referral);","days_overlapped= Difference between the date of admission of the earlier treatment, and the date of discharge of the latter treatment","mas_dias_trat= Earlier treatment has more days of treatment"), notation = "none") %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#FOR COMPARISON
#panelr::long_panel(CONS_C1_df_dup_FEB_2020_overlaps, prefix = "_", label_location = "end", begin = 1, end = 2) %>% 
#  #dplyr::select(-hash_key_2) %>%
#  dplyr::rename("overlap_id"="id") %>%
#  guardar_tablas("_overlaps_feb_2020")
```


We identified `r CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%  nrow() %>% formatC(, format="f", big.mark=",", digits=0)` overlappings. For those cases with less or equal to 30 days of treatment, we substracted the days overlapped between the date of discharge of the first treatment and the date of admission of the next treatment. This process can be seen in Figure 2. Some of the users appearing more than one time (n= `r CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%group_by(hash_key_1) %>% dplyr::filter(!is.na(fech_egres_2),!is.na(fech_egres_1)) %>% dplyr::mutate(mas_de_un_row=n_distinct(row_1)) %>% ungroup() %>% filter(mas_de_un_row>1) %>% nrow()`). Those users may have competing dates of discharge, that will have to be chosen based on their individual trajectores.


```{r image-decision_tree_overlapped_cases, echo=FALSE, fig.align='center', fig.pos='H', fig.cap= "Figure 2. Decision Tree for the Discard of Overlapping Dates in Cases", message=FALSE}
knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/overlapped_ranges_decision_tree.svg")
```

It might be possible that treatments that are not qualified as financed by SENDA might be effectivelly financed by SENDA. However, also the SENDA's professional stated that Senda only checked information of the treatments that are recognized as financed by SENDA. 

Four alternatives were delimited in order to resolve overlapped dates:

- Impute treated days, and replacing the date of discharge
- Keep the earliest treatment
- Discard the earliest treatment
- Substract days to the date of discharge of the last treatment

Must note that between the cases that have overlapped treatment days in different centers, these are the cases that repeat most:

- 109	"COSAM Concepcion"	to 117	"Comunidad Terapeutica Villamavida"
- 328	"COSAM Alenmoguen "	to 	502	"Centro de Responsabilidad de Salud Mental del Complejo Asistencial Dr.Victor Rios Ruiz"
- 502	"Centro de Responsabilidad de Salud Mental del Complejo Asistencial Dr.Victor Rios Ruiz"	to 	123	"COSAM Newen"
- 123	"COSAM Newen"		to 117	"Comunidad Terapeutica Villamavida"
- 161	"Centro Comunitario de Salud Mental Familiar (COSAM Pudahuel)"	to 147	"Comunidad Terapeutica Manresa"
- 502	"Centro de Responsabilidad de Salud Mental del Complejo Asistencial Dr.Victor Rios Ruiz"	to 328	"COSAM Alenmoguen "
- 166	"COSAM Enrique Paris"	to 171	"Hospital de Dia Iquique" 

<br>

```{r 0a_menos_30_dias_superpuestos,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
  dplyr::mutate(row_id=paste0(row_1,"_",row_2)) %>%
  dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
  panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
  as.data.frame(.) %>% 
  dplyr::arrange(id, desc(fech_ing_num)) %>%
  dplyr::group_by(id) %>%
  dplyr::mutate(fech_egres_num_imp=ifelse(days_overlapped<=30,dplyr::lag(fech_ing_num),NA)) %>% 
  ungroup() %>%
  dplyr::filter(wave==1) %>% 
  dplyr::filter(days_overlapped<=30) %>%
  dplyr::select(row,fech_egres_num_imp) %>%
  as.data.frame(.) %>% 
   # dplyr::filter(row=="36873"), tiene más de una fecha de egreso.
  dplyr::filter(!duplicated(row)) %>% 
  dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev2, by="row") %>% #nrow()
  dplyr::select(everything(),fech_egres_num_imp) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev3",.,envir = .GlobalEnv) #117,620
 # assign("CONS_C1_df_dup_FEB_2020_overlaps_less_30_days",.,envir = .GlobalEnv)
# la fecha de egreso es NA en algunos. Cuidado, podría estar imputando sin querer
#por lo visto no, porque son todos wave 2, lo que significa que le antecede una fecha posterior:
#CONS_C1_df_dup_FEB_2020_overlaps_less_30_days %>% group_by(wave) %>% summarise(n())
####
#CONS_C1_df_dup_FEB_2020_overlaps_less_30_days %>% dplyr::group_by(row) %>% dplyr::summarise(n=n()) %>% dplyr::filter(n>1)
####
#39524 48099 tienen más de una fecha agregada, lo que significa que pueden contraponerse.
 
```

```{r 0b_dias_trat_igual_0,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
  dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
  dplyr::filter(dias_trat_2==0) %>% #filter treatments with 0 days in the second treatment
  dplyr::select(row_2) %>%
  assign("filas_superpuestas_con_0_dias_trat",.,envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev3 %>%
 dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(filas_superpuestas_con_0_dias_trat)))))) %>% # Select HASHs of cited cases
  assign("CONS_C1_df_dup_FEB_2020_prev4",.,envir = .GlobalEnv)
```

```{r 3a_mismo_id_centro_si_absorvidos,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==1) %>%
    dplyr::filter(senda=="Si Ambos"|senda=="No Ambos") %>%
    dplyr::mutate(trat_1_absorve_a_2=ifelse(fech_egres_num_1>fech_egres_num_2,1,0)) %>%
    dplyr::filter(trat_1_absorve_a_2==1) %>%
    dplyr::select(row_2) %>%
  assign("same_center_id_both_same_senda_abosrved_by_latter_treatment",.,envir = .GlobalEnv)
#80 casos
CONS_C1_df_dup_FEB_2020_prev4 %>%
 dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(same_center_id_both_same_senda_abosrved_by_latter_treatment)))))) %>% # Select HASHs of cited cases
  assign("CONS_C1_df_dup_FEB_2020_prev5",.,envir = .GlobalEnv)
```

```{r 4a_mismo_id_centro_si_no_absorvidos_derivados,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==1) %>%
    dplyr::filter(senda=="Si Ambos"|senda=="No Ambos") %>%
    dplyr::mutate(trat_1_absorve_a_2=ifelse(fech_egres_num_1>fech_egres_num_2,1,0)) %>%
    dplyr::filter(trat_1_absorve_a_2==0) %>%
    dplyr::filter(Derivacion==1) %>% 
  panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
    as.data.frame(.) %>%
    dplyr::arrange(id, desc(fech_ing_num)) %>%
    dplyr::group_by(id) %>%
    dplyr::mutate(fech_egres_num_imp_2=dplyr::lag(fech_ing_num)) %>%
    ungroup() %>%
    dplyr::filter(wave==1) %>% #dim() 35
  # 14074 12180 336 8809, duplicados
    dplyr::filter(!duplicated(row)) %>% 
    dplyr::select(row,fech_egres_num_imp_2) %>% 
    as.data.frame(.) %>% 
    dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev5, by="row") %>%
    dplyr::select(everything(),fech_egres_num_imp_2) %>% 
    assign("CONS_C1_df_dup_FEB_2020_prev6",.,envir = .GlobalEnv) #117,540
#CONS_C1_df_dup_FEB_2020_prev5 ==117540
```

```{r 4b_mismo_id_centro_si_no_absorvidos_no_derivados,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==1) %>%
    dplyr::filter(senda=="Si Ambos"|senda=="No Ambos") %>%
    dplyr::mutate(trat_1_absorve_a_2=ifelse(fech_egres_num_1>fech_egres_num_2,1,0)) %>%
    dplyr::filter(trat_1_absorve_a_2==0) %>%
    dplyr::filter(Derivacion==0) %>% 
  panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
    as.data.frame(.) %>%
    dplyr::arrange(id, desc(fech_ing_num)) %>%
    dplyr::group_by(id) %>%
    dplyr::mutate(fech_egres_num_imp_22=dplyr::lag(fech_ing_num)) %>%
    ungroup() %>%
    dplyr::filter(wave==1) %>% #dim() 35
  # 14074 12180 336 8809, duplicados
    dplyr::filter(!duplicated(row)) %>% 
    dplyr::select(row,fech_egres_num_imp_22) %>%
    dplyr::mutate(motivodeegreso_cor2="Derivación") %>% #agrego un motivo de eegreso a corregir
    as.data.frame(.) %>% 
    dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev6, by="row") %>%
    dplyr::select(everything(),fech_egres_num_imp_22, motivodeegreso_cor2) %>% 
    assign("CONS_C1_df_dup_FEB_2020_prev7",.,envir = .GlobalEnv) #117,540
#CONS_C1_df_dup_FEB_2020_prev5 ==117540
```

```{r 2b1_distinct_senda_earlier,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==1) %>%
    dplyr::filter(senda=="Si 2") %>%
    dplyr::select(row_1) %>%
    assign("same_center_id_earlier_treat_senda_yes",.,envir = .GlobalEnv) #9
CONS_C1_df_dup_FEB_2020_prev7 %>%
 dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(same_center_id_earlier_treat_senda_yes)))))) %>% # Select HASHs of cited cases
  assign("CONS_C1_df_dup_FEB_2020_prev8",.,envir = .GlobalEnv) #117,532  
```

```{r 2b2_distinct_senda_latter,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==1) %>%
    dplyr::filter(senda=="No 2") %>% 
    dplyr::select(row_2) %>% #porque estamos elminando la última
    assign("same_center_id_latter_treat_senda_yes",.,envir = .GlobalEnv) #19
CONS_C1_df_dup_FEB_2020_prev8 %>%
 dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(same_center_id_latter_treat_senda_yes)))))) %>% # Select HASHs of cited cases
  assign("CONS_C1_df_dup_FEB_2020_prev9",.,envir = .GlobalEnv) #117,532
```

```{r 35b_distinto_id_centro_si_absorvidos_mismo_ano_bd,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==0) %>%
    dplyr::filter(senda=="Si Ambos"|senda=="No Ambos") %>%
    dplyr::mutate(trat_1_absorve_a_2=ifelse(fech_egres_num_1>fech_egres_num_2,1,0)) %>%
    dplyr::filter(trat_1_absorve_a_2==1) %>%
    dplyr::filter(bd_2_mas_reciente==0) %>% #68
    dplyr::select(row_2) %>% #tomo los más nuevos para descartarlos, porque se superponen
  assign("diff_center_id_both_same_senda_abosrved_by_latter_treatment_mismo_ano_bd",.,envir = .GlobalEnv)
#80 casos
CONS_C1_df_dup_FEB_2020_prev9 %>%
 dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(diff_center_id_both_same_senda_abosrved_by_latter_treatment_mismo_ano_bd)))))) %>% # Select HASHs of cited cases
  assign("CONS_C1_df_dup_FEB_2020_prev10",.,envir = .GlobalEnv)# 63 casos efectivos q se restan #117,449  
```

```{r 4a_distinto_id_centro_no_absorvido_derivacion_si,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==0) %>%
    dplyr::filter(senda=="Si Ambos"|senda=="No Ambos") %>%
    dplyr::mutate(trat_1_absorve_a_2=ifelse(fech_egres_num_1>fech_egres_num_2,1,0)) %>%
    dplyr::filter(trat_1_absorve_a_2==0) %>%
    dplyr::filter(Derivacion==1) %>%  #55
panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
    as.data.frame(.) %>%
    dplyr::arrange(id, desc(fech_ing_num)) %>%
    dplyr::group_by(id) %>%
    dplyr::mutate(fech_egres_num_imp_3=dplyr::lag(fech_ing_num)) %>%
    ungroup() %>%
    dplyr::filter(wave==1) %>% #dim() 55
  # no hay duplicados pero por si
    dplyr::filter(!duplicated(row)) %>% 
    dplyr::select(row,fech_egres_num_imp_3) %>% 
    as.data.frame(.) %>% 
    dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev10, by="row") %>%
    dplyr::select(everything(),fech_egres_num_imp_3) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev11",.,envir = .GlobalEnv)# #117449  
```

```{r 4b_distinto_id_centro_no_absorvido_derivacion_no,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==0) %>%
    dplyr::filter(senda=="Si Ambos"|senda=="No Ambos") %>%
    dplyr::mutate(trat_1_absorve_a_2=ifelse(fech_egres_num_1>fech_egres_num_2,1,0)) %>%
    dplyr::filter(trat_1_absorve_a_2==0) %>%
    dplyr::filter(Derivacion==0) %>%  #55
panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
    as.data.frame(.) %>%
    dplyr::arrange(id, desc(fech_ing_num)) %>%
    dplyr::group_by(id) %>%
    dplyr::mutate(fech_egres_num_imp_32=dplyr::lag(fech_ing_num)) %>%
    ungroup() %>%
    dplyr::filter(wave==1) %>% #dim() 24
  # no hay duplicados pero por si
    dplyr::filter(!duplicated(row)) %>% 
    dplyr::select(row,fech_egres_num_imp_32) %>% 
    dplyr::mutate(motivodeegreso_cor3="Derivación") %>% #agrego un motivo de eegreso a corregir
    as.data.frame(.) %>% 
    dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev11, by="row") %>%
    dplyr::select(everything(),fech_egres_num_imp_32,motivodeegreso_cor3) %>% 
  assign("CONS_C1_df_dup_FEB_2020_prev12",.,envir = .GlobalEnv)# #117449  
```

```{r 2b1_distinct_centre_distinct_senda_earlier,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==0) %>%
    dplyr::filter(senda=="Si 2") %>% #11
    dplyr::select(row_1) %>% 
    assign("diff_center_id_earlier_treat_senda_yes",.,envir = .GlobalEnv) #9
CONS_C1_df_dup_FEB_2020_prev12 %>%
 dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(diff_center_id_earlier_treat_senda_yes)))))) %>% # Select HASHs of cited cases
  assign("CONS_C1_df_dup_FEB_2020_prev13",.,envir = .GlobalEnv) #117,438   #11
```

```{r 2b2__distinct_centre_distinct_senda_latter,echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%
    dplyr::filter(!is.na(fech_egres_1)) %>% #Overlap due to missing values in the date of discharge of the latter treatment
    dplyr::filter(days_overlapped>30) %>%
    dplyr::filter(dias_trat_2!=0) %>% #filter treatments with 0 days in the second treatment
    dplyr::filter(mismo_id_centro==0) %>%
    dplyr::filter(senda=="No 2") %>% #45
    dplyr::select(row_2) %>% #porque estamos elminando la última
    assign("diff_center_id_latter_treat_senda_yes",.,envir = .GlobalEnv)
CONS_C1_df_dup_FEB_2020_prev13 %>%
 dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(diff_center_id_latter_treat_senda_yes)))))) %>% # Select HASHs of cited cases
  assign("CONS_C1_df_dup_FEB_2020_prev14",.,envir = .GlobalEnv) #117,393 #menos 45, esto.
```

<br>

---

<br>

Of the overlapping variables dates, `r CONS_C1_df_dup_FEB_2020_overlaps_COMP %>% dplyr::filter(is.na(fech_egres_1)) %>% nrow()` cases had missing values in the date of discharge of the latter treatment, generating confusion when it comes to analyse the trajectories of a user from 2010 to 2019. There were `r CONS_C1_df_dup_FEB_2020_overlaps_COMP %>% dplyr::filter(is.na(fech_egres_2)) %>% nrow()` cases had missing values in the second treatment, but these were not relevant, because these may not interfere or overlap with the following treatment. In Table 3, we may find the different treatments available for users that have at least one treatment with a missing date of discharge. **These cases were sent to SENDA's professional previously, and filtered and resended on February 24**. Meanwhile, two possible alternatives would be to fill the date of discharge with the date of admission of the next treatment, or to impute those missing data based on other cases. However, this imputation must avoid overlapping with the following date.

<br>

```{r  Miss_val_date_discharge_to_impute,echo=T, cache=T, paged.print=TRUE, warning=F}
fech_egres_na_overlap<- CONS_C1_df_dup_FEB_2020_overlaps_COMP %>% dplyr::filter(is.na(fech_egres_1)) %>% distinct(hash_key_1)
#son 14 hashs con datos perdidos en la fecha de egreso
#probablemente los otros casos perdidos correspondan a personas que sólo tenían un evento no más.
CONS_C1_df_dup_FEB_2020_prev14 %>%
  dplyr::filter(is.na(fech_egres_num_imp_32),is.na(fech_egres_num_imp_3),is.na(fech_egres_num_imp_22),is.na(fech_egres_num_imp_2),is.na(fech_egres_num_imp))%>%
  dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(fech_egres_na_overlap)))))) %>% # select hashs of wrongly assigned ages
  dplyr::arrange(hash_key, desc(fech_ing)) %>% 
  dplyr::group_by(hash_key) %>% 
  dplyr::mutate(fech_egres_imp_NA = dplyr::lag(fech_ing, n = 1, default = NA), fech_egres_imp_NA=ifelse(is.na(fech_egres),as.character(fech_egres_imp_NA),as.character(fech_egres))) %>%
  dplyr::mutate(dias_trat_imp= as.numeric(as.Date(fech_egres_imp_NA))-as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(dias_trat_alta_temprana_imp=ifelse(dias_trat_imp>=90,0,1)) %>%
  dplyr::mutate(dias_trat_alta_temprana_imp=as.factor(dias_trat_alta_temprana_imp)) %>%
  dplyr::mutate(dias_trat_alta_temprana_imp= dplyr::recode(dias_trat_alta_temprana_imp, "1"="Menos de 90 días", "0"="Mayor o igual a 90 días")) %>%
#  dplyr::mutate(motivodeegreso_mod_imp= ifelse(dias_trat_alta_temprana_imp=="Menos de 90 días" & motivodeegreso=="Abandono", "Abandono #Temprano",as.character(motivodeegreso))) %>% ## CONSTE QUE ESTO NO VA A FUNCIONAR PORQUE ES NA EL MOTIVO DE EGRESO
  #dplyr::mutate(motivodeegreso_mod_imp= ifelse(dias_trat_alta_temprana_imp=="Mayor o igual a 90 días" & motivodeegreso=="Abandono", "Abandono Tardio",as.character(motivodeegreso_mod_imp))) %>% 
  #dplyr::mutate(motivodeegreso_mod_imp=as.factor(motivodeegreso_mod_imp)) %>%
  dplyr::select(row,hash_key, ano_bd, fech_ing, fech_egres, fech_egres_imp_NA,dias_trat, dias_trat_imp,dias_trat_alta_temprana_imp,senda, id_centro, motivodeegreso_mod, tipo_de_plan_2) %>% #print()
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 3. Cases with missing values in the date of discharge and Simple Imputation Assuming Continuous Treatments",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::add_footnote( c("Note.fech_egres_imp_NA= Imputed Date of Discharge Based on the Following Date of Admission", "dias_trat_imp= Imputed Days of Treatment Based on the Following Date of Admission", "dias_trat_alta_temprana_imp= Days of Tratment (Less than 90 days) incluiding Imputed Data Based on the Following Date of Admission"), notation = "none") %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#si tiene un caso más, significa que con ese caso se detectó el overlap.
#001022ffb28057b24dd76900bbf1e3de   no hay problemas. sólo tiene 1 caso más
#0d7fe0ff18f5b16868a68ca5ee5d4b87   no hay problemas. sólo tiene 1 caso más
#137e8525aa3f79235fa8ad90913fdcbe   no hay problemas, sólo tiene 1 caso más después del que tiene perdida la fecha
#144b8d70d7ea1b9ea70d2ef7543520b2   no hay problemas, sólo tiene 1 caso más después del que tiene perdida la fecha
#1baff032eb17af74d98d63542c87423a   no hay problemas, sólo tiene 1 caso más después del que tiene perdida la fecha
#1d53b9a82ab4fbc0e6cfa109d664eb51   complicado
#2a9e74353a3177ed278508f91265e4b4   debiese quedar con fecha 2010-04-29
#3e23f3c3cbedb2aa1003e6a9d03eb070   podría ser el 2011-04-12 en el primer caso.
#57b4de7542dfab3c29b6705cb392ff8a   2012-02-16
#9803638c4b8ca2a0920ea15bcc024da5

#CREO QUE PODRÍA ORDENAR TODOS LOS DATOS POR FECHA DE INGRESO, Y OCUPAR LEAD Y LAG PARA REEMPLAZAR Y CHAO. AUTOMATIZAR EL PROCESO
```

<br>

We imputed the missing date of discharge of the cases with overlapped ranges. We used VIM k-Nearest Neighbour Imputation, by finding the weighted median of the 50 nearest neighbors based on Gower distance, but restricting donnors with covariates beyond 90th percent. This approach assumes that missing values can be approximated by the values of the points that are closest to it, based on covariates. Here, we selected as distance covariates the main substance of use, other substances (1), Age of Onset of Drug Use, Marital Status, Age in Groups, Motive of Admission to Treatment,Educational Attainment, Sex, and Frequency of Consumption of the Main Substance (Kowarik & Templ, 2016).

<br>


```{r imputation_of_missing_dates_of_discharge, echo=T, warning=FALSE, cache=T, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev_imp <- CONS_C1_df_dup_FEB_2020_prev2[,c("row","hash_key","fech_ing","ano_bd","fech_egres",'dias_trat','tipo_de_plan_2','edad_al_ing', "id_centro", "sus_principal", "otras_sus1","sus_ini","edad_ini_cons","estado_conyugal_2","estatus_ocupacional","cat_ocupacional","edad_grupos","origen_ingreso", "escolaridad", "sexo_2", "freq_cons_sus_prin")] %>%
  dplyr::mutate(dias_trat_for_imp=ifelse(is.na(fech_egres),NA,dias_trat)) %>%
  as.data.table()
set.seed(4321)
CONS_FEB_2020_impute_kNN<-VIM::kNN(CONS_C1_df_dup_FEB_2020_prev_imp, variable = c("dias_trat_for_imp"), 
                                   dist_var=c("sus_principal","otras_sus1","edad_ini_cons","estado_conyugal_2","edad_grupos","sexo_2","escolaridad","estatus_ocupacional","cat_ocupacional","origen_ingreso","tipo_de_plan_2","edad_al_ing", "ano_bd"),numFun = median, k=50,
                                   donorcond=list(c("<1045","<1045","<27","<1045","<1045","<1045","<1045","<1045","<1045","<1045","<1045","<1045","<56","<1045")))
#CONS_FEB_2020_impute_kNN %>% dplyr::filter(row %in% c(157931, 111197, 109317, 89750, 65674, 25303, 16163, 18784, 15769, 15672, 194, 8239, 6593, 2603)) %>% print()
#donorcond: list of length equal to the number of variables, with a donorcond condition for the donors e.g. ">5"
#se demora 15 minutos en cargar. Desde las 15.20 a las 15.35
```

```{r  retrieval_of_imputed_data,echo=T, cache=T,paged.print=TRUE, warning=F}
CONS_FEB_2020_impute_kNN  %>%
  dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(fech_egres_na_overlap)))))) %>% # select hashs of wrongly assigned ages
  dplyr::arrange(hash_key, desc(fech_ing)) %>% 
  dplyr::mutate(fech_egres_imp=fech_ing+lubridate::days(dias_trat_for_imp)) %>%
  dplyr::select(row, hash_key, ano_bd, fech_ing,dias_trat, dias_trat_for_imp,fech_egres, fech_egres_imp,tipo_de_plan_2, edad_al_ing, id_centro, everything()) %>%
  dplyr::group_by(hash_key) %>%
  dplyr::mutate(fech_ing_siguiente=dplyr::lag(fech_ing))%>%
  dplyr::mutate(diff_between_dates=as.Date(fech_ing_siguiente)-as.Date(fech_egres_imp)) %>%
  dplyr::select(row,hash_key,ano_bd,fech_ing,dias_trat, dias_trat_for_imp,fech_egres, fech_egres_imp,fech_ing_siguiente,diff_between_dates) %>% 
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 4. Imputation of missing values and overlapped in the date of discharge",
                 align =rep('c', 101))  %>%
  kableExtra::add_footnote( c("Note.fech_egres_imp= Imputed Date of Discharge Based on Nearest Neighbour Network", "dias_trat_for_imp	= Imputed Days of Treatment Based on Nearest Neighbour Network", "fech_ing_siguiente= Date of Admission of the Following Treatment", "diff_between_dates= Difference Between Date of Admission of the earlier treatment and imputed date of discharge of the latter treatment (negative represents overlapping)"), notation = "none") %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/4_prueba_imp.RData")
```

<br>

As seen in Table 4, there are some cases in which the imputed date of discharge overlapped with the date of admission of the latter treatment. These cases will be normalized following the rules of the decision tree for overlapping ranges, but added as new columns, in case some researchers do not want to work with around 15 cases imputed.

```{r imputation_of_missing_dates_of_discharge_in_dataset,echo=F, paged.print=TRUE}
fech_egres_na_overlap_row<- CONS_C1_df_dup_FEB_2020_overlaps_COMP %>% dplyr::filter(is.na(fech_egres_1)) %>% distinct(row_1) %>% as.data.frame()

kNN_imp_cases_for_imp  <- CONS_FEB_2020_impute_kNN %>% 
                    dplyr::filter(row %in% as.character(as.vector(unlist(as.data.table(unlist(fech_egres_na_overlap_row)))))) %>% 
                    dplyr::select(row,dias_trat_for_imp) %>%
                    as.data.table()

CONS_C1_df_dup_FEB_2020_prev14 %>% #117,393
  dplyr::left_join(kNN_imp_cases_for_imp, by="row") %>% #dim() #se mantiene el conteo de filas
  dplyr::rename("dias_trat_knn_imp"="dias_trat_for_imp") %>%
  dplyr::mutate(fech_egres_knn_imp=ifelse(!is.na(dias_trat_knn_imp),as.character(fech_ing+lubridate::days(dias_trat_knn_imp)), as.character(fech_egres))) %>%
  dplyr::mutate(fech_egres_knn_imp=lubridate::parse_date_time(as.character(fech_egres_knn_imp),"Ymd")) %>%
  dplyr::mutate(dias_trat_knn_imp=ifelse(!is.na(dias_trat_knn_imp),dias_trat_knn_imp, dias_trat)) %>%
  dplyr::mutate(dias_trat_alta_temprana_knn_imp=ifelse(dias_trat_knn_imp>=90,0,1)) %>%
  dplyr::mutate(dias_trat_alta_temprana_knn_imp=as.factor(dias_trat_alta_temprana_knn_imp)) %>%
  dplyr::mutate(dias_trat_alta_temprana_knn_imp= dplyr::recode(dias_trat_alta_temprana_knn_imp, "1"="Menos de 90 días", "0"="Mayor o igual a 90 días")) %>%
#PARA PROBAR COMO FUNCIONA
#   dplyr::select(row, hash_key, fech_ing, fech_egres, fech_egres_knn_imp, dias_trat, dias_trat_knn_imp, dias_trat_alta_temprana,dias_trat_alta_temprana_knn_imp)%>%
# dplyr::filter(row %in% as.character(as.vector(unlist(as.data.table(unlist(fech_egres_na_overlap_row)))))) %>% 
 #print()
  assign("CONS_C1_df_dup_FEB_2020_prev15",.,envir = .GlobalEnv) #117,393 
```

<!--- eso requiere cambiar los días de tratamiento, el motivodeegreso mod, el de late withdrawal y todo, dias_trat, etc --->
<!--- ¿y qué pasa con los casos que tienen más de un HASH overlapiado??, `r CONS_C1_df_dup_FEB_2020_overlaps_COMP %>%group_by(hash_key_1) %>% dplyr::mutate(mas_de_un_row=n_distinct(row_1)) %>% ungroup() %>% filter(mas_de_un_row>1) %>% nrow()` #137, 2 y #38 +2 --->
<!--- qué pasa con los casos que tenian la fecha perdida de egreso por mucho tiempo y por tanto estoy perdiendo casos intermedios? `r CONS_C1_df_dup_FEB_2020_overlaps_COMP %>% dplyr::filter(is.na(fech_egres_1)) %>% nrow()`.#19. AQUÍ HAY 2 PROBLEMAS.--->

<br>

Of the cases that their dates may be replaced,  HASH Key "5fab3d3029d511f60544d7a58d047e5c" had 2 different dates which can be replaced, because it had 3 treatments: one from 2012-11-25 to 2014-03-31, other from 2012-10-25 to  2012-12-17, and a third from 2012-05-24 to 2012-11-27. We keeped these cases without modiications, for further analysis.

<br>

```{r replace_of_data_related_to_overlapping_in_dataset,echo=T, paged.print=TRUE}
#PARA VER EL PROGRESO
#CONS_C1_df_dup_FEB_2020_prev15 %>%
#  dplyr::filter(!is.na(fech_egres_num_imp_32)|!is.na(fech_egres_num_imp_22)|!is.na(fech_egres_num_imp_3)|!is.na(fech_egres_num_imp_2)|!is.na(motivodeegreso_cor2)|!is.na(fech_egres_num_imp_2)|!is.na(fech_egres_num_imp)) %>% View()

#Me da 1166 casos, siendo que debiesen ser 1025 (de los que tienen menos o igual a 30 días de superposición) y 397 (sin días de superposición)= 1422. Puede que habiendo borrado algunos casos: 11+45+9+19+68+3+80 de los que borré o descarté uno, dan 235, lo que da 1187. Todavía hay 21 casos que no me calzan

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#para ver si hay más de uno. En este caso, sacar al hash 5fab3d3029d511f60544d7a58d047e5c
##cols<-c("fech_egres_num_imp_32","fech_egres_num_imp_3","fech_egres_num_imp_22","fech_egres_num_imp_2","fech_egres_num_imp") #hay uno
##cols2<-c("motivodeegreso_cor3","motivodeegreso_cor2") #o hay duplicados
##library(dplyr)    
##CONS_C1_df_dup_FEB_2020_prev15 %>%
##  mutate(sum_yes = rowSums(.[cols2] != "", na.rm=T)) %>%
##  dplyr::filter(sum_yes==1)
##  group_by(sum_yes) %>%
##  summarise(n=n())
#
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

CONS_C1_df_dup_FEB_2020_prev15 %>%
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_num_imp_32)&hash_key!="5fab3d3029d511f60544d7a58d047e5c",as.character(as.Date(fech_egres_num_imp_32)),
                                          as.character(fech_egres_knn_imp))) %>% #porque es del knn imputation q lo queremos sacar
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_num_imp_22)&hash_key!="5fab3d3029d511f60544d7a58d047e5c",as.character(as.Date(fech_egres_num_imp_22)),
                                          as.character(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_num_imp_3)&hash_key!="5fab3d3029d511f60544d7a58d047e5c",as.character(as.Date(fech_egres_num_imp_3)),
                                          as.character(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_num_imp_2)&hash_key!="5fab3d3029d511f60544d7a58d047e5c",as.character(as.Date(fech_egres_num_imp_2)),
                                          as.character(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_num_imp)&hash_key!="5fab3d3029d511f60544d7a58d047e5c",as.character(as.Date(fech_egres_num_imp)),
                                          as.character(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_imp=lubridate::parse_date_time(as.character(fech_egres_imp),"Ymd")) %>%    
  #primero la correcion3
  dplyr::mutate(motivodeegreso_imp=ifelse(!is.na(motivodeegreso_cor3),as.character(motivodeegreso_cor3),
                                          as.character(motivodeegreso))) %>%
  dplyr::mutate(motivodeegreso_mod_imp=ifelse(!is.na(motivodeegreso_cor3),as.character(motivodeegreso_cor3),
                                          as.character(motivodeegreso_mod))) %>%
  dplyr::mutate(motivodeegreso_imp=as.factor(motivodeegreso_imp)) %>%
  dplyr::mutate(motivodeegreso_mod_imp=as.factor(motivodeegreso_mod_imp)) %>%
  #ahora la otra var
  dplyr::mutate(motivodeegreso_imp=ifelse(!is.na(motivodeegreso_cor2),as.character(motivodeegreso_cor2),
                                          as.character(motivodeegreso_imp))) %>%
  dplyr::mutate(motivodeegreso_mod_imp=ifelse(!is.na(motivodeegreso_cor2),as.character(motivodeegreso_cor2),
                                          as.character(motivodeegreso_mod_imp))) %>%
  dplyr::mutate(motivodeegreso_imp=as.factor(motivodeegreso_imp)) %>%
  dplyr::mutate(motivodeegreso_mod_imp=as.factor(motivodeegreso_mod_imp)) %>%
  dplyr::mutate(dias_trat_imp=as.numeric(as.Date(fech_egres_imp)-as.Date(fech_ing),units="days")) %>%
  ## Calcular de nuevo las variables que dependendn de dias trat para todos los casos imputados
  dplyr::mutate(dias_trat_alta_temprana_imp=ifelse(dias_trat_imp>=90,0,1)) %>%
  dplyr::mutate(dias_trat_alta_temprana_imp=as.factor(dias_trat_alta_temprana_imp)) %>%
  dplyr::mutate(dias_trat_alta_temprana_imp= dplyr::recode(dias_trat_alta_temprana_imp, "1"="Menos de 90 días", "0"="Mayor o igual a 90 días")) %>%
  dplyr::mutate(motivodeegreso_mod_imp= ifelse(dias_trat_alta_temprana_imp=="Menos de 90 días" & motivodeegreso_imp=="Abandono", "Abandono Temprano",as.character(motivodeegreso_mod_imp))) %>% 
  dplyr::mutate(motivodeegreso_mod_imp= ifelse(dias_trat_alta_temprana_imp=="Mayor o igual a 90 días" & motivodeegreso_imp=="Abandono", "Abandono Tardio",as.character(motivodeegreso_mod_imp))) %>% 
  dplyr::select(-motivodeegreso_cor3,-motivodeegreso_cor2,-fech_egres_num_imp_32,-fech_egres_num_imp_22,-fech_egres_num_imp_3,-fech_egres_num_imp_2,-fech_egres_num_imp)%>%
##PARA PESQUISAR RESULTADOS
#  dplyr::filter(!is.na(fech_egres_num_imp_32)|!is.na(fech_egres_num_imp_22)|!is.na(fech_egres_num_imp_3)|!is.na(fech_egres_num_imp_2)|!is.na(motivodeegreso_cor2)#|!is.na(fech_egres_num_imp_2)|!is.na(fech_egres_num_imp)) %>% 
#       dplyr::select(row, hash_key, fech_ing, fech_egres, fech_egres_knn_imp, fech_egres_imp,dias_trat, dias_trat_knn_imp, dias_trat_alta_temprana,dias_trat_alta_temprana_knn_imp, dias_trat_imp,motivodeegreso_imp, motivodeegreso_mod_imp) %>%  
#    View()
##PARA VER SI HAY CASOS QUE TIENEN MÁS DE UNA IMPUTACIÓN. UNA KNN Y OTRA LÓGICA  
#  dplyr::mutate(eso=ifelse(fech_egres_knn_imp==fech_egres,1,0),
#                eso2=ifelse(fech_egres_imp==fech_egres_knn_imp,1,0),
#                eso3=ifelse(eso==0&eso2==0,1,0)) %>%
#  dplyr::filter(eso3==1) %>%print()
###NO HAY NADIE QUE TENGA MÁS DE UNA IMPUTACIÓN, ES DECIR, MÁS DE UN KNN Y LA OTRA LÓGICA HASTA AHORA
assign("CONS_C1_df_dup_FEB_2020_prev16",.,envir = .GlobalEnv) #117,393 
```

<br>

Once this process of imputation and replacing is done, we ended with `r formatC(nrow(CONS_C1_df_dup_FEB_2020_prev16), format="f", big.mark=",", digits=0)` cases, but we still need to check entries with more than one overlap, those without center ID and center name, and whether imputed dates of discharge ended overlapping with another entry.

<br>

```{r  overlap2,echo=T, paged.print=TRUE}
CONS_C1_df_dup_intervals_FEB_2020_2<- CONS_C1_df_dup_FEB_2020_prev16 %>%
  #as.numeric(as.Date("2019-11-13")) #18213
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_num2=ifelse(is.na(fech_egres_imp),18213,fech_egres_num2)) %>% #equivalente a 2019-11-13
  dplyr::rename("hash_key_2"="hash_key", "row2"="row") %>%
  dplyr::select(row2,hash_key_2, ano_bd,fech_ing, fech_ing_num2,fech_egres_imp,fech_egres_num2,edad, dias_trat_imp,id_centro, motivodeegreso_imp, senda) %>% 
  #dplyr::filter(motivodeegreso!="Derivación") %>%
  data.table::as.data.table()
require(sqldf)
require(gridExtra)

  overlap_dates_C1_FEB_2020_2 <- janitor::clean_names(sqldf("SELECT *
                 FROM CONS_C1_df_dup_intervals_FEB_2020_2 AS x  
                 INNER JOIN CONS_C1_df_dup_intervals_FEB_2020_2 AS y 
                 ON x.hash_key_2 == y.hash_key_2 AND 
                 x.fech_ing_num2 < y.fech_egres_num2 AND x.fech_egres_num2 > y.fech_ing_num2 AND x.row2 != y.row2"))  
  
  #busca mismo hash, distinto row,pero fecha de ingreso menor o igual a la fecha de egreso del otro, y fecha de egreso mayor o igual a la fecha de ingreso del otro. lo del row ES PARA DESCARTAR CASOS QUE SE SUPERPONEN CONSIGMO MISMO.
overlap_dates_C1_FEB_2020_2 %>%
  as.data.table() %>%
  dplyr::rename("row_1"="row2", "row_2"="row2_2", "fech_ing_num_1"="fech_ing_num2", "fech_ing_num_2"="fech_ing_num2_2") %>%
  dplyr::mutate(caso_2_mas_reciente=ifelse(as.numeric(fech_ing_num_2)>as.numeric(fech_ing_num_1),1,0)) %>% #ver si el dato de la izq es más aniguo
  dplyr::arrange(desc(caso_2_mas_reciente)) %>% #NO AFECTA PORQUE SIEMPRE COMPARATIVAMENTE UNO SERÁ MÁS RECIENTE QUE EL OTRO. además no lo hace con variable número sino con fecha.
  #2388
  dplyr::select(row_1, row_2) %>%
  dplyr::mutate(prod_row=as.numeric(row_1)*as.numeric(row_2), sum_row=as.numeric(row_1)+as.numeric(row_2), filter_row=paste0(prod_row,"_",sum_row)) %>%
  dplyr::filter(!duplicated(filter_row)) %>% #dejé sólo los casos que son más recientes. Se supone q no perdí casos, sino que saqué los duplicados
  dplyr::select(row_1, row_2) %>%
  panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
    as.data.table() %>%
  assign("CONS_C1_df_dup_FEB_2020_overlaps_2",.,envir = .GlobalEnv)

#EL DE LA IZQUIERDA TIENDE A SER MÁS ANTIGUO QUE EL DE LA DERECHA, CONSTE
CONS_C1_df_dup_FEB_2020_overlaps_2 %>%
  dplyr::left_join(dplyr::select(CONS_C1_df_dup_FEB_2020_prev16,row,ano_bd, hash_key,id_mod, fech_egres, fech_ing, fech_egres_imp,  id_centro,dias_trat,dias_trat_imp,id_centro,motivodeegreso,motivodeegreso_imp,senda), by="row") %>%   
  dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num=as.numeric(as.Date(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_num=ifelse(is.na(fech_egres_imp),18213,fech_egres_num)) %>% #equivalente a 2019-11-13
reshape(idvar="id", timevar="wave", direction="wide",sep="_") %>%
  dplyr::mutate(mismo_id_centro=ifelse(id_centro_1==id_centro_2,1,0)) %>%
  dplyr::mutate(bd_2_mas_reciente=ifelse(ano_bd_2>ano_bd_1,1,0)) %>% #es el dato de la derecha de una base de datos mas reciente.
  dplyr::mutate(senda= ifelse(senda_1=="Si" & senda_2=="Si","Si Ambos",
                        ifelse(senda_1=="No" & senda_2=="No","No Ambos",
                              ifelse(senda_1=="No" & senda_2=="Si","Si 2",
                                     ifelse(senda_1=="Si" & senda_2=="No","No 2",NA))))) %>%
  dplyr::mutate(Derivacion= ifelse(motivodeegreso_imp_1=="Derivación",1,0)) %>%
  dplyr::mutate(days_overlapped=fech_egres_num_1-fech_ing_num_2) %>% # para que hayan dias positivos. Se supone que la fecha de egreso es más reciente que la fecha de ingreso del evento que superpone.
  dplyr::mutate(mas_dias_trat=ifelse(dias_trat_imp_2>dias_trat_imp_1,1,0)) %>% #más días tratado en 2
  dplyr::mutate(trat_1_absorve_a_2=ifelse(fech_egres_num_1>fech_egres_num_2,1,0)) %>%
  dplyr::select(-hash_key_2) %>%
    assign("CONS_C1_df_dup_FEB_2020_overlaps_COMP_2",.,envir = .GlobalEnv)
####
CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 5. Cases with overlapped treatment ranges, once filtered duplicated rows and other overlapped cases",
                 align =rep('c', 101))  %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::add_footnote( c("Note.Each row represents an overlap. Variables ending with '_1' correspond to the first case, and variables ending with '_2' correspond to the second case;", "mismo_id_centro= If both cases share the same Center ID", "bd_2_mas_reciente= Year of the yearly dataset is more recent in the second case;", "senda= If both cases are financed by SENDA;", "Derivación= If the cause of discharge is the referral from another center (1= Referral);","days_overlapped= Difference between the date of admission of the earlier treatment, and the date of discharge of the latter treatment (w imputed values)","mas_dias_trat= Earlier treatment has more days of treatment"), notation = "none") %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#FOR COMPARISON
CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>%
panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>% 
  dplyr::rename("overlap_id"="id") %>%
 guardar_tablas("_overlaps_feb_2020_2")

#casos con centro ID NAs
#CONS_C1_df[CONS_C1_df$HASH_KEY=="380d9b27915ca8873d06f71d4d74030e", "ID.centro"]
#CONS_C1_df[CONS_C1_df$HASH_KEY=="1d53b9a82ab4fbc0e6cfa109d664eb51", "ID.centro"]
```

```{r overlap_cases_final, echo=FALSE, fig.align='center', fig.pos='H', fig.cap= "Figure 3. Trajectories of every HASH with overlaps from dates of admission to discharge", message=FALSE}
c28 <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "gray16", "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2","orchid1", 
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70","deeppink1", "khaki2","steelblue4",
  "maroon",  "blue1", "brown",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4",  "gray40", "blue","black")

  CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>%
  panelr::long_panel(prefix = "_", label_location = "end", begin = 1, end = 2) %>%
  dplyr::mutate(id_wave=paste0(id,"-",wave)) %>%
  ggplot() + 
  geom_segment(aes(x = as.POSIXct(as.Date(fech_ing)), xend = as.POSIXct(as.Date(fech_egres_imp)),
                   y = id, yend = id, colour=as.factor(row),size=5)) +
  scale_x_datetime(breaks=scales::date_breaks("1 year"),labels = scales::date_format("%m/%y"),
                   limits = as.POSIXct(c('2009-01-01 09:00:00','2020-01-01 09:00:00')))+
  scale_color_manual(values=c28) +
  theme(axis.title.y=element_blank(),
        axis.title.x=element_blank(),
        axis.ticks.y=element_blank(),
        panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),plot.background=element_blank(),
        legend.position="none") +
    labs(x = "Dates of admission and discharge", y = "", subtitle="Colored lines represent different rows in the dataset, but with the same HASH")
```

<br>

Now there are `r CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>% dplyr::filter(is.na(fech_egres_imp_1)) %>% nrow()` cases that had missing values in the date of discharge of the latter treatment, but `r CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>%group_by(hash_key_1) %>% dplyr::mutate(mas_de_un_row=n_distinct(row_1)) %>% ungroup() %>% filter(mas_de_un_row>1) %>% nrow()` cases that overlaps with more than one case. As we may see in Table 5, many of these cases comes from imputed cases that had had missing values in the first date of discharge, but the imputed discharge date was also overlapped with the date of admission of the earlier treatment. Also there is the case of  HASHs "380d9b27915ca8873d06f71d4d74030e" (which had an overlapping date with a treatment of only one day between 04-11-2014 and 05-11-2014) and "1d53b9a82ab4fbc0e6cfa109d664eb51" which did not have the date of discharge but the center ID neither. The other group of cases correspond to HASH "5fab3d3029d511f60544d7a58d047e5c", which appeared with more than two treatments overlapping between each other. We applied again the rules stated in Figure 2.

<br>

```{r apply_rules_to_dataset_wo_overlaps,echo=F, paged.print=TRUE}
var_int<-c('numero_de_hijos_ingreso_tratamiento_residencial',
'numero_de_tratamientos_anteriores',
'x_se_trata_de_una_mujer_embarazada',
'frecuencia_de_consumo_sustancia_principal',
'via_administracion_sustancia_principal',
'diagnostico_trs_consumo_sustancia',
'diagnostico_trs_psiquiatrico_dsm_iv',
'diagnostico_trs_psiquiatrico_sub_dsm_iv',
'x2_diagnostico_trs_psiquiatrico_dsm_iv',
'x2_diagnostico_trs_psiquiatrico_sub_dsm_iv',
'x3_diagnostico_trs_psiquiatrico_dsm_iv',
'x3_diagnostico_trs_psiquiatrico_sub_dsm_iv',
'diagnostico_trs_psiquiatrico_cie_10',
'diagnostico_trs_psiquiatrico_sub_cie_10',
'x2_diagnostico_trs_psiquiatrico_cie_10',
'x2_diagnostico_trs_psiquiatrico_sub_cie_10',
'x3_diagnostico_trs_psiquiatrico_cie_10',
'x3_diagnostico_trs_psiquiatrico_sub_cie_10',
'otros_problemas_de_atencion_de_salud_mental',
'diagnostico_global_de_necesidades_de_integracion_social',
'diagnostico_de_necesidades_de_integrac_io_n_social_en_capital_humano',
'diagnostico_de_necesidades_de_integrac_io_n_social_en_capital_fisico',
'diagnostico_de_necesidades_de_integrac_io_n_social_en_capital_social',
'usuario_de_tribunales_tratamiento_drogas',
'diagnostico_trastorno_psiquiatrico_cie_10_al_egreso',
'diagnostico_global_de_necesidades_de_integracion_social_1',
'diagnostico_de_necesidades_de_integrac_io_n_social_en_capital_humano_1',
'diagnostico_de_necesidades_de_integrac_io_n_social_en_capital_fisico_1',
'diagnostico_de_necesidades_de_integrac_io_n_social_en_capital_social_1',
'motivo_de_egreso_alta_administrativa')

var_out<-c('num_hijos_ing_trat_res',
'num_trat_ant',
'x_se_trata_mujer_emb',
'freq_cons_sus_prin_original',
'via_adm_sus_prin_original',
'dg_trs_cons_sus_or',
'dg_trs_psiq_dsm_iv_or',
'dg_trs_psiq_sub_dsm_iv_or',
'x2_dg_trs_psiq_dsm_iv_or',
'x2_dg_trs_psiq_sub_dsm_iv_or',
'x3_dg_trs_psiq_dsm_iv_or',
'x3_dg_trs_psiq_sub_dsm_iv_or',
'dg_trs_psiq_cie_10_or',
'dg_trs_psiq_sub_cie_10_or',
'x2_dg_trs_psiq_cie_10_or',
'x2_dg_trs_psiq_sub_cie_10_or',
'x3_dg_trs_psiq_cie_10_or',
'x3_dg_trs_psiq_sub_cie_10_or',
'otros_probl_at_sm_or',
'dg_global_nec_int_soc_or',
'dg_nec_int_soc_cap_hum_or',
'dg_nec_int_soc_cap_fis_or',
'dg_nec_int_soc_cap_soc_or',
'usuario_tribunal_trat_droga',
'dg_trs_psiq_cie_10_egres_or',
'dg_global_nec_int_soc_or_1',
'dg_nec_int_soc_cap_hum_or_1',
'dg_nec_int_soc_cap_fis_or_1',
'dg_nec_int_soc_cap_soc_or_1',
'mot_egres_alt_adm_or')

#https://docs.google.com/spreadsheets/d/1RhwegmN9RrDodHtxk4PqbYZs6eZ4enB5q1LLzbwmo6M/edit?usp=sharing
##eliminar 156785, 64530 49659 6349 (826) last one due to inconsistencies (yearly dataset 2010, treatment raging from 2010 to 2016)
##CONS_C1_df[which(CONS_C1_df$HASH_KEY=="9a8fef6d37e8010c477c25db3e5e8455"),c("ano_bd",HASH_KEY","fech_ing","fech_egres")]
CONS_C1_df_dup_FEB_2020_prev16 %>% #117,393
  dplyr::filter(!row %in% as.character(as.vector(unlist(as.data.table(unlist(c(156785, 64530,49659, 6349,826,31405, 48099, 26804, 31405))))))) %>% 
  assign("CONS_C1_df_dup_FEB_2020_prev17",.,envir = .GlobalEnv) #117,388
#ESTOS SON LOS HASH CON LOS CASOS DESCARTADOS
#dplyr::filter(!hash_key %in% c("a92ab8f10fa05d0d9dcb5855c0ec0092", "380d9b27915ca8873d06f71d4d74030e", "137e8525aa3f79235fa8ad90913fdcbe","9a8fef6d37e8010c477c25db3e5e8455","584feda92f394aa23d89e5162b8e3d05","5fab3d3029d511f60544d7a58d047e5c")) %>%
  #print()
  CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>%
  dplyr::filter(days_overlapped<=30) %>%
  dplyr::mutate(fech_egres_imp_less_30_days=fech_ing_2) %>%
  dplyr::select(row_1, fech_egres_imp_less_30_days) %>%
  as.data.frame(.) %>% 
  dplyr::rename("row"="row_1") %>%
  dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev17,by="row") %>%
  dplyr::select(everything(),fech_egres_imp_less_30_days) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev18",.,envir = .GlobalEnv) 
#para poner la fecha de ingreso por fecha de egreso

CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>%
  dplyr::filter(days_overlapped>30) %>%
  dplyr::filter(!hash_key_1 %in% c("5fab3d3029d511f60544d7a58d047e5c","a92ab8f10fa05d0d9dcb5855c0ec0092", "380d9b27915ca8873d06f71d4d74030e", "137e8525aa3f79235fa8ad90913fdcbe","9a8fef6d37e8010c477c25db3e5e8455","584feda92f394aa23d89e5162b8e3d05")) %>%
  dplyr::filter(is.na(motivodeegreso_1)) %>% 
  dplyr::mutate(motivodeegreso_imp_more_30_days_wo_cause_discharge="Derivación") %>%
  dplyr::mutate(fech_egres_imp_more_30_days_wo_cause_discharge=fech_ing_2) %>%
  dplyr::select(row_1, motivodeegreso_imp_more_30_days_wo_cause_discharge,fech_egres_imp_more_30_days_wo_cause_discharge) %>%
  as.data.frame(.) %>% 
  dplyr::rename("row"="row_1") %>%
  dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev18,by="row") %>%
  dplyr::select(everything(),motivodeegreso_imp_more_30_days_wo_cause_discharge,fech_egres_imp_more_30_days_wo_cause_discharge) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev19",.,envir = .GlobalEnv) 

CONS_C1_df_dup_FEB_2020_overlaps_COMP_2 %>%
  dplyr::filter(days_overlapped>30) %>%
  dplyr::filter(!hash_key_1 %in% c("5fab3d3029d511f60544d7a58d047e5c","a92ab8f10fa05d0d9dcb5855c0ec0092", "380d9b27915ca8873d06f71d4d74030e", "137e8525aa3f79235fa8ad90913fdcbe","9a8fef6d37e8010c477c25db3e5e8455","584feda92f394aa23d89e5162b8e3d05")) %>%
  dplyr::filter(motivodeegreso_1=="Derivación") %>% 
  dplyr::mutate(fech_egres_imp_more_30_days_w_cause_discharge=fech_ing_2) %>%
  dplyr::select(row_1, fech_egres_imp_more_30_days_w_cause_discharge) %>%
  as.data.frame(.) %>% 
  dplyr::rename("row"="row_1") %>%
  dplyr::right_join(CONS_C1_df_dup_FEB_2020_prev19,by="row") %>%
  dplyr::select(everything(),fech_egres_imp_more_30_days_w_cause_discharge) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev20",.,envir = .GlobalEnv) 

CONS_C1_df_dup_FEB_2020_prev20 %>%
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_imp_less_30_days),as.character(as.Date(fech_egres_imp_less_30_days)),
                                          as.character(fech_egres_imp))) %>% #porque es del knn imputation q lo queremos sacar
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_imp_more_30_days_wo_cause_discharge),as.character(as.Date(fech_egres_imp_more_30_days_wo_cause_discharge)),
                                          as.character(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_imp=ifelse(!is.na(fech_egres_imp_more_30_days_w_cause_discharge),as.character(as.Date(fech_egres_imp_more_30_days_w_cause_discharge)),
                                          as.character(fech_egres_imp))) %>%
  dplyr::mutate(fech_egres_imp=lubridate::parse_date_time(as.character(fech_egres_imp),"Ymd")) %>%    
#primero la correcion3
  dplyr::mutate(motivodeegreso_imp=ifelse(!is.na(motivodeegreso_imp_more_30_days_wo_cause_discharge),as.character(motivodeegreso_imp_more_30_days_wo_cause_discharge),
                                          as.character(motivodeegreso))) %>%
  dplyr::mutate(motivodeegreso_mod_imp=ifelse(!is.na(motivodeegreso_imp_more_30_days_wo_cause_discharge),as.character(motivodeegreso_imp_more_30_days_wo_cause_discharge),
                                          as.character(motivodeegreso_mod))) %>%
  dplyr::mutate(motivodeegreso_imp=as.factor(motivodeegreso_imp)) %>%
  dplyr::mutate(motivodeegreso_mod_imp=as.factor(motivodeegreso_mod_imp)) %>%
  dplyr::mutate(dias_trat_imp=as.numeric(as.Date(fech_egres_imp)-as.Date(fech_ing),units="days")) %>%
  ## Calcular de nuevo las variables que dependendn de dias trat para todos los casos imputados
  dplyr::mutate(dias_trat_alta_temprana_imp=ifelse(dias_trat_imp>=90,0,1)) %>%
  dplyr::mutate(dias_trat_alta_temprana_imp=as.factor(dias_trat_alta_temprana_imp)) %>%
  dplyr::mutate(dias_trat_alta_temprana_imp= dplyr::recode(dias_trat_alta_temprana_imp, "1"="Menos de 90 días", "0"="Mayor o igual a 90 días")) %>%
  dplyr::mutate(motivodeegreso_mod_imp= ifelse(dias_trat_alta_temprana_imp=="Menos de 90 días" & motivodeegreso_imp=="Abandono", "Abandono Temprano",as.character(motivodeegreso_mod_imp))) %>% 
  dplyr::mutate(motivodeegreso_mod_imp= ifelse(dias_trat_alta_temprana_imp=="Mayor o igual a 90 días" & motivodeegreso_imp=="Abandono", "Abandono Tardio",as.character(motivodeegreso_mod_imp))) %>% 
  dplyr::select(-fech_egres_imp_less_30_days,-fech_egres_imp_more_30_days_wo_cause_discharge,-motivodeegreso_imp_more_30_days_wo_cause_discharge,-fech_egres_imp_more_30_days_w_cause_discharge)%>%
  dplyr::rename_at(vars(var_int), function(x) var_out) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev21",.,envir = .GlobalEnv) %>%
  dplyr::arrange(hash_key, desc(fech_ing)) %>% 
  rio::export(file = "G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/CONS_C1_df_dup_FEB_2020_prev.dta")
save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/4_post_dedup.RData")
```

<br>

## 1. Probabilistic Matches

&nbsp;

The code used in stata is shown here: We selected matches in the rows with the same hash, center id, date of admission, age, educational attainment, sex and id, within ages and with a match score greater or equal to 70.

&nbsp;
<br>

```{stata, collectcode=TRUE}
use "G:\Mi unidad\Alvacast\SISTRAT 2019 (github)\CONS_C1_df_dup_FEB_2020_prev.dta", clear 

cap gen date_in = mdy(real_fech_ing_mes, real_fech_ing_dia, real_fech_ing_ano)
cap gen date_in = mdy(fech_ing_mes, fech_ing_dia, fech_ing_ano)

generate id_match = _n
cap drop _id
dtalink hash_key 25 -25 id_centro 10 0 date_in 30 -30 5 edad 7 -7 escolaridad 8 -8 sexo 10 -10 id 10 -10, block(edad) cutoff(70)
drop if missing(_score)
cap qui save "G:\Mi unidad\Alvacast\SISTRAT 2019 (github)\Stata Duplicates Match\_CONS_C1_df_match70_2020_02_29.dta"
cap qui save "G:\Mi unidad\Alvacast\SISTRAT 2019 (github)\Stata Duplicates Match\_CONS_C1_df_match70_2020_02_29.dta", replace
```


```{r  matches_stata, include=T, echo=T, eval=F, cache=T}
matches_from_stata_c1_feb <- haven::read_dta("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/Stata Duplicates Match/_CONS_C1_df_match70_2020_02_29.dta")
matches_from_stata_c1_feb <-matches_from_stata_c1_feb %>% dplyr::rename(score = 3, matchID = 1, row_id=2)
matches_from_stata_c1_feb  %>%
dplyr::arrange(score,matchID,hash_key) %>%
dplyr::group_by(matchID) %>%
dplyr::mutate(following_date_adm=dplyr::lead(fech_ing)) %>%
dplyr::select(score, matchID, hash_key, ano_bd, id_centro, date_in, fech_ing, fech_egres,following_date_adm, edad, dias_trat) %>%
as.data.frame() %>%
knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
caption="Table 6. View of Matches from Stata, once Deduplication and De-overlapping", align =rep('c', 100)) %>%
kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>

As seen in Table 6, every case that stata considered a match was in fact another treatment that lasted around 1 to 5 days, or ended inmediatelly before the next treatment. Of the abovementioned, none of them was considered as an overlap between treatments.

<br>

## 2. Data Editing / Deductive Imputation

<br>

TThere may be differences between route of administration of principal substance and the principal substance. For example, there were `r CONS_C1_df_dup_FEB_2020_prev21 %>% dplyr::filter(sus_principal=="Cocaína", via_adm_sus_prin!="Intranasal  ( aspiración de polvo por la nariz)") %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)` cases that do not snort Cocaine, ¿so what is the correct route of administration of each main substance?. This was corrected in a variable called `via_adm_sus_prin_act`.

<br>

```{r  tab_ruta_adm_sus_prin, include=T, echo=T, eval=F, cache=T}
CONS_C1_df_dup_FEB_2020_prev21 %>%
janitor::tabyl(sus_principal, via_adm_sus_prin) %>%
  as.data.frame() %>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 7. Main Substance of Use dependending on Route of consumption", align =rep('c', 100)) %>%
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
    kableExtra::scroll_box(width = "100%", height = "350px")
```
<br>

```{r  recode route of adm, include=T, echo=T, eval=T, cache=T}
CONS_C1_df_dup_FEB_2020_prev21 %>% 
  dplyr::mutate(via_adm_sus_prin_act=ifelse(sus_principal=="Alcohol","Oral (bebida o comida)",as.character(via_adm_sus_prin))) %>%
  dplyr::mutate(via_adm_sus_prin_act=ifelse(sus_principal=="Cocaína","Intranasal ( aspiración de polvo por la nariz)",via_adm_sus_prin_act)) %>%
  dplyr::mutate(via_adm_sus_prin_act=ifelse(sus_principal=="Marihuana","Fumada o Pulmonar (aspiración de gases o vapores)",via_adm_sus_prin_act)) %>%
  dplyr::mutate(via_adm_sus_prin_act=as.factor(via_adm_sus_prin_act)) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev22",.,envir = .GlobalEnv)
```

<br>

There are some cases that does not have a primary diagnostic, but have a secondary or tertiary (n= `r CONS_C1_df_dup_FEB_2020_prev22 %>% dplyr::filter(is.na(dg_trs_psiq_dsm_iv_or) & !is.na(x2_dg_trs_psiq_dsm_iv_or)) %>% dplyr::select(dg_trs_psiq_dsm_iv_or,x2_dg_trs_psiq_dsm_iv_or,x3_dg_trs_psiq_dsm_iv_or) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`).

<br>

```{r  dg_replace_dsm, include=T, echo=T, eval=T, cache=T}
CONS_C1_df_dup_FEB_2020_prev22 %>% 
  dplyr::mutate(dg_trs_psiq_dsm_iv_or=ifelse(is.na(dg_trs_psiq_dsm_iv_or),as.character(x2_dg_trs_psiq_dsm_iv_or),as.character(dg_trs_psiq_dsm_iv_or))) %>%
  dplyr::mutate(dg_trs_psiq_sub_dsm_iv_or=ifelse(is.na(dg_trs_psiq_sub_dsm_iv_or),as.character(x2_dg_trs_psiq_sub_dsm_iv_or),as.character(dg_trs_psiq_sub_dsm_iv_or))) %>%
  dplyr::mutate(x2_dg_trs_psiq_dsm_iv_or=ifelse(is.na(dg_trs_psiq_dsm_iv_or),as.character(x3_dg_trs_psiq_dsm_iv_or),as.character(x2_dg_trs_psiq_dsm_iv_or))) %>%
  dplyr::mutate(x2_dg_trs_psiq_sub_dsm_iv_or=ifelse(is.na(dg_trs_psiq_sub_dsm_iv_or),as.character(x3_dg_trs_psiq_sub_dsm_iv_or),as.character(x2_dg_trs_psiq_sub_dsm_iv_or))) %>%
  dplyr::mutate(x3_dg_trs_psiq_dsm_iv_or=ifelse(is.na(dg_trs_psiq_dsm_iv_or),NA,as.character(x3_dg_trs_psiq_dsm_iv_or))) %>%
  dplyr::mutate(x3_dg_trs_psiq_sub_dsm_iv_or=ifelse(is.na(dg_trs_psiq_sub_dsm_iv_or),NA,as.character(x3_dg_trs_psiq_sub_dsm_iv_or))) %>%  
  dplyr::mutate(dg_trs_psiq_dsm_iv_or=as.factor(dg_trs_psiq_dsm_iv_or)) %>%
  dplyr::mutate(dg_trs_psiq_sub_dsm_iv_or=as.factor(dg_trs_psiq_sub_dsm_iv_or)) %>%
  dplyr::mutate(x2_dg_trs_psiq_dsm_iv_or=as.factor(x2_dg_trs_psiq_dsm_iv_or)) %>%
  dplyr::mutate(x2_dg_trs_psiq_sub_dsm_iv_or=as.factor(x2_dg_trs_psiq_sub_dsm_iv_or)) %>%
  dplyr::mutate(x3_dg_trs_psiq_dsm_iv_or=as.factor(x3_dg_trs_psiq_dsm_iv_or)) %>%
  dplyr::mutate(x3_dg_trs_psiq_sub_dsm_iv_or=as.factor(x3_dg_trs_psiq_sub_dsm_iv_or)) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev23",.,envir = .GlobalEnv)
```
<br>

There are some cases that does not have a primary diagnostic cor DSM-IV, but have a secondary or tertiary (n= `r CONS_C1_df_dup_FEB_2020_prev22 %>% dplyr::filter(is.na(dg_trs_psiq_dsm_iv_or) & !is.na(x2_dg_trs_psiq_dsm_iv_or)) %>% dplyr::select(dg_trs_psiq_dsm_iv_or,x2_dg_trs_psiq_dsm_iv_or,x3_dg_trs_psiq_dsm_iv_or) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`).

There are some cases that does not have a primary diagnostic for CIE-10, but have a secondary or tertiary (n= `r CONS_C1_df_dup_FEB_2020_prev22 %>% dplyr::filter(is.na(dg_trs_psiq_cie_10_or) & !is.na(x2_dg_trs_psiq_cie_10_or)) %>% dplyr::select(dg_trs_psiq_cie_10_or,x2_dg_trs_psiq_cie_10_or,x3_dg_trs_psiq_cie_10_or) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`).

<br>

Also, there are some cases that do not have another substances (1), but do have another substances (2) (n= `r CONS_C1_df_dup_FEB_2020_prev21 %>% dplyr::filter(is.na(otras_sus1) & !is.na(otras_sus2)) %>% dplyr::select(otras_sus1,otras_sus2,otras_sus3) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`).

<br>

```{r  dg_replace_substances, include=T, echo=T, eval=T, cache=T}
CONS_C1_df_dup_FEB_2020_prev23 %>%
  dplyr::mutate(otras_sus1=ifelse(is.na(otras_sus1),as.character(otras_sus2),as.character(otras_sus1))) %>%
  dplyr::mutate(otras_sus2=ifelse(is.na(otras_sus1),as.character(otras_sus3),as.character(otras_sus2))) %>%
  dplyr::mutate(otras_sus3=ifelse(is.na(otras_sus1),NA,as.character(otras_sus2))) %>%
  dplyr::mutate(otras_sus1=as.factor(otras_sus1)) %>%
  dplyr::mutate(otras_sus2=as.factor(otras_sus2)) %>%
  dplyr::mutate(otras_sus3=as.factor(otras_sus3)) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev24",.,envir = .GlobalEnv)
```

<br>

```{r  dg_recode_serv_salud, include=T, echo=T, eval=T, cache=T}
CONS_C1_df_dup_FEB_2020_prev24 %>%
  dplyr::mutate(servicio_de_salud=stringr::str_trim(as.character(servicio_de_salud))) %>%
  dplyr::mutate(servicio_de_salud=as.factor(servicio_de_salud)) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev25",.,envir = .GlobalEnv)
```

<br>

## 3. Different Information Within User, Concerning Personal Information

We may see that many users have more than one disctinct personal information. In fact, these inconsistencies within users (incluiding those related to the date of birth) may impact in their SENDA's ID, making it difficult to detect changes along users in the datasets. Fortunately, we have the encripted code of the national identity number, which can replace SENDAs ID.

```{r image-decision_tree_distinct_values_user_invariant, echo=FALSE, fig.align='center', fig.pos='H', fig.cap= "Figure 4. Decision Tree for the Users with more than one value in a User-Invariant Variable", message=FALSE}
knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/same_hash_distinct_values_user_invariant.svg")
```

<!--- Programa Específico Mujeres	MASA1**031978, ver si es hombre o mujer de verdad --->

- Sex (sexo_2) (`r CONS_C1_df_dup_FEB_2020_prev23 %>% dplyr::group_by(hash_key) %>% dplyr::mutate(sexo_por_hash=dplyr::n_distinct(sexo_2)) %>% ungroup() %>% dplyr::filter(sexo_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`). In cases where there are only 2 observations with distinct sexes but in the same yearly dataset, we replaced the sex to "women" if the user ever has been into a type of program specific for women, or if has ever been pregnant.
<!--- considerar la identidad de género. Esto puede haber afectado la imputación de casos para tipo_de_plan y tipo_de_programa  --->

```{r pers_info_sex, eval=T,echo=T, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev23_sex <- CONS_C1_df_dup_FEB_2020_prev23 %>% group_by(hash_key) %>% dplyr::mutate(sexo_por_hash=n_distinct(sexo_2)) %>% ungroup() %>% dplyr::filter(sexo_por_hash>1) %>% dplyr::distinct(hash_key)
CONS_C1_df_dup_FEB_2020_prev23 %>% 
 dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev23_sex)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(hash_key) %>% #ordeno por ids 
  dplyr::select(row,id, hash_key, ano_bd, sexo, identidad_de_genero,edad_al_ing, fech_ing, fech_egres, tipo_de_plan_2,tipo_de_programa_2, senda)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 8. HASHs with more than one Sex",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#_______________________
###PARA HACER LA CONVERSION
#_______________________
#ha_estado_embarazada_egreso , embarazo x_se_trata_mujer_emb,tipo_de_programa_2
CONS_C1_df_dup_FEB_2020_prev23 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev23_sex)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n==2) %>% #casos en que hay que recurrir a otras variables
dplyr::arrange(hash_key) %>%
  dplyr::mutate(sex_id=stringi::stri_sub(id,5,5)) %>%
  dplyr::select(row,hash_key, id, id_mod, sexo_2,ano_bd,ha_estado_embarazada_egreso,x_se_trata_mujer_emb,tipo_de_programa_2,sex_id) %>% 
dplyr::group_by(hash_key) %>% 
    dplyr::mutate(rn=row_number()) %>% 
  as.data.frame() %>%
reshape(idvar = "hash_key", timevar = "rn", direction = "wide") %>%
    dplyr::mutate(sexo_2.1=as.character(sexo_2.1))%>%
    dplyr::mutate(sexo_2.2=as.character(sexo_2.2))%>%
    dplyr::mutate(sexo_2.1 = case_when(as.character(tipo_de_programa_2.1)=="Programa Específico Mujeres" ~ "Mujer",
                        as.character(x_se_trata_mujer_emb.1)=="Si"  ~ "Mujer",
                        as.character(ha_estado_embarazada_egreso.1)=="Si" ~ "Mujer",
                    as.character(tipo_de_programa_2.2)=="Programa Específico Mujeres" ~ "Mujer",
                        as.character(x_se_trata_mujer_emb.2)=="Si"  ~ "Mujer",
                        as.character(ha_estado_embarazada_egreso.2)=="Si" ~ "Mujer",
                    TRUE ~ as.character(sexo_2.1))) %>%
    dplyr::mutate(sexo_2.2 = case_when(as.character(tipo_de_programa_2.1)=="Programa Específico Mujeres" ~ "Mujer",
                        as.character(x_se_trata_mujer_emb.1)=="Si"  ~ "Mujer",
                        as.character(ha_estado_embarazada_egreso.1)=="Si" ~ "Mujer",
                    as.character(tipo_de_programa_2.2)=="Programa Específico Mujeres" ~ "Mujer",
                        as.character(x_se_trata_mujer_emb.2)=="Si"  ~ "Mujer",
                        as.character(ha_estado_embarazada_egreso.2)=="Si" ~ "Mujer",
                    TRUE ~ as.character(sexo_2.2))) %>% #el sexo debiese ser el mismo.
  dplyr::mutate(id_mod.1=ifelse(sexo_2.1=="Mujer",`substr<-`(id_mod.1,5,5,"2"),`substr<-`(id_mod.1,5,5,"1"))) %>%
  dplyr::mutate(id_mod.2=ifelse(sexo_2.2=="Mujer",`substr<-`(id_mod.2,5,5,"2"),`substr<-`(id_mod.1,5,5,"1"))) %>%
  dplyr::mutate(id.1=ifelse(sexo_2.1=="Mujer",`substr<-`(id.1,5,5,"2"),`substr<-`(id.1,5,5,"1"))) %>%
  dplyr::mutate(id.2=ifelse(sexo_2.2=="Mujer",`substr<-`(id.2,5,5,"2"),`substr<-`(id.1,5,5,"1"))) %>%
  dplyr::mutate(sexo_2.1=as.factor(sexo_2.1))%>%
  dplyr::mutate(sexo_2.2=as.factor(sexo_2.2))%>%
#2.1 es el que capturó la complejidad
long_panel(id="comun_hash",prefix = ".", begin = 1, end = 2, label_location = "end") %>%
as.data.table() %>%
  dplyr::filter(wave==1) %>%
assign("hash_sex_misma_bd_2_casos",., envir = .GlobalEnv)
CONS_C1_df_dup_FEB_2020_prev23 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev23_sex)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n>2) %>% 
dplyr::select(-n) %>%
dplyr::mutate(concat_hash_sex=paste0(hash_key,"_",sexo)) %>%
dplyr::group_by(concat_hash_sex) %>%
dplyr::add_tally() %>%  #agrego un nuevo n, para contar los distintos sexos
dplyr::select(row,concat_hash_sex,hash_key, id, id_mod, sexo_2,ano_bd,ha_estado_embarazada_egreso,x_se_trata_mujer_emb,tipo_de_programa_2,n) %>% 
dplyr::ungroup() %>%  
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(n)) %>% #me quedo con la concatenación por hash key que más se repite.
dplyr::ungroup() %>%
assign("hash_sex_most_freq_value",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev23 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev23_sex)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis>1) %>% 
dplyr::arrange(hash_key) %>%
dplyr::select(row,hash_key, id, id_mod, sexo_2,ano_bd,ha_estado_embarazada_egreso,x_se_trata_mujer_emb,tipo_de_programa_2,n) %>% 
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(ano_bd)) %>%
dplyr::ungroup() %>%
assign("hash_sex_most_recent_db",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev23 %>%
  dplyr::left_join(hash_sex_misma_bd_2_casos, by="hash_key",suffix=c("","_sex_misma_bd_2_casos")) %>%
  dplyr::mutate(id= ifelse(!is.na(sexo_2_sex_misma_bd_2_casos),id_sex_misma_bd_2_casos,id)) %>%
  dplyr::mutate(id_mod= ifelse(!is.na(sexo_2_sex_misma_bd_2_casos),id_mod_sex_misma_bd_2_casos,id_mod)) %>%
  dplyr::mutate(sexo_2= ifelse(!is.na(sexo_2_sex_misma_bd_2_casos), as.character(sexo_2_sex_misma_bd_2_casos), as.character(sexo_2))) %>%
  dplyr::select(-ends_with("_sex_misma_bd_2_casos")) %>% 
  #janitor::tabyl(sexo_2) %>%
  dplyr::left_join(hash_sex_most_freq_value, by="hash_key",suffix=c("","_sex_mfv")) %>%
  dplyr::mutate(id= ifelse(!is.na(sexo_2_sex_mfv),id_sex_mfv,id)) %>%
  dplyr::mutate(id_mod= ifelse(!is.na(sexo_2_sex_mfv),id_mod_sex_mfv,id_mod)) %>%
  dplyr::mutate(sexo_2= ifelse(!is.na(sexo_2_sex_mfv), as.character(sexo_2_sex_mfv), as.character(sexo_2))) %>%
  dplyr::select(-ends_with("_sex_mfv")) %>%
  dplyr::left_join(hash_sex_most_recent_db, by="hash_key",suffix=c("","_sex_recent_db")) %>%
  dplyr::mutate(id= ifelse(!is.na(sexo_2_sex_recent_db),id_sex_recent_db,id)) %>%
  dplyr::mutate(id_mod= ifelse(!is.na(sexo_2_sex_recent_db),id_mod_sex_recent_db,id_mod)) %>%
  dplyr::mutate(sexo_2= ifelse(!is.na(sexo_2_sex_recent_db), as.character(sexo_2_sex_recent_db), as.character(sexo_2))) %>%
  dplyr::select(-ends_with("_sex_recent_db"),-wave,-concat_hash_sex,-n,-sex_id,-comun_hash) %>%
  #dplyr::select(row,id, id_mod,sexo_2,ends_with("_sex_mfv"),ends_with("_sex_recent_db"),ends_with("_sex_misma_bd_2_casos")) %>% 
  #dplyr::filter(!is.na(sexo_2_sex_recent_db))
  dplyr::mutate(sexo_2=as.factor(sexo_2)) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev24",., envir = .GlobalEnv)
    #dplyr::filter(hash_key=="00012586ea3036b7a18093c396847a87")
#para comprobar cómo le fue
#CONS_C1_df_dup_FEB_2020_prev24 %>% dplyr::group_by(hash_key) %>% dplyr::mutate(sexo_por_hash=dplyr::n_distinct(sexo_2)) %>% ungroup() %>% dplyr::filter(sexo_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)
```

<!--- La fecha de nacimiento puede no haberse corregido del todo porque hay muchos casos en que no tienen una edad distinta, por lo que el programa no  los filtra  --->
- Date of Birth (fech_nac) (`r CONS_C1_df_dup_FEB_2020_prev24 %>% group_by(hash_key) %>% dplyr::mutate(fech_nac_por_hash=n_distinct(fech_nac)) %>% ungroup() %>% dplyr::filter(fech_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`) (different date of birth that does not impact on age). In cases with nothing than 2 distinct dates of birth with datasets from the same year, we replace the date of birth with the mean between both dates.

```{r pers_info_fech_nac,eval=T, echo=T, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev24_fech_nac <- CONS_C1_df_dup_FEB_2020_prev24 %>% group_by(hash_key) %>% dplyr::mutate(fech_nac_por_hash=n_distinct(fech_nac)) %>% ungroup() %>% dplyr::filter(fech_nac_por_hash>1) %>% dplyr::distinct(hash_key)
CONS_C1_df_dup_FEB_2020_prev24 %>% 
 dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev24_fech_nac)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(hash_key) %>% #ordeno por ids 
dplyr::select(row, hash_key, ano_bd, id_mod, sexo, fech_nac,ano_nac,edad,edad_al_ing, fech_ing, fech_egres,fech_egres_imp, tipo_de_plan, senda)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 9. HASHs with more than one Date of Birth",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#_______________________
###PARA HACER LA CONVERSION
#_______________________
#edad_al_ingreso , ano_nac,
##    dplyr::mutate(fech_nac=lubridate::parse_date_time(stringi::stri_sub(id,-8,-1),"dmY")) %>% 
CONS_C1_df_dup_FEB_2020_prev24 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev24_fech_nac)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n==2) %>% #casos en que hay que recurrir a otras variables
dplyr::arrange(hash_key) %>%
  dplyr::select(row,hash_key, id, id_mod, edad,ano_bd,ano_nac,fech_nac) %>% 
dplyr::group_by(hash_key) %>% 
    dplyr::mutate(rn=row_number()) %>% 
  as.data.frame() %>%
reshape(idvar = "hash_key", timevar = "rn", direction = "wide") %>%
  dplyr::mutate(fech_nac_num.1=as.numeric(as.Date(fech_nac.1)), fech_nac_num.2=as.numeric(as.Date(fech_nac.2))) %>%
  rowwise() %>% 
  dplyr::mutate(mean_fech_nac=rowMeans(cbind(fech_nac_num.1,fech_nac_num.2), na.rm=T)) %>%
  dplyr::ungroup() %>%
  dplyr::mutate(mean_fech_nac=lubridate::parse_date_time(as.character(as.Date(mean_fech_nac)),"Ymd")) %>%
  dplyr::mutate(mean_fech_nac_char=as.character(format(as.Date(as.character(mean_fech_nac)), "%d%m%Y"))) %>%
  dplyr::mutate(id.1=`substr<-`(id.1,6,13,mean_fech_nac_char)) %>%
  dplyr::mutate(id.2=`substr<-`(id.2,6,13,mean_fech_nac_char)) %>%
  dplyr::mutate(id_mod.1=sub("(.{5}).", "\\1*",id.1)) %>%
  dplyr::mutate(id_mod.1=sub("(.{6}).", "\\1*",id_mod.1)) %>%
  dplyr::mutate(id_mod.2=sub("(.{5}).", "\\1*",id.2)) %>%
  dplyr::mutate(id_mod.2=sub("(.{6}).", "\\1*",id_mod.2)) %>%
#dejo la edad al ingreso al final, para no perder la complejidad de una variable que depende de la fecha de ingreso.
long_panel(id="comun_hash",prefix = ".", begin = 1, end = 2, label_location = "end") %>%
as.data.table() %>%
  dplyr::filter(wave==1) %>%
assign("hash_fech_nac_misma_bd_2_casos",., envir = .GlobalEnv)
CONS_C1_df_dup_FEB_2020_prev24 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev24_fech_nac)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n>2) %>% #más de 2 hash, pero todos dentro de la misma bd del mismo año
dplyr::select(-n) %>%
dplyr::mutate(concat_hash_fech_nac=paste0(hash_key,"_",fech_nac)) %>%
dplyr::group_by(concat_hash_fech_nac) %>%
dplyr::add_tally() %>%  #agrego un nuevo n, para contar los distintos sexos
dplyr::select(row,hash_key, id, id_mod, edad,ano_bd,ano_nac,fech_nac,n) %>% 
dplyr::ungroup() %>%  
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(n)) %>% #me quedo con la concatenación por hash key que más se repite.
dplyr::ungroup() %>%
assign("hash_fech_nac_most_freq_value",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev24 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev24_fech_nac)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis>1) %>% 
dplyr::arrange(hash_key) %>%
dplyr::select(row,hash_key, id, id_mod, edad,ano_bd,ano_nac,fech_nac,n) %>% 
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(ano_bd)) %>%
dplyr::ungroup() %>%
assign("hash_fech_nac_most_recent_db",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev24 %>%
  dplyr::left_join(hash_fech_nac_misma_bd_2_casos, by="hash_key",suffix=c("","_fechnac_misma_bd_2_casos")) %>%
  dplyr::mutate(id= ifelse(!is.na(mean_fech_nac),id_fechnac_misma_bd_2_casos,id)) %>%
  dplyr::mutate(id_mod= ifelse(!is.na(mean_fech_nac),id_mod_fechnac_misma_bd_2_casos,id_mod)) %>%
  dplyr::mutate(fech_nac= ifelse(!is.na(mean_fech_nac), as.character(mean_fech_nac), as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_fechnac_misma_bd_2_casos")) %>% 
  #janitor::tabyl(sexo_2) %>%
  dplyr::left_join(hash_fech_nac_most_freq_value, by="hash_key",suffix=c("","_fechnac_mfv")) %>%
  dplyr::mutate(id= ifelse(!is.na(fech_nac_fechnac_mfv),id_fechnac_mfv,id)) %>%
  dplyr::mutate(id_mod= ifelse(!is.na(fech_nac_fechnac_mfv),id_mod_fechnac_mfv,id_mod)) %>%
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_fechnac_mfv), as.character(fech_nac_fechnac_mfv), as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_fechnac_mfv")) %>%
  dplyr::left_join(hash_fech_nac_most_recent_db, by="hash_key",suffix=c("","_fechnac_recent_db")) %>%
  dplyr::mutate(id= ifelse(!is.na(fech_nac_fechnac_recent_db),id_fechnac_recent_db,id)) %>%
  dplyr::mutate(id_mod= ifelse(!is.na(fech_nac_fechnac_recent_db),id_mod_fechnac_recent_db,id_mod)) %>%
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_fechnac_recent_db), as.character(fech_nac_fechnac_recent_db), as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_fechnac_recent_db"),-wave,-concat_hash_fech_nac,-n,-comun_hash,-mean_fech_nac,-mean_fech_nac_char,-fech_nac_num) %>%
  #dplyr::select(row,id, id_mod,feech_nac,edad_al_ing, ano_nac,ends_with("_fechnac_mfv"),ends_with("_fechnacx_recent_db"),ends_with("_fechnac_misma_bd_2_casos")) %>% 
  #dplyr::filter(!is.na(sexo_2_sex_recent_db))
  dplyr::mutate(fech_nac=lubridate::parse_date_time(as.character(as.Date(fech_nac)),"Ymd")) %>%
  dplyr::mutate(ano_nac= as.numeric(stringi::stri_sub(as.character(fech_nac),1,4))) %>%
  dplyr::mutate(edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(edad_al_ing=replace(edad_al_ing, is.na(edad), NA)) %>%
  assign("CONS_C1_df_dup_FEB_2020_prev25",., envir = .GlobalEnv)

#CONS_C1_df_dup_FEB_2020_prev25 %>% group_by(hash_key) %>% dplyr::mutate(fech_nac_por_hash=n_distinct(fech_nac)) %>% ungroup() %>% dplyr::filter(fech_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)
```

- Nationallity (nacionalidad) (`r CONS_C1_df_dup_FEB_2020_prev25 %>% group_by(hash_key) %>% dplyr::mutate(nacionalidad_por_hash=n_distinct(nacionalidad)) %>% ungroup() %>% dplyr::filter(nacionalidad_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`). In cases where there are only two distinct nationallities per hash and comes from the same yearly dataset, we created a second variable called `nacionalidad_2` that contains the second nationallity.

```{r pers_info_nationallity, eval=T,echo=T, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev25_nat <- CONS_C1_df_dup_FEB_2020_prev25 %>% group_by(hash_key) %>% dplyr::mutate(nat_por_hash=n_distinct(nacionalidad)) %>% ungroup() %>% dplyr::filter(nat_por_hash>1) %>% dplyr::distinct(hash_key)
CONS_C1_df_dup_FEB_2020_prev25 %>% 
 dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev25_nat)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(hash_key) %>% #ordeno por ids 
dplyr::select(row, hash_key, ano_bd, nacionalidad, etnia, sexo, fech_nac,edad_al_ing, fech_ing, fech_egres, tipo_de_plan, senda)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 10. HASHs with more than one Nationallity",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#
#CONS_C1_df_dup_FEB_2020_prev25 %>%
#janitor::tabyl(nacionalidad,etnia) %>%
#_______________________
###PARA HACER LA CONVERSION
#_______________________
CONS_C1_df_dup_FEB_2020_prev25 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev25_nat)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n==2) %>% #casos en que hay que recurrir a otras variables
dplyr::arrange(hash_key) %>%
 dplyr::select(row, hash_key, ano_bd, nacionalidad, etnia)%>%
#dejarla como segunda nacionalidad
  dplyr::group_by(hash_key) %>% 
    dplyr::mutate(rn=row_number()) %>% 
  as.data.frame() %>%
  reshape(idvar = "hash_key", timevar = "rn", direction = "wide") %>%
dplyr::select(hash_key,nacionalidad.1,nacionalidad.2) %>%
  dplyr::rename("nacionalidad_1"="nacionalidad.1","nacionalidad_2"="nacionalidad.2") %>%
  assign("nat_misma_bd_2_casos",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev25 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev25_nat)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n>2) %>% #más de 2 hash, pero todos dentro de la misma bd del mismo año
dplyr::select(-n) %>%
dplyr::mutate(concat_hash_nat=paste0(hash_key,"_",nacionalidad)) %>%
dplyr::group_by(concat_hash_nat) %>%
dplyr::add_tally() %>%  #agrego un nuevo n, para contar los distintos nacionalidades
dplyr::select(row,concat_hash_nat, hash_key, ano_bd, nacionalidad, etnia,n)%>%
dplyr::ungroup() %>%  
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(n)) %>% #me quedo con la concatenación por hash key que más se repite.
dplyr::ungroup() %>%
assign("hash_nat_most_freq_value",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev25 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev25_nat)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis>1) %>% 
dplyr::arrange(hash_key) %>%
dplyr::select(row,hash_key, ano_bd, nacionalidad, etnia,n)%>%
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(ano_bd)) %>%
dplyr::ungroup() %>%
assign("hash_nat_most_recent_db",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev25 %>%
  dplyr::left_join(nat_misma_bd_2_casos, by="hash_key",suffix=c("","_nat_misma_bd_2_casos")) %>%
  dplyr::mutate(nacionalidad= ifelse(!is.na(nacionalidad_1), as.character(nacionalidad_1), as.character(nacionalidad))) %>%
  dplyr::select(-ends_with("_nat_misma_bd_2_casos")) %>% 
  #janitor::tabyl(sexo_2) %>%
  dplyr::left_join(hash_nat_most_freq_value, by="hash_key",suffix=c("","_nat_mfv")) %>%
  dplyr::mutate(nacionalidad= ifelse(!is.na(nacionalidad_nat_mfv), as.character(nacionalidad_nat_mfv), as.character(nacionalidad))) %>%
  dplyr::select(-ends_with("_nat_mfv")) %>%
  dplyr::left_join(hash_nat_most_recent_db, by="hash_key",suffix=c("","_nat_recent_db")) %>%
  dplyr::mutate(nacionalidad= ifelse(!is.na(nacionalidad_nat_recent_db), as.character(nacionalidad_nat_recent_db), as.character(nacionalidad))) %>%
  dplyr::select(-ends_with("_nat_recent_db"),-concat_hash_nat,-n,-nacionalidad_1) %>%
  dplyr::mutate(nacionalidad=as.factor(nacionalidad))%>%
  dplyr::mutate(nacionalidad_2=as.factor(nacionalidad_2))%>%
    assign("CONS_C1_df_dup_FEB_2020_prev26",., envir = .GlobalEnv)
#CONS_C1_df_dup_FEB_2020_prev26 %>% group_by(hash_key) %>% dplyr::mutate(nac_por_hash=n_distinct(nacionalidad)) %>% ungroup() %>% dplyr::filter(nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)
```

- Ethnicity (etnia) (`r CONS_C1_df_dup_FEB_2020_prev26 %>% group_by(hash_key) %>% dplyr::mutate(etnia_por_hash=n_distinct(etnia)) %>% ungroup() %>% dplyr::filter(etnia_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`). In case of users that had two treatments in the same yearly dataset, but in each one they had a different value in this variable, we discarded missing values or "no pertenece" first, and replaced it with a valid ethnic group if in one of the treatments the user declared so. Also, we discarded missing values in the other cases, because missing values were being considered as a distinct value. **Must take into account this selection in the future**.

```{r pers_info_etnia, eval=T,echo=T, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev26_etnia <- CONS_C1_df_dup_FEB_2020_prev26 %>% group_by(hash_key) %>% dplyr::mutate(etnia_por_hash=n_distinct(etnia)) %>% ungroup() %>% dplyr::filter(etnia_por_hash>1) %>% dplyr::distinct(hash_key)
CONS_C1_df_dup_FEB_2020_prev26 %>% 
 dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev26_etnia)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(hash_key) %>% #ordeno por ids 
dplyr::select(row, hash_key, ano_bd, nacionalidad, etnia)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 11. HASHs with more than one Ethnicity",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#_______________________
###PARA HACER LA CONVERSION
#_______________________
CONS_C1_df_dup_FEB_2020_prev26 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev26_etnia)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n==2) %>% #casos en que hay que recurrir a otras variables
dplyr::arrange(hash_key) %>%
 dplyr::select(row, hash_key, ano_bd, nacionalidad, etnia)%>%
#dejarla como segunda nacionalidad
  dplyr::group_by(hash_key) %>% 
    dplyr::mutate(rn=row_number()) %>% 
  as.data.frame() %>%
  reshape(idvar = "hash_key", timevar = "rn", direction = "wide") %>%
dplyr::mutate(etnia.1=as.character(etnia.1)) %>%
dplyr::mutate(etnia.2=as.character(etnia.2)) %>%
  #para que diga no pertenece en vez de nada
dplyr::mutate(etnia.1=ifelse(is.na(etnia.1)&etnia.2=="No pertenece","No pertenece",etnia.1))  %>%
dplyr::mutate(etnia.2=ifelse(is.na(etnia.1)&etnia.2=="No pertenece","No pertenece",etnia.2))  %>%
dplyr::mutate(etnia.1=ifelse(is.na(etnia.2)&etnia.1=="No pertenece","No pertenece",etnia.1))   %>%
dplyr::mutate(etnia.2=ifelse(is.na(etnia.2)&etnia.1=="No pertenece","No pertenece",etnia.2))  %>%
#cuando una col es no pertenece o vacío, es reemplazada por la otra columna
dplyr::mutate(etnia.1=ifelse(is.na(etnia.1)&etnia.2 %in% c("Aimara","Alacalufe","Atacame?","Colla","Diaguitas","Mapuche","Quechua","Rapa Nui","Y?na"),etnia.2,etnia.1))  %>%
dplyr::mutate(etnia.1=ifelse(etnia.1=="No pertenece"&etnia.2 %in% c("Aimara","Alacalufe","Atacame?","Colla","Diaguitas","Mapuche","Quechua","Rapa Nui","Y?na"),etnia.2,etnia.1))  %>%
dplyr::mutate(etnia.2=ifelse(is.na(etnia.2)&etnia.1 %in% c("Aimara","Alacalufe","Atacame?","Colla","Diaguitas","Mapuche","Quechua","Rapa Nui","Y?na"),etnia.1,etnia.2))  %>%
dplyr::mutate(etnia.2=ifelse(etnia.2=="No pertenece"&etnia.1 %in% c("Aimara","Alacalufe","Atacame?","Colla","Diaguitas","Mapuche","Quechua","Rapa Nui","Y?na"),etnia.1,etnia.2))  %>%
#GENERAR UNA TERCERA COLUMNA PARA CASOS CON MAS DE UNA ETNIA
dplyr::mutate(etnia_2=ifelse(etnia.2 !=etnia.1,etnia.2,NA)) %>%
  long_panel(id="comun_hash",prefix = ".", begin = 1, end = 2, label_location = "end") %>%
as.data.table() %>%
  dplyr::filter(wave==1) %>%
dplyr::select(hash_key,etnia,etnia_2) %>%
  dplyr::rename("etnia_1"="etnia") %>%
  assign("etnia_misma_bd_2_casos",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev26 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev26_etnia)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n>2) %>% #más de 2 hash, pero todos dentro de la misma bd del mismo año
dplyr::select(-n) %>%
#necesario descartar valores perdidos, no son opción para reemplazo
dplyr::filter(!is.na(etnia)) %>% 
dplyr::mutate(concat_hash_etnia=paste0(hash_key,"_",etnia)) %>%
dplyr::group_by(concat_hash_etnia) %>%
dplyr::add_tally() %>%  #agrego un nuevo n, para contar los distintos nacionalidades
dplyr::select(row,concat_hash_etnia, hash_key, ano_bd, nacionalidad, etnia,n)%>%
dplyr::ungroup() %>%  
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(n)) %>% #me quedo con la concatenación por hash key que más se repite.
dplyr::ungroup() %>%
assign("hash_etnia_most_freq_value",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev26 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev26_etnia)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis>1) %>% 
dplyr::arrange(hash_key) %>%
  #debo filtrar valores perdidos
dplyr::filter(!is.na(etnia)) %>% 
dplyr::select(row,hash_key, ano_bd, nacionalidad, etnia,n)%>%
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(ano_bd)) %>%
dplyr::ungroup() %>%
assign("hash_etnia_most_recent_db",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev26 %>%
  dplyr::left_join(etnia_misma_bd_2_casos, by="hash_key",suffix=c("","_etnia_misma_bd_2_casos")) %>%
  dplyr::mutate(etnia= ifelse(!is.na(etnia_1), as.character(etnia_1), as.character(etnia))) %>%
  dplyr::select(-ends_with("_etnia_misma_bd_2_casos")) %>% 
  #janitor::tabyl(sexo_2) %>%
  dplyr::left_join(hash_etnia_most_freq_value, by="hash_key",suffix=c("","_etnia_mfv")) %>%
  dplyr::mutate(etnia= ifelse(!is.na(etnia_etnia_mfv), as.character(etnia_etnia_mfv), as.character(etnia))) %>%
  dplyr::select(-ends_with("_etnia_mfv")) %>%
  dplyr::left_join(hash_etnia_most_recent_db, by="hash_key",suffix=c("","_etnia_recent_db")) %>%
  dplyr::mutate(etnia= ifelse(!is.na(etnia_etnia_recent_db), as.character(etnia_etnia_recent_db), as.character(etnia))) %>%
  dplyr::select(-ends_with("_etnia_recent_db"),-concat_hash_etnia,-n,-etnia_1) %>%
  dplyr::mutate(etnia=as.factor(etnia))%>%
    assign("CONS_C1_df_dup_FEB_2020_prev27",., envir = .GlobalEnv)
#CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(et_por_hash=n_distinct(etnia)) %>% ungroup() %>% dplyr::filter(et_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)
#CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(et_por_hash=n_distinct(etnia)) %>% ungroup() %>% dplyr::filter(et_por_hash>1) %>% dplyr::arrange(hash_key) %>% dplyr::select(row,hash_key, ano_bd, nacionalidad, etnia)
```

- Age of Onset of Drug Use (edad_ini_cons) (`r CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(edad_ini_cons_por_hash=n_distinct(edad_ini_cons)) %>% ungroup() %>% dplyr::filter(edad_ini_cons_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`). There are too many distinct values by each user. This value should be imputed.

```{r pers_info_edad_ini_cons,eval=F, echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev27_edad_ini_cons <- CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(edad_ini_cons_por_hash=n_distinct(edad_ini_cons)) %>% ungroup() %>% dplyr::filter(edad_ini_cons_por_hash>1) %>% dplyr::distinct(hash_key)
CONS_C1_df_dup_FEB_2020_prev27 %>% 
 dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_edad_ini_cons)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(hash_key) %>% #ordeno por ids 
dplyr::select(row, hash_key, ano_bd, edad_ini_cons, edad, fech_nac,edad_al_ing, fech_ing, fech_egres_imp, tipo_de_plan, senda)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 12. HASHs with more than one Age of Onset of Drug Use",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#_______________________
###PARA HACER LA CONVERSION
#_______________________
CONS_C1_df_dup_FEB_2020_prev27 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_edad_ini_cons)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n==2) %>% #casos en que hay que recurrir a otras variables
dplyr::arrange(hash_key) %>%
 dplyr::select(row, hash_key, ano_bd, edad_ini_cons, edad, fech_nac,edad_al_ing)%>%
#dejarla como segunda nacionalidad
  dplyr::group_by(hash_key) %>% 
    dplyr::mutate(rn=row_number()) %>% 
  as.data.frame() %>%
  reshape(idvar = "hash_key", timevar = "rn", direction = "wide") %>%
  dplyr::mutate(mean_edad_ini_cons=round(rowMeans(cbind(edad_ini_cons.1,edad_ini_cons.2), na.rm=T),0)) %>%
dplyr::select(hash_key,mean_edad_ini_cons) %>%
  assign("edad_ini_cons_misma_bd_2_casos",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev27 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_edad_ini_cons)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n>2) %>% #más de 2 hash, pero todos dentro de la misma bd del mismo año
dplyr::select(-n) %>%
dplyr::mutate(concat_hash_edadinicons=paste0(hash_key,"_",edad_ini_cons)) %>%
dplyr::group_by(concat_hash_edadinicons) %>%
dplyr::add_tally() %>%  #agrego un nuevo n, para contar los distintos nacionalidades
 dplyr::select(row, hash_key, ano_bd, edad_ini_cons, edad, fech_nac,edad_al_ing,n)%>%
dplyr::ungroup() %>%  
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(n)) %>% #me quedo con la concatenación por hash key que más se repite.
dplyr::ungroup() %>%
assign("hash_edadinicons_most_freq_value",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev27 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_edad_ini_cons)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis>1) %>% 
dplyr::arrange(hash_key) %>%
dplyr::select(row, hash_key, ano_bd, edad_ini_cons, edad, fech_nac,edad_al_ing,n)%>%
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(ano_bd)) %>%
dplyr::ungroup() %>%
assign("hash_edadinicons_most_recent_db",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev27 %>%
  dplyr::left_join(edad_ini_cons_misma_bd_2_casos, by="hash_key",suffix=c("","_edadinicons_misma_bd_2_casos")) %>%
  dplyr::mutate(edad_ini_cons= ifelse(!is.na(mean_edad_ini_cons), mean_edad_ini_cons, edad_ini_cons)) %>%
  dplyr::select(-ends_with("_edadinicons_misma_bd_2_casos")) %>% 
  #janitor::tabyl(sexo_2) %>%
  dplyr::left_join(hash_edadinicons_most_freq_value, by="hash_key",suffix=c("","_edadinicons_mfv")) %>%
  dplyr::mutate(etnia= ifelse(!is.na(edad_ini_cons_edadinicons_mfv), edad_ini_cons_edadinicons_mfv, edad_ini_cons)) %>%
  dplyr::select(-ends_with("_edadinicons_mfv")) %>%
  dplyr::left_join(hash_edadinicons_most_recent_db, by="hash_key",suffix=c("","_edadinicons_recent_db")) %>%
  dplyr::mutate(etnia= ifelse(!is.na(edad_ini_cons_edadinicons_recent_db), edad_ini_cons_edadinicons_recent_db, edad_ini_cons)) %>%
  dplyr::select(-ends_with("_edadinicons_recent_db"),-concat_hash_edadinicons,-n,mean_edad_ini_cons) %>%
    assign("CONS_C1_df_dup_FEB_2020_prev28",., envir = .GlobalEnv)
#CONS_C1_df_dup_FEB_2020_prev28 %>% group_by(hash_key) %>% dplyr::mutate(edad_ini_cons_por_hash=n_distinct(edad_ini_cons)) %>% ungroup() %>% dplyr::filter(edad_ini_cons_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)
```

- Age of Onset of Drug Use Principal Substance (edad_ini_sus_prin) (`r CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(edad_ini_sus_prin_por_hash=n_distinct(edad_ini_sus_prin)) %>% ungroup() %>% dplyr::filter(edad_ini_sus_prin_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`). There are too many distinct values by each user. This value should be imputed.
<!--- #considerar que no sea mayor a la edad de inicio de consumo --->

```{r pers_info_edad_ini_sus_prin,eval=F, echo=F, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev28_edad_ini_sus_prin <- CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(edad_ini_sus_prin_por_hash=n_distinct(edad_ini_sus_prin)) %>% ungroup() %>% dplyr::filter(edad_ini_sus_prin_por_hash>1) %>% dplyr::distinct(hash_key)
CONS_C1_df_dup_FEB_2020_prev27 %>% 
 dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev28_edad_ini_sus_prin)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(hash_key) %>% #ordeno por ids 
dplyr::select(row, hash_key, ano_bd, edad_ini_cons, edad, fech_nac,edad_al_ing, fech_ing, fech_egres_imp, tipo_de_plan, senda)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 13. HASHs with more than one Age of Onset of Drug Use Principal Substance",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#_______________________
###PARA HACER LA CONVERSION
#_______________________
CONS_C1_df_dup_FEB_2020_prev28 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev28_edad_ini_sus_prin)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n==2) %>% #casos en que hay que recurrir a otras variables
dplyr::arrange(hash_key) %>%
 dplyr::select(row, hash_key, ano_bd, edad_ini_sus_prin, edad, fech_nac,edad_al_ing)%>%
#dejarla como segunda nacionalidad
  dplyr::group_by(hash_key) %>% 
    dplyr::mutate(rn=row_number()) %>% 
  as.data.frame() %>%
  reshape(idvar = "hash_key", timevar = "rn", direction = "wide") %>%
  dplyr::mutate(mean_edad_ini_sus_prin=round(rowMeans(cbind(edad_ini_sus_prin.1,edad_ini_sus_prin.2), na.rm=T),0)) %>%
dplyr::select(hash_key,mean_edad_ini_sus_prin) %>%
  assign("edad_ini_sus_prin_misma_bd_2_casos",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev28 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev28_edad_ini_sus_prin)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n>2) %>% #más de 2 hash, pero todos dentro de la misma bd del mismo año
dplyr::select(-n) %>%
dplyr::mutate(concat_hash_edadinisusprin=paste0(hash_key,"_",edad_ini_sus_prin)) %>%
dplyr::group_by(concat_hash_edadinisusprin) %>%
dplyr::add_tally() %>%  #agrego un nuevo n, para contar los distintos nacionalidades
 dplyr::select(row, hash_key, ano_bd, edad_ini_sus_prin, edad, fech_nac,edad_al_ing,n)%>%
dplyr::ungroup() %>%  
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(n)) %>% #me quedo con la concatenación por hash key que más se repite.
dplyr::ungroup() %>%
assign("hash_edadinisusprin_most_freq_value",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev28 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev28_edad_ini_sus_prin)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis>1) %>% 
dplyr::arrange(hash_key) %>%
dplyr::select(row, hash_key, ano_bd, edad_ini_sus_prin, edad, fech_nac,edad_al_ing,n)%>%
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(ano_bd)) %>%
dplyr::ungroup() %>%
assign("hash_edadinisusprin_most_recent_db",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev28 %>%
  dplyr::left_join(edad_ini_sus_prin_misma_bd_2_casos, by="hash_key",suffix=c("","_edadinisusprin_misma_bd_2_casos")) %>%
  dplyr::mutate(edad_ini_sus_prin= ifelse(!is.na(mean_edad_ini_sus_prin), mean_edad_ini_sus_prin, edad_ini_sus_prin)) %>%
  dplyr::select(-ends_with("_edadinisusprin_misma_bd_2_casos")) %>% 
  #janitor::tabyl(sexo_2) %>%
  dplyr::left_join(hash_edadinisusprin_most_freq_value, by="hash_key",suffix=c("","_edadinisusprin_mfv")) %>%
  dplyr::mutate(etnia= ifelse(!is.na(edad_ini_sus_prin_edadinisusprin_mfv), edad_ini_sus_prin_edadinisusprin_mfv, edad_ini_sus_prin)) %>%
  dplyr::select(-ends_with("_edadinisusprin_mfv")) %>%
  dplyr::left_join(hash_edadinisusprin_most_recent_db, by="hash_key",suffix=c("","_edadinisusprin_recent_db")) %>%
  dplyr::mutate(etnia= ifelse(!is.na(edad_ini_sus_prin_edadinisusprin_recent_db), edad_ini_sus_prin_edadinisusprin_recent_db, edad_ini_sus_prin)) %>%
  dplyr::select(-ends_with("_edadinisusprin_recent_db"),-concat_hash_edadinisusprin,-n,mean_edad_ini_sus_prin) %>%
    assign("CONS_C1_df_dup_FEB_2020_prev29",., envir = .GlobalEnv)
```

- Starting Substance (sus_ini) (`r CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(sus_ini_por_hash=n_distinct(sus_ini)) %>% ungroup() %>% dplyr::filter(sus_ini_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`). For users that only had two treatments but a different starting substance, we added a second variable called `sus_ini_2` that contains a second starting substance.

<!---# considerar que no sea mayor a la edad de inicio de consumo --->

```{r pers_info_sus_ini, eval=T, echo=T, paged.print=TRUE}
CONS_C1_df_dup_FEB_2020_prev27_sus_ini <- CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(sus_ini_por_hash=n_distinct(sus_ini)) %>% ungroup() %>% dplyr::filter(sus_ini_por_hash>1) %>% dplyr::distinct(hash_key)
CONS_C1_df_dup_FEB_2020_prev27 %>% 
 dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_sus_ini)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(hash_key) %>%
  dplyr::select(row, hash_key, ano_bd, edad_ini_cons, edad, fech_nac,edad_al_ing, fech_ing, fech_egres_imp, tipo_de_plan, senda)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 12. HASHs with more than one Starting Substance",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")
#_______________________
###PARA HACER LA CONVERSION
#_______________________
CONS_C1_df_dup_FEB_2020_prev27 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_sus_ini)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n==2, !is.na(sus_ini)) %>% #casos en que hay que recurrir a otras variables
dplyr::arrange(hash_key) %>%
 dplyr::select(row, hash_key, ano_bd, sus_ini)%>%
#dejarla como segunda sus_ini
  dplyr::group_by(hash_key) %>% 
    dplyr::mutate(rn=row_number()) %>% 
  as.data.frame() %>%
  reshape(idvar = "hash_key", timevar = "rn", direction = "wide") %>%
dplyr::select(hash_key,sus_ini.1,sus_ini.2) %>%
  dplyr::rename("sus_ini_1"="sus_ini.1","sus_ini_2"="sus_ini.2") %>%
  assign("sus_ini_misma_bd_2_casos",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev27 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_sus_ini)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis==1,n>2,!is.na(sus_ini)) %>% #más de 2 hash, pero todos dentro de la misma bd del mismo año
dplyr::select(-n) %>%
dplyr::mutate(concat_hash_sus_ini=paste0(hash_key,"_",sus_ini)) %>%
dplyr::group_by(concat_hash_sus_ini) %>%
dplyr::add_tally() %>%  #agrego un nuevo n, para contar los distintos sus_inies
dplyr::select(row,concat_hash_sus_ini, hash_key, ano_bd, sus_ini, etnia,n)%>%
dplyr::ungroup() %>%  
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(n)) %>% #me quedo con la concatenación por hash key que más se repite.
dplyr::ungroup() %>%
assign("hash_sus_ini_most_freq_value",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev27 %>%
dplyr::filter(hash_key %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_FEB_2020_prev27_sus_ini)))))) %>% 
dplyr::group_by(hash_key) %>%
dplyr::add_tally() %>%  
dplyr::mutate(n_dis=n_distinct(ano_bd)) %>%
dplyr::ungroup() %>%
dplyr::filter(n_dis>1, !is.na(sus_ini)) %>% 
dplyr::arrange(hash_key) %>%
dplyr::select(row, hash_key, ano_bd, sus_ini, etnia,n)%>%
dplyr::group_by(hash_key) %>%
dplyr::slice(which.max(ano_bd)) %>%
dplyr::ungroup() %>%
assign("hash_sus_ini_most_recent_db",., envir = .GlobalEnv)

CONS_C1_df_dup_FEB_2020_prev27 %>%
  dplyr::left_join(sus_ini_misma_bd_2_casos, by="hash_key",suffix=c("","_sus_ini_misma_bd_2_casos")) %>%
  dplyr::mutate(sus_ini= ifelse(!is.na(sus_ini_1), as.character(sus_ini_1), as.character(sus_ini))) %>%
  dplyr::select(-ends_with("_sus_ini_misma_bd_2_casos")) %>% 
  #janitor::tabyl(sexo_2) %>%
  dplyr::left_join(hash_sus_ini_most_freq_value, by="hash_key",suffix=c("","_sus_ini_mfv")) %>%
  dplyr::mutate(sus_ini= ifelse(!is.na(sus_ini_sus_ini_mfv), as.character(sus_ini_sus_ini_mfv), as.character(sus_ini))) %>%
  dplyr::select(-ends_with("_sus_ini_mfv")) %>%
  dplyr::left_join(hash_sus_ini_most_recent_db, by="hash_key",suffix=c("","_sus_ini_recent_db")) %>%
  dplyr::mutate(sus_ini= ifelse(!is.na(sus_ini_sus_ini_recent_db), as.character(sus_ini_sus_ini_recent_db), as.character(sus_ini))) %>%
  dplyr::select(-ends_with("_sus_ini_recent_db"),-concat_hash_sus_ini,-n,-sus_ini_1) %>%
  dplyr::mutate(sus_ini=as.factor(sus_ini))%>%
  dplyr::mutate(sus_ini_2=as.factor(sus_ini_2))%>%
    assign("CONS_C1_df_dup_FEB_2020",., envir = .GlobalEnv)
  #janitor::tabyl(sexo_2) %>%

#CONS_C1_df_dup_FEB_2020_prev27 %>% group_by(hash_key) %>% dplyr::mutate(sus_ini_por_hash=n_distinct(sus_ini)) %>% ungroup() %>% dplyr::filter(sus_ini_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)
#CONS_C1_df_dup_FEB_2020 %>% group_by(hash_key) %>% dplyr::mutate(sus_ini_por_hash=n_distinct(sus_ini)) %>% ungroup() %>% dplyr::filter(sus_ini_por_hash>1) %>% dplyr::arrange(hash_key) %>% dplyr::select(row, hash_key, ano_bd, sus_ini)
#glimpse(CONS_C1_df_dup_FEB_2020$sus_ini)
```

&nbsp;
<br>

## 4. Final Treatments to dataset

<br>

Finally, we ended with a dataset of `r CONS_C1_df_dup_FEB_2020 %>% nrow %>% formatC(, format="f", big.mark=",", digits=0)` cases, with `r CONS_C1_df_dup_FEB_2020 %>% distinct(hash_key) %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)` HASHs of a mean of `r mean(CONS_C1_df_dup_FEB_2020$edad_al_ing,na.rm=T)  %>% formatC(, format="f", big.mark=",", digits=0)` years at the time they were admitted to treatment (Q1=`r quantile(CONS_C1_df_dup_FEB_2020$edad_al_ing,.25,na.rm=T) %>% formatC(, format="f", big.mark=",", digits=0)`; Q3=`r quantile(CONS_C1_df_dup_FEB_2020$edad_al_ing,.75,na.rm=T) %>% formatC(, format="f", big.mark=",", digits=0)`), and mainly composed by men (`r CONS_C1_df_dup_FEB_2020 %>% janitor::tabyl(sexo_2) %>% as.data.frame() %>% dplyr::select(percent) %>% dplyr::slice(1) %>% as.numeric() %>% scales::percent()`). In terms of administrative regions, users are mainly treated in the Metropolitan Region (`r CONS_C1_df_dup_FEB_2020 %>% janitor::tabyl(region_del_centro) %>% as.data.frame() %>% dplyr::select(percent) %>% dplyr::slice(16) %>% as.numeric() %>% scales::percent()`). 

<br>


```{r change labels,echo=F, paged.print=TRUE}
  metadata(CONS_C1_df_dup_FEB_2020)$name <- "Agreement 1 SENDA"
  metadata(CONS_C1_df_dup_FEB_2020)$description <- "Information About Agreement 1 of SENDA and MINSAL"
  
codebook::var_label(CONS_C1_df_dup_FEB_2020) <- list(row = 'Numerador de los eventos presentes en la Base de Datos/Events in the Dataset',
table = 'Origen de los Datos (de los archivos por año)/Source of Data (of files per year)',
hash_key = 'Codificación del RUT/Masked Identifier (RUT)',
ano_bd = 'Año de la Base de Datos/Year of the Dataset (Source)',
id = 'Codigo Identificación de SENDA/SENDAs ID',
nombre_centro = 'Nombre del Centro de Tratamiento/Treatment Center',
tipo_centro = 'Tipo de Centro/Type of Center',
region_del_centro = 'Región del Centro/Chilean Region of the Center',
servicio_de_salud = 'Servicio de Salud/Health Service',
tipo_de_programa = '(original, Recodificado en tipo_de_programa_2)/',
tipo_de_plan = '(original, Recodificado en tipo_de_plan_2)/',
senda = 'SENDA/SENDA',
dias_trat = 'Días de Tratamiento/Days of Treatment',
nmesesentratamiento = 'Número de Meses en Tratamiento/Number of Months in Treatment',
dias_en_senda = 'Días en SENDA/Days in SENDA',
n_meses_en_senda = 'Número de Meses en SENDA/Number of Months in SENDA',
sexo = '(original, Recodificado en sexo_2)/',
edad = 'Edad (número entero)/Year (Discrete Number)',
nombre_usuario = 'Nombre del Usuario (OCULTO y no accesible)/Name of the User (Not Accessible)',
comuna_residencia = 'Comuna de Residencia/Municipality of Residence',
origen_de_ingreso = '(original, Recodificado en origen_ingreso)/',
pais_nacimiento = 'País de Nacimiento/Country of Birth',
nacionalidad = 'Nacionalidad/Nationallity',
etnia = 'Etnia/Ethnicity',
estado_conyugal = '(original, Recodificado en estado_conyugal_2)/',
numero_de_hijos = 'Número de Hijos/Number of Children',
num_hijos_ing_trat_res = 'Número de Hijos para Ingreso a Tratamiento Residencial/Number of Children to Residential Treatment',
parentesco_con_el_jefe_de_hogar = '(Sólo presenta valores perdidos)/',
num_trat_ant = 'Número de Tratamientos Anteriores/Number of Previous Treatments',
fecha_ultimo_tratamiento = 'Fecha del Último Tratamiento (aún no formateada como fecha)/Date of the Last Treatment',
sustancia_de_inicio = '(original, Recodificado en sus_ini)/',
edad_inicio_consumo = '(original, Recodificado en edad_ini_cons)/', 
x_se_trata_mujer_emb = 'Mujer Embarazada al Ingreso/Pregnant at Admission',
escolaridad_ultimo_ano_cursado = '(original, Recodificado en escolaridad)/', 
condicion_ocupacional = '(original, Recodificado en estatus_ocupacional)/', 
categoria_ocupacional = '(original, Recodificado en cat_ocupacional)/',
rubro_trabaja = 'Rubro de Trabajo/Area of Work',
con_quien_vive = 'Persona con la que vive el Usuario/People that Share Household with the User',
tipo_de_vivienda = 'Tipo de Vivienda/Type of Housing',
tenencia_de_la_vivienda = 'Tenencia de la Vivienda/Tenure status of Households',
sustancia_principal = '(original, Recodificado en sus_principal)/',
otras_sustancias_nº1 = '(original, Recodificado en otras_sus1)/',
otras_sustancias_nº2 = '(original, Recodificado en otras_sus2)/',
otras_sustancias_nº3 = '(original, Recodificado en otras_sus3)/',
freq_cons_sus_prin_original = '(original, Recodificado en freq_cons_sus_prin)/',
edad_inicio_sustancia_principal = '(original, Recodificado en edad_ini_sus_prin)/',
via_adm_sus_prin_original = '(original, Recodificado en via_adm_sus_prin)/',
dg_trs_cons_sus_or = 'Diagnósico de Trastorno por Consumo de Sustancias/Diagnosed of Substance Use Disorder',
dg_trs_psiq_dsm_iv_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV/Diagnosis of Psychiatric Disorders, DSM-IV criteria',
dg_trs_psiq_sub_dsm_iv_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification)',
x2_dg_trs_psiq_dsm_iv_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (2)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (2)',
x2_dg_trs_psiq_sub_dsm_iv_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion) (2)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (2)',
x3_dg_trs_psiq_dsm_iv_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (3)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (3)',
x3_dg_trs_psiq_sub_dsm_iv_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion) (3)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (3)',
dg_trs_psiq_cie_10_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10/Diagnosis of Psychiatric Disorders, CIE-10 criteria',
dg_trs_psiq_sub_cie_10_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification)',
x2_dg_trs_psiq_cie_10_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (2)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (2)',
x2_dg_trs_psiq_sub_cie_10_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion) (2)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (2)',
x3_dg_trs_psiq_cie_10_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (3)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (3)',
x3_dg_trs_psiq_sub_cie_10_or = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion) (3)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (3)',
diagnostico_trs_fisico = 'Diagnóstico de Trastorno Físico/Diagnosis of Physical Disorder',
otros_probl_at_sm_or = 'Otros Problemas de Atención Vinculados a Salud Mental/Other problems linked to Mental Health',
compromiso_biopsicosocial = 'Compromiso Biopsicosocial/Biopsychosocial Involvement',
dg_global_nec_int_soc_or = 'Diagnóstico Global de Necesidades de Integración Social (Al Ingreso)/Global Diagnosis of Social Integration (At Admission)',
dg_nec_int_soc_cap_hum_or = 'Diagnóstico de Necesidades de Integración Social en Capital Humano (Al Ingreso)/Global Diagnosis of Social Integration in Human Capital (At Admission)',
dg_nec_int_soc_cap_fis_or = 'Diagnóstico de Necesidades de Integración Social en Capital Físico (Al Ingreso)/Global Diagnosis of Social Integration in Physical Capital (At Admission)',
dg_nec_int_soc_cap_soc_or = 'Diagnóstico de Necesidades de Integración Social en Capital Social (Al Ingreso)/Global Diagnosis of Social Integration in Social Capital (At Admission)',
fech_ing = 'Fecha de Ingreso a Tratamiento/Date of Admission to Treatment',
fecha_ingreso_a_convenio_senda = 'Fecha de Ingreso a Convenio SENDA (aún no formateada como fecha)/Date of Admission to SENDA Agreement',
usuario_tribunal_trat_droga = 'Usuario de modalidad Tribunales de Tratamiento de Drogas/User of Drug Treatment Courts Modality',
consentimiento_informado = 'Consentimiento Informado/Informed Consent',
fech_egres = 'Fecha de Egreso de Tratamiento/Date of Discharge from Treatment',
motivodeegreso = 'Motivo de Egreso/Cause of Discharge',
tipo_centro_derivacion = 'Tipo de Centro al que el Usuario es Derivado/Type of Center of Derivation',
evaluacindelprocesoteraputico = 'Evaluación del Proceso Terapéutico/Evaluation of the Therapeutic Process',
eva_consumo = 'Evaluación al Egreso Respecto al Patrón de consumo/Evaluation at Discharge regarding to Consumption Pattern',
eva_fam = 'Evaluación al Egreso Respecto a Situación Familiar/Evaluation at Discharge regarding to Family Situation',
eva_relinterp = 'Evaluación al Egreso Respecto a Relaciones Interpersonales/Evaluation at Discharge regarding to Interpersonal Relations',
eva_ocupacion = 'Evaluación al Egreso Respecto a Situación Ocupacional/Evaluation at Discharge regarding to Occupational Status',
eva_sm = 'Evaluación al Egreso Respecto a Salud Mental/Evaluation at Discharge regarding to Mental Health',
eva_fisica = 'Evaluación al Egreso Respecto a Salud Física/Evaluation at Discharge regarding to Physical Health',
eva_transgnorma = 'Evaluación al Egreso Respecto a Trasgresión a la Norma Social/Evaluation at Discharge regarding to Transgression to the Norm',
dg_trs_psiq_cie_10_egres_or = '(Sólo presenta valores perdidos)/',
dg_global_nec_int_soc_or_1 = 'Diagnóstico Global de Necesidades de Integración Social (Al Egreso)/Global Diagnosis of Social Integration (At Discharge)',
dg_nec_int_soc_cap_hum_or_1 = 'Diagnóstico de Necesidades de Integración Social en Capital Humano (Al Egreso)/Global Diagnosis of Social Integration in Human Capital (At Discharge)',
dg_nec_int_soc_cap_fis_or_1 = 'Diagnóstico de Necesidades de Integración Social en Capital Físico (Al Egreso)/Global Diagnosis of Social Integration in Physical Capital (At Discharge)',
dg_nec_int_soc_cap_soc_or_1 = 'Diagnóstico de Necesidades de Integración Social en Capital Social (Al Egreso)/Global Diagnosis of Social Integration in Social Capital (At Discharge)',
tiene_menores_de_edad_a_cargo = 'Menores de Edad A Cargo/Minor Dependants',
mot_egres_alt_adm_or = 'Motivo de Egreso Alta Administrativa/Cause of Administrative Discharge',
consorcio = 'Sociedades de Tratamiento, Servicios de Salud, Fundaciones, entre otras entidades encargadas de los centros/Consortium',
id_centro = 'ID de Centro/Center ID',
ha_estado_embarazada_egreso = '¿Ha estado embarazada? (al Egreso)/Have you been Pregnant (at Discharge)',
identidad_de_genero = 'Identidad de Género/Gender Identity',
discapacidad = 'Presenta Discapacidad/Disability',
hash_rut_completo = 'HASH alternativo, en el escenario en que se asuma que el individuo al que se le codificó el RUT presente mayor edad/Alternative HASH-Key',
opcion_discapacidad = 'Origen de Discapacidad/Cause of Disability',
sexo_2 = 'Sexo Usuario/Sex of User',
embarazo = 'Embarazo/Pregnant',
tipo_de_plan_2 = 'Tipo de Plan/Type of Plan',
tipo_de_programa_2 = 'Tipo de Programa de Tratamiento/Type of Program',
fech_egres_sin_fmt = 'Fecha de Egreso de Tratamiento (Sin Formato de Fecha)/Date of Discharge',
id_mod = 'ID de SENDA para Presentación en Página Web (enmascara caracteres 5 y 6)/SENDAs ID (mask characters 5 & 6)',
ano_nac = 'Año de Nacimiento (numérico)/Year of Birth (numeric)',
fech_ing_ano = 'Año de Ingreso (numérico)/Year of Admission (numeric)',
fech_ing_mes = 'Mes de Ingreso (numérico)/Month of Admission (numeric)',
fech_ing_dia = 'Día de Ingreso (numérico)/Day of Admission (numeric)',
concat = 'ID de SENDA y HASH Concatenado (permite discriminar más de un HASH en un mismo ID)/Combination of SENDAs ID & HASH',
dias_trat_inv = 'Días de Tratamiento Invertidos (fecha más reciente, menor valor numérico)/Treatment Days (Reversed)',
fech_nac = 'Fecha de Nacimiento/Date of Birth',
edad_al_ing = 'Edad a la Fecha de Ingreso a Tratamiento (numérico continuo)/Age at Admission to Treatment',
edad_ini_cons= 'Edad de Inicio de Consumo/ Age of Onset of Drug Use',
edad_ini_sus_prin =  'Edad de Inicio de Consumo Sustancia Principal/ Age of Onset of Drug Use Principal Substance',
dias_trat_alta_temprana = 'Días de tratamiento (<90)/ Less than 90 days in treatment',
motivodeegreso_mod = 'Motivo de Egreso (con abandono temprano y tardío)/Cause of Discharge (with late and early withdrawal)',
sus_principal = 'Sustancia Principal de Consumo/Main Substance of Consumption',
otras_sus1= 'Otras Sustancias (1)/Other Substances (1)',
otras_sus2= 'Otras Sustancias (2)/Other Substances (2)',
otras_sus3= 'Otras Sustancias (3)/Other Substances (3)',
sus_ini= 'Sustancia de Inicio/Starting Substance',
estado_conyugal_2='Estado Conyugal/Marital Status',
estatus_ocupacional= 'Condición Ocupacional/Occupational Status',
cat_ocupacional= 'Categoría Ocupacional/Occupational Category',
edad_grupos	= 'Edad agrupada/Age in groups',
origen_ingreso= 'Origen de Ingreso/Motive of Admission to Treatment',
escolaridad= 'Escolaridad: Nivel Eduacional/Educational Attainment',
freq_cons_sus_prin = 'Frecuencia de Consumo de la Sustancia Principal/Frequency of Consumption of the Main Substance',
via_adm_sus_prin = 'Vía de Administración de la Sustancia Principal/Route of Administration of the Main Substance',
dias_trat_knn_imp= 'Días de Tratamiento (Imputados KNN)/Days of Treatment (Imputed KNN)',
fech_egres_knn_imp= 'Fecha de Egreso (Imputados KNN)/Date of Discharge (Imputed KNN)',
dias_trat_alta_temprana_knn_imp= 'Días de Tratamiento con Alta Temprana (<90) (Imputados KNN)/Days of Treatment w Early Withdrawal (Imputed KNN)',
fech_egres_imp= 'Fecha de Egreso (Imputados KNN & Lógico)/Date of Discharge (Imputed KNN & Logic)',
motivodeegreso_imp= 'Motivo de Egreso(Imputados KNN & Lógico)/Cause of Discharge (Imputed KNN & Logic)',
motivodeegreso_mod_imp= 'Motivo de Egreso (con abandono temprano y tardío)(Imputados KNN & Lógico)/Cause of Discharge (with late and early withdrawal)(Imputed KNN & Logic)',
dias_trat_imp= 'Días de Tratamiento (Imputados KNN & Lógico)/Days of Treatment (Imputed KNN & Logic)', 
dias_trat_alta_temprana_imp= 'Días de Tratamiento con Alta Temprana (<90) (Imputados KNN & Lógico)/Days of Treatment w Early Withdrawal (Imputed KNN & Logic)',
via_adm_sus_prin_act= 'Vía de Administración de la Sustancia Principal (Se aplicaron criterios de limpieza)/Route of Administration of the Main Substance (Tidy)',
nacionalidad_2 = 'Segunda Nacionalidad/Second Nationallity',
etnia_2 = 'Etnia/Second Ethnic Group',
sus_ini_2 = 'Segunda Sustancia de Inicio/Second Starting Substance')
#PARA EXPORTAR LABELS A EXCEL
#data.table::data.table(table(CONS_C1_df_dup_FEB_2020_prev2$identidad.de.genero, exclude=NULL)) %>% mutate(export=paste0(row_number(),".",V1)) %>% select(-V1) %>% select(export,N)%>% copiar_nombres()
```

<br>

```{r generate data in csv, echo=F, paged.print=TRUE}
#write.csv2(CONS_C1_df_dup_FEB_2020_prev2, file ="G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/CONS_C1_df_dup_FEB_2020.csv")
#write.csv(.,"_matches_feb_2020.csv", row.names = FALSE)
#_#_#_#_#_#_#_#_#
#_#_#_#_#_#_#_#_#PARA CAMBIAR LOS NOMBRES DE LAS COLUMNas##_#_#_#_#_#_#_#_
##COMPARAR##
#copiar_nombres(data.frame(original = colnames(CONS_C1_df_dup_FEB_2020_prev2), clean_names = colnames(clean_names(CONS_C1_df_dup_FEB_2020_prev2))))
#_#_#_#_#_#_#_#_#
#_#_#_#_#_#_#_#_#

#####to_export_labels
tibble::rownames_to_column(data.frame(Hmisc::label(CONS_C1_df_dup_FEB_2020))) %>% data.frame() %>%
  dplyr::rename("code" = !!names(.[1]), "label" = !!names(.[2])) %>% data.frame() %>% 
 # dplyr::filter(label!="") %>%
#  bind_rows(data.frame("code"=c("fech_egres_imp", 
##                                "dias_trat_imp",
#                                "dias_trat_alta_temprana_imp",
#                                "motivodeegreso_mod_imp"), "label"=c("Date of Discharge (Imputed)", 
##                                                                     "Days of Treatment (Imputed)",
#                                                                     "Days of Treatment for Early Withdrawal (Imputed)",
#                                                                     "Cause of Discharge w/ Early or Late Withdrawal (Imputed)"))) %>% 
  write.csv2("__labels_to_stata_C1_feb_2020.csv")
CONS_C1_df_dup_FEB_2020 %>%
  dplyr::arrange(hash_key, desc(fech_ing)) %>% 
  rio::export(file = "G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/CONS_C1_df_dup_FEB_2020.dta")
save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/5.RData")
```

<br>

```{stata 2, collectcode=TRUE,results="hide"}
cap do _label_var_to_stata.do
```

## 5. Preliminary Summary in Early March 2020

Many selections for the purposes of the study are still being necessary until today, in order to  keep the greater amount of information about each event. 

```{r brief_summary, echo=T, fig.align='center', message=FALSE}
knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/Diagram_STROBE.svg")
```


