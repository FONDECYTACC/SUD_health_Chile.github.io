---
title: "Duplicated/ Repeated Cases in SISTRAT C1"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide  
    toc: true # table of content true
    toc_depth: 5  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
---

<style type="text/css">
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid black;
        }
.centrado {
    text-align: center;
}
.table.center {
    margin-left:auto; 
    margin-right:auto;
  }
.table_wrapper{
    display: block;
    overflow-x: auto;
    white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
      text-align: justify;
  }
.superbigimage{
    overflow-y:scroll;
    white-space: nowrap;
}
.superbigimage img{
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>

```{r prev, include=FALSE, cache=T}
rm(list=ls());gc()
unlink('SUD_CL/Duplicates_cache', recursive = TRUE)
```

```{r load, include=FALSE, cache=T}
load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/1.Rdata")
if(!require(dplyr)){install.packages("dplyr")}
if(!require(data.table)){install.packages("data.table")}
require(data.table)
require(dplyr)
CONS_C1_df%>%
  dplyr::mutate(fech_ing_ano = lubridate::year(fech_ing), 
                fech_ing_mes = lubridate::month(fech_ing), 
                fech_ing_dia = lubridate::day(fech_ing)) %>%
  dplyr::mutate(concat=paste0(HASH_KEY,"_",fech_ing_ano,"_",fech_ing_mes,"_",fech_ing_dia)) %>%
  dplyr::mutate(duplicated_HASH_date = duplicated(concat)) %>%
  as.data.table() %>%
  assign("CONS_C1_df_dup",.,envir = .GlobalEnv)
#45526 trues
```

```{r setup, include = FALSE, cache=T}
#Libraries used in the routine. Dont change the order
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})
#https://github.com/RevolutionAnalytics/checkpoint
if(!require(checkpoint)){install.packages("checkpoint")}
if(!require(here)){install.packages("here")}

#checkpoint::checkpoint("2020-02-11",project=here::here(),checkpointLocation=paste0(here::here(),"/Duplicates"), use.lock=F, use.knitr=T, auto.install.knitr = T,scan.rnw.with.knitr=T, forceInstall=T,scanForPackages = TRUE)
#checkpointArchives(tempdir(), full.names = TRUE)
#getOption("repos")
#normalizePath(.libPaths(), winslash = "/")
#installed.packages(.libPaths()[1])[, "Package"]
#unCheckpoint()
#.libPaths()
if(!require(knitr)){install.packages("knitr")}
if(!require(tidyr)){install.packages("tidyr")}
if(!require(janitor)){install.packages("janitor")}
if(!require(stringi)){install.packages("stringi")}
if(!require(stringr)){install.packages("stringr")}
if(!require(ggplot2)){install.packages("ggplot2")}
if(!require(Hmisc)){install.packages("Hmisc")}
if(!require(kableExtra)){install.packages("kableExtra")}
if(!require(plotly)){install.packages("plotly")}
if(!require(lubridate)){install.packages("lubridate")}
if(!require(rbokeh)){install.packages("rbokeh")}
if(!require(altair)){install.packages("altair")}
if(!require(zoo)){install.packages("zoo")}
if(!require(codebook)){install.packages("codebook")}
if(!require(broom)){install.packages("broom")}
if(!require(sqldf)){install.packages("sqldf")} 
if(!require(devtools)){install.packages("devtools")}
if(!require(Statamarkdown)){install_github("hemken/Statamarkdown")}
if(!require(haven)){install.packages("haven")}
if(!require(data.table)){install.packages("data.table")}
if(!require(dplyr)){install.packages("dplyr")}
```

## 1. Deletion of nearly exact duplicated cases

&nbsp;
<br>
The dataset was configured to find duplicated rows in almost every variable, excepting the row number in the whole consolidated dataset and the year of the dataset in which the row was obtained. For the purpose of this page, we will use the terms "rows" and "cases" as equal to refer to the entries of the dataset.

<br>

```{r echo=T, cache=T, paged.print=TRUE}
#create vector with variable names
names_c1 <- names(CONS_C1_df_dup[,c(3,5:106)])
#Group by duplicated rows 
as.data.table(CONS_C1_df_dup)[, dup_todo := .N, by = names_c1] %>%
  data.table::as.data.table() %>%
  assign("CONS_C1_df_dup_ENE_2020_prev",.,envir = .GlobalEnv)
#summarise duplicates and times
as.data.table(CONS_C1_df_dup)[, dup_todo := .N, by = names_c1] %>%
  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd)) %>%
  dplyr::group_by(dup_todo) %>%
  dplyr::summarise(n()) %>%
  data.frame() %>%
  dplyr::rename("Times present in Dataset"=dup_todo, "Number of Rows"=`n..`) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 1. Duplicated cases in almost every variable",
                 align ="cccc")  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 10)
```

```{r dataset_creation, echo=F, paged.print=TRUE, cache=T, warning=F}
data.table::data.table(CONS_C1_df_dup_ENE_2020_prev) %>%
  dplyr::arrange(desc(ano_bd)) %>%
  dplyr::distinct_(.dots = names_c1, .keep_all = TRUE) %>%
  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd), desc(fech_egres)) %>%
  data.table::as.data.table() %>%
  assign("CONS_C1_df_dup_ENE_2020_prev",.,envir = .GlobalEnv)
#Unlike base sorting with sort(), NA are: always sorted to the end for local data, even when wrapped with desc().
```

&nbsp;
<br>
Since these duplicated rows contained the same values, **no additional information is lost by deleting these rows**. Considering this, of the original `r formatC(nrow(CONS_C1_df_dup), format="f", big.mark=",", digits=0)` cases, only `r formatC(nrow(CONS_C1_df_dup_ENE_2020_prev), format="f", big.mark=",", digits=0)` rows were selected to the analysis. Still, we need to identify which row has nearly the same but more recent information regarding an specific treatment of a user, that is why we need to eliminate duplicated rows, but **keep events that contemplates more days of treatment, or comes from more recent yearly datasets**. Table 2 shows HASHs that possess negative days of treatment and their entries. **We meed to clarify some dates in order to avoid overlap between treatments. As can be seen in Table 2, a few can be replaced by an event with siilar dates, but there were others that may be imuted once the dataset is normalized.** 

<br>

```{r neg treat days, echo=T, paged.print=TRUE, message=F}
require(dplyr)
require(data.table)
HASHS_of_negtive_days_treat <- CONS_C1_df_dup_ENE_2020_prev %>% 
  dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), fech_egres_num= as.numeric(as.Date(fech_egres)),discharge_before_treatment=fech_egres_num-fech_ing_num) %>%
  dplyr::filter(discharge_before_treatment<0) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, dias_trat, SENDA) %>% dplyr::distinct(HASH_KEY)
#
CONS_C1_df_dup_ENE_2020_prev %>% 
    dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(HASHS_of_negtive_days_treat)))))) %>%
    dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd)) %>%
    dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, dias_trat, SENDA) %>% 
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 2 Negative days of treatment", align =rep('c', 101)) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::add_footnote( c("Assuming the date of retrieval, 2019-11-13"), notation = "none") %>%
  kableExtra::scroll_box(width = "100%", height = "350px")


```

<br>

The second stage consisted in **eliminating rows that contained duplicated values in some variables related to the users and more contextual variables. The following were selected:** HASH Key (HASH_KEY), date of admission (fech_ing), type of center(tipo_centro), ID of the center(ID.centro), type of program (Tipo.de.Programa), type of plan (Tipo.de.Plan), SENDA program (SENDA), main substance of consumption (Sustancia.Principal), other substances (first, second and third) (Otras.Sustancias.), frequency of consumption of the main substance (Frecuencia.de.Consumo..Sustancia.Principal), substance of initiation (Sustancia.de.Inicio) and year of the initiation (Edad.Inicio.Consumo).

<br>

```{r dataset_iteration1, echo=F, paged.print=TRUE, cache=T, warning=F, message=F}
require(data.table)
names_c1_stage2 <- c("HASH_KEY","fech_ing", "tipo_centro", "ID.centro", "Tipo.de.Programa", "Tipo.de.Plan", "SENDA", "Sustancia.Principal", "Otras.Sustancias.nº1","Otras.Sustancias.nº2","Otras.Sustancias.nº3", "Frecuencia.de.Consumo..Sustancia.Principal.","Sustancia.de.Inicio", "Edad.Inicio.Consumo")
require(dplyr)
data.table::data.table(CONS_C1_df_dup_ENE_2020_prev) %>%
  dplyr::mutate(dias_trat_inv=ifelse(dias_trat<0,0,dias_trat*-1))%>% #transforma los erroneos en 0
  #dplyr::group_by(dias_trat_inv) %>%summarise(n()) %>% View() para probarlo
  dplyr::arrange(desc(ano_bd),HASH_KEY, desc(fech_ing), desc(fech_egres),dias_trat_inv) %>%
  dplyr::distinct_(.dots = names_c1_stage2, .keep_all = TRUE) %>%
#  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd)) %>%
  data.table::as.data.table() %>% #para contar las filas
 # dplyr::select(row) %>%  summarise(mean(row), sd(row)) #, lo mismo que en STATA. Se supone que una row es sensible a cambios distintos.
  assign("CONS_C1_df_dup_ENE_2020_prev2",.,envir = .GlobalEnv)
#Lo mismo que en STATA: Ahora hay 118,121. Una vez que introduje 
#  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd), desc(fech_egres)) %>% criterio anterior
```

Of the total `r formatC(nrow(CONS_C1_df_dup_ENE_2020_prev2), format="f", big.mark=",", digits=0)` cases, there were `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(hash_rut_completo!="") %>% nrow()` with an alternative HASH key, that could be replaced if the first HASH does not match any of the HASHs Keys of another datasets. In the following table, we can see that duplicated cases may be around 5.5% per yearly datasets.

```{r echo=T, paged.print=TRUE}
#Cases by year.
CONS_C1_df_dup_ENE_2020_prev2 %>% 
      dplyr::group_by(ano_bd) %>% 
      dplyr::tally() %>%
      as.data.frame() %>%
      dplyr::mutate(ano_bd=as.numeric(ano_bd)) %>%
      assign("cant_ano",., envir = .GlobalEnv)
CONS_C1_df_dup_ENE_2020_prev2 %>% 
  dplyr::group_by(ano_bd) %>% 
  distinct(HASH_KEY) %>% 
  dplyr::summarize(n=n()) %>% 
  dplyr::mutate(ano_bd= as.numeric(ano_bd)) %>%
  dplyr::left_join(cant_ano,by="ano_bd") %>% 
  mutate(dif=`n.y`-`n.x`, "%"=paste0(round(100 * dif/`n.y`, 1), "%")) %>%
  dplyr::rename("Year"=ano_bd, "Unique HASHs"=n.x, "Total Cases"=n.y, "Diff."=dif) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 3. Differences between HASHs and unique HASHs by year",
                 align ="cccc")  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 10)
```
&nbsp;

## 2. Identification of HASH-Keys and ID's from SENDA

&nbsp;

There were `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::select(ano_bd,id,HASH_KEY) %>% dplyr::group_by(ano_bd,id) %>% tally() %>% dplyr::mutate(n_col=n) %>% dplyr::filter(n>1) %>% as.data.frame() %>% reshape::cast(.,ano_bd+id~n) %>% dplyr::arrange(ano_bd,id) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` that has more than 1 repeated SENDAs ID in each yearly dataset. This same analysis but considering more than 1 repeated HASH in each yearly dataset, is around `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::select(ano_bd,id,HASH_KEY) %>% dplyr::group_by(ano_bd,HASH_KEY) %>% tally() %>%  dplyr::mutate(n_col=n) %>%  dplyr::filter(n>1) %>%   as.data.frame() %>%  reshape::cast(.,ano_bd+HASH_KEY~n) %>% dplyr::arrange(ano_bd, HASH_KEY) %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)`. Of the `r CONS_C1_df_dup_ENE_2020_prev2 %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)` cases, around `r CONS_C1_df_dup_ENE_2020_prev2 %>%  mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)` had a unique combination of ID and HASH. There were `r CONS_C1_df_dup_ENE_2020_prev2 %>%  dplyr::distinct(HASH_KEY, .keep_all = TRUE) %>% nrow()  %>% formatC(, format="f", big.mark=",", digits=0)` unique HASHs, and `r CONS_C1_df_dup_ENE_2020_prev2 %>%  dplyr::distinct(id, .keep_all = TRUE) %>% nrow()  %>% formatC(, format="f", big.mark=",", digits=0)` unique IDs.

&nbsp;
<br>

Instead, there were `r CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(id)) %>% dplyr::arrange(id) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` users with duplicated HASH's in each ID. This represents a `r paste0(round((CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(id)) %>% dplyr::arrange(id) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow()/ CONS_C1_df_dup_ENE_2020_prev2 %>% nrow())*100,1),"%")` of the total cases. **According to indications from the professionals of SENDA, these duplicated rows correspond to different RUTs, so users may be considered as different than each other.**


```{r IDs w more than one hash, echo=T, paged.print=TRUE}
#Take which has a combination of IDs and HASH Keys distinct to the rest
#With this I may be subestimating the number of cases with a different concatenation.
#Considering all the distinct combinations, i take what they have a duplicate ID
#Select the duplicate IDs, it orders and...
#Filter only cases that has distinct id.
CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% #once here, n° of cases has been replaced by distinct or unique combinations of IDs and HASH keys.
  dplyr::filter(duplicated(id)) %>% dplyr::arrange(id) %>%  #filter cases in which there is more than one ID, despite there is differents combinations of HASH and IDs, and then arrange IDs. This is possible only if a different HASH-Key contains more than one ID or viceversa.
  dplyr::distinct(id) %>% #take distincts IDs (exclude duplicated repeated IDs)
  assign("ids_more_one_hash",., envir = .GlobalEnv) # Differently put, take the distints IDs per HASH-Key, of the cases in which there are different combinations.
# of IDs and hash, and in which subgroup exists duplicated IDs.
 
#IMPORTANT: IF THE ID IS DUPLICATED, MIGHT NOT BE REFLECTED IN THIS RESUME IN TERMS OF QUANTITY.

# Then, apply these cases to the whole population
CONS_C1_df_dup_ENE_2020_prev2 %>%
dplyr::filter(id %in% as.character(as.vector(unlist(as.data.table(unlist(ids_more_one_hash)))))) %>% # Select IDs of cited cases
dplyr::arrange(id) %>% #ordeno por ids 
  #762 cases. 409 cases without duplicates.
      dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101,-110,-11,-112) %>%
      dplyr::select(row, ano_bd, id_mod, HASH_KEY, hash_rut_completo ,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, everything()) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 4. Total cases that each ID have more than one HASH-KEY",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

&nbsp;

For example, we can appreciate that an id like "MAMO108111971"contain different HASH_KEYs: `r  CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(id=="MAMO108111971") %>% dplyr::distinct(HASH_KEY) %>%  dplyr::filter(row_number()==1)` and `r  CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(id=="MAMO108111971") %>% dplyr::distinct(HASH_KEY) %>%  dplyr::filter(row_number()==2)`.

&nbsp;

```{r echo=F, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020_prev2 %>% 
  dplyr::filter(id=="MASA124091985"|id=="NIAG108091996"|id=="JUGA108021973"|id=="MAMO108111971") %>%
  dplyr::arrange(id) %>%
      dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101) %>%
      dplyr::select(row, ano_bd, id_mod,HASH_KEY, hash_rut_completo, fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, everything()) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 5. Examples of problematic IDs",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```
&nbsp;


There were `r CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(HASH_KEY)) %>% dplyr::arrange(HASH_KEY) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` HASHs with duplicated ID's en each hash. This represents a `r paste0(round((CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(HASH_KEY)) %>% dplyr::arrange(HASH_KEY) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow()/nrow(CONS_C1_df_dup_ENE_2020_prev2))*100,1),"%")` of the total cases. A much bigger number that could mean that **HASH could be less likely to represent more than one user, compared to SENDAs ID.**

## 3. Focus on Duplicated Cases and Dates of Admission

&nbsp;

**We need to distinguish between duplicated cases and admissions from 2010 to 2019**  
One problem is that many variables could not be retrieved from  SENDAs datasets. We need to know if a certain amount of missing data can be replaced by another entry in the dataset that shares the same HASH and date of admission. A possible set of indexes could be the Date of discharge (fech_egres), Cause of discharge (motivodeegreso), Days of treatment (dias_trat) and Date of Last Treatment.

There were `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::mutate(concat=paste0(id,"_",HASH_KEY,"_",fech_ing,"_",fech_egres,"_",motivodeegreso,"_",dias_trat,"_",Fecha.Ultimo.Tratamiento)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` (which represents the `r paste0(round((CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::mutate(concat=paste0(id,"_",HASH_KEY,"_",fech_ing,"_",fech_egres,"_",motivodeegreso,"_",dias_trat,"_",Fecha.Ultimo.Tratamiento)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% nrow()*100/CONS_C1_df_dup_ENE_2020_prev2 %>% nrow),2),"%")` of the `r CONS_C1_df_dup_ENE_2020_prev2 %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` cases), with distinct cases with a unique ID, HASH, date of admission, date of discharge, cause of discharge, days treated and days of last treatment. Comparing the explanatory power of each variable: cause of discharge does not impact in the number of unique cases, maintaining other variables, neither dates of admission and discharge removed separately, maintaining the other variables, but if both are removed, we get `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::mutate(concat=paste0(id,"_",HASH_KEY,"_",motivodeegreso,"_",dias_trat,"_",Fecha.Ultimo.Tratamiento)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` unique cases. Days of treatment does, lowering into `r  CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::mutate(concat=paste0(id,"_",HASH_KEY,"_",fech_ing,"_",fech_egres,"_",motivodeegreso,"_",Fecha.Ultimo.Tratamiento)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` unique cases. If we remove the ID we get `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::mutate(concat=paste0(HASH_KEY,"_",fech_ing,"_",fech_egres,"_",motivodeegreso,"_",dias_trat,"_",Fecha.Ultimo.Tratamiento)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` unique cases.

&nbsp;

```{r echo=F, paged.print=TRUE, warning=F, message=F}
# OR plot
m1=glm(duplicated_HASH_date ~ is.na(fech_egres) + is.na(motivodeegreso) + is.na(dias_trat) + is.na(Fecha.Ultimo.Tratamiento), data=CONS_C1_df_dup_ENE_2020_prev2, family = binomial ( link = logit )) 
#m2=glm(duplicated ~ factor(sexo) + fech_egres +Fecha.Ultimo.Tratamiento, data = CONS_C1_df_dup_ENE_2020_prev2, family = binomial ( link = logit ))

m1_0 <- update(m1, . ~ 1)
require(lmtest)
cbind(Coef.=rbind("Intercept","Date of Discharge(NULL)", "Cause of Discharge(NULL)", "Days of Treatment(NULL)", "Date of Last Treatment(NULL)"),
      as.matrix.data.frame(round(Epi::ci.lin(m1, Exp=T),3))[,1:7]) %>% 
knitr::kable(., digits=3, scientific=FALSE,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 6. Coefficients of model to determinate whether events have the same HASH and Date of Admission",
      col.names= c("Covariates", "Coef.", "StdErr","z","P","OR", "CI 95% lower","CI 95% upper"),
      align =rep('c', 101)) %>%
 kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 11) %>%
  kableExtra::add_footnote(paste0("LR:",round(lmtest::lrtest(m1)$`LogLik`[1],2),", df=5, ","AIC=",round(m1$aic,2)), notation = "none")

```

&nbsp;

Of Table 6, we can identify that the fact that date of last treatment is missing may be associated with slightly more duplicated cases in comparison to cases that have a date of last treatment. This means that possibly we can replace this date with another entry that has the same date of admission and HASH key. This can be useful to  close ranges within treatments, by defining a date of admission and a date of discharge.

&nbsp;

## 4. Age in datasets

<br>

Based on the meeting on Dec. 05 of 2019, one of the main challenges was to check wether age was linked to the last 4 numbers of each ID. As we can see in the Figure 1, there is a clear correlation with a few residuals. If year of birth is regressed on year, we find that the intercept is `r coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[1] %>%  formatC(, format="f", big.mark=",", digits=2)` and the slope is `r coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[2] %>%  formatC(, format="f", big.mark=",", digits=2)`. This can be represented as `r format(lubridate::date_decimal(coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[1]), "%Y-%m-%d")`, and by substracting the slope, this means that an approximate date of retrieval could be `r as.character(format(lubridate::date_decimal(coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[1]-coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[2]), "%Y-%m-%d"))`.

<br>

##### Figure 1. Scatterplot of Year of Birth and Age
```{r fig_fecha_nac_edad, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F}
#plot(CONS_C1_df_dup_ENE_2020_prev2$ano_nac, CONS_C1_df_dup_ENE_2020_prev2$Edad, ylab="Age", xlab="Year of Birth")
require(plotly)
plotly::plot_ly(CONS_C1_df_dup_ENE_2020_prev2,type="scatter", x = ~ano_nac, y = ~Edad, 
        text =  ~paste("Row: ", row, '<br>Year DB:', ano_bd),
        mode = "markers") %>% layout(xaxis=list(title="Year of Birth"), 
                                     yaxis=list(title="Age"))
```

<br>

We identified the outliers, ending up with 3 cases in which the expected age and year of birth presented a difference greater than 1 year. In Table 7 we can see the first 6 cases that had differences ordered by the magnitude of the difference. The rest of the `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::mutate(dif_edad=ano_nac-(2019-Edad)) %>% filter(dif_edad!=0) %>% nrow() %>% sum(-3) %>% formatC(, format="f", big.mark=",", digits=0)` had 12 months of difference.

<br>


```{r edad_fecha_nac, echo=T, paged.print=TRUE}
    CONS_C1_df_dup_ENE_2020_prev2 %>%
    dplyr::mutate(dif_edad=ano_nac-(2019-Edad)) %>%
      dplyr::filter(dif_edad!=0) %>%
      dplyr::arrange(desc(dif_edad)) %>%
      dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101) %>%
      dplyr::select(row, ano_bd, ano_nac, Edad, dif_edad,
                    HASH_KEY, hash_rut_completo, id_mod,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, 
                    ID.centro, everything()) %>%
      head() %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 7. Cases that have a different year of birth and age",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```


<br>

However, we may take account that there are `r paste0(round(CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18|Edad>90) %>% dplyr::summarise(n())/nrow(CONS_C1_df_dup_ENE_2020_prev2),3)*100,"%")` cases with inappropiate years, representing `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18) %>% dplyr::summarise(n()) %>% as.numeric() %>% formatC(, format="f", big.mark=",", digits=0)` cases with less than 18 years, and `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad>90) %>% dplyr::summarise(n()) %>% as.numeric() %>%  formatC(, format="f", big.mark=",", digits=0)` cases with more than 90 years. Most of the SENDAs IDs are constructed from the date of admission, as can be seen in Table 8:

<br>
```{r wrong ages, echo=T, paged.print=TRUE}
  CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18|Edad>90) %>%
    dplyr::select(row, HASH_KEY, id_mod, ano_nac, ano_bd,Edad,fech_ing) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 8. Cases that have a wrongly asigned age",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>

This may condition the data linkage, given that if I assign a missing value to a user that in other registry has the correct age, it won't be matched within the block assigned. In order to account for this possible bias, we checked whether cases may be replaced with data with another HASH Key.

<br>

```{r wrong ages duplicates, echo=T,cache=T, paged.print=TRUE}
#list of distinct HASHs that have a wrongly assigned age
CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18|Edad>90) %>%
  dplyr::distinct(HASH_KEY) %>%
  assign("distinct_hash_wrong_age2",., envir = .GlobalEnv)

#Then, apply these cases to the whole population
CONS_C1_df_dup_ENE_2020_prev2 %>%
dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(distinct_hash_wrong_age2)))))) %>% # select hashs of wrongly assigned ages
dplyr::arrange(HASH_KEY) %>% #order by hashs 
  dplyr::filter(Edad>=18,Edad<=90) %>% #nrow() #if you want to see how many cases would be changed: 387.
  #dplyr::filter(!duplicated(HASH_KEY)) %>% nrow() # 211 DIFFERENT HASHS WERE CAPTURED.
      dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101) %>%
      dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,Edad, fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, everything()) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 9. Total cases with wrong ages but their HASH had a valid age along the dataset",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

```{r transformation of ages in datasets, echo=F,cache=T, paged.print=TRUE}
#Capture every valid case distinct that has a valid age
CONS_C1_df_dup_age <- dplyr::select(CONS_C1_df, HASH_KEY, id, id_mod, Edad)%>% 
                      dplyr::filter(Edad>=18, Edad<=90) %>% #%>%  #dim rows 85490, 4 columns
                      dplyr::filter(!duplicated(HASH_KEY)) #lo mismo que  dplyr::distinct(HASH_KEY)
#Join datasets 
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev2,dplyr::select(CONS_C1_df_dup_age,HASH_KEY,Edad, id,id_mod), by = "HASH_KEY", suffix = c("", ".y")) %>% # dim()
    dplyr::mutate(id= ifelse((Edad<18 & !is.na(Edad.y))|(Edad>90 & !is.na(Edad.y)),id.y, id)) %>%
    dplyr::mutate(id_mod=ifelse((Edad<18 & !is.na(Edad.y))|(Edad>90 & !is.na(Edad.y)),id_mod.y,id_mod)) %>% 
    dplyr::mutate(Edad= ifelse(Edad<18|Edad>90,Edad.y, Edad)) %>% #treat as invalid
 dplyr::select(-id_mod.y, -id.y) %>%
    #dplyr::group_by(Edad) %>% summarise(n=n()) %>% View()
    assign("CONS_C1_df_dup_ENE_2020_prev3",., envir = .GlobalEnv) 
  #The modification of age must be in the end of the changes, so it does not affect the rest of variables
```

<br>

We found that the age is a time-invariant variable. In order to find similar matches, we need to identify the date of admission and the HASH Key, but also considering the year, leading to `r CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(Edad<18, Edad>90) %>% nrow()` invalid values in age (<18 or >90), but `r CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(is.na(Edad)) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` missing values with `r CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(is.na(Edad)) %>% distinct(HASH_KEY) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` different HASH keys. This may be found in Table 10, as cases found correspond mainly to people that does not present any valid age throughout different ages.

<br>

```{r invalid values in age, echo=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020_prev3 %>% 
  dplyr::filter(is.na(Edad)) %>% 
  arrange(HASH_KEY) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, SENDA) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 10. Missing Ages among Users with Wrong Dates of Birth",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>

Only 2 cases were replaced by cases in TOP dataset:

<br>

```{r invalid values in age replaced in TOP, echo=T, cache=T, paged.print=TRUE}
CONS_TOP_df_dup_age <- dplyr::select(CONS_TOP, HASH_KEY, ID, Sexo, Edad)%>% 
  dplyr::filter(Edad>=18, Edad<=90) %>% #%>%  #dim rowa 162449, 4 columns
  dplyr::mutate(id_mod=sub("(.{5}).", "\\1*",ID)) %>%
  dplyr::mutate(id_mod=sub("(.{6}).", "\\1*",id_mod)) %>%
  dplyr::mutate(id=ID) %>%
  dplyr::filter(!duplicated(HASH_KEY)) #dplyr::distinct(HASH_KEY) %>% nrow() #37124 rows, 5 columns
#merge datasets w CONS C1
CONS_C1_df_dup_ENE_2020_prev3  %>% 
  dplyr::filter(is.na(Edad)) %>% 
  arrange(HASH_KEY) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, SENDA) %>%
  dplyr::left_join(CONS_TOP_df_dup_age, by="HASH_KEY", suffix= c(".C1",".TOP")) %>%
  dplyr::filter(!is.na(id_mod.TOP)) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod.C1, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad.C1, Edad.TOP,SENDA, id_mod.TOP) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 11. Replaced Ages from TOP dataset",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 9) %>%
  kableExtra::scroll_box(width = "100%", height = "175px")
```

```{r previous assignment, echo=F,cache=T, paged.print=TRUE}
#Join datasets 
CONS_TOP_df_dup_age <- dplyr::select(CONS_TOP, HASH_KEY, ID, Sexo, Edad)%>% 
  dplyr::filter(Edad>=18, Edad<=90) %>% #%>%  #dim rowa 162449, 4 columns
  dplyr::mutate(id_mod=sub("(.{5}).", "\\1*",ID)) %>%
  dplyr::mutate(id_mod=sub("(.{6}).", "\\1*",id_mod)) %>%
  dplyr::mutate(id=ID) %>%
  dplyr::filter(!duplicated(HASH_KEY)) %>%
  dplyr::select(-ID)
#CONS_C1_df_dup_ENE_2020_prev3 %>% group_by(Edad) %>% summarise() %>% View() #son puros NA's

  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev3, CONS_TOP_df_dup_age, by="HASH_KEY", suffix= c("",".TOP")) %>%
    #dplyr::mutate(Edad_error=Edad) %>%
    dplyr::mutate(id= ifelse(is.na(Edad) & !is.na(id.TOP),id.TOP, id)) %>%
    dplyr::mutate(id_mod=ifelse(is.na(Edad) & !is.na(id_mod.TOP),id_mod.TOP,id_mod)) %>% 
    dplyr::mutate(Edad= ifelse(is.na(Edad) & !is.na(Edad.TOP),Edad.TOP, Edad)) %>%
    dplyr::mutate(fech_nac=lubridate::parse_date_time(stringi::stri_sub(id,-8,-1),"dmY")) %>% 
    #dplyr::mutate(Edad_fech_nac= lubridate::time_length(difftime(as.Date("2019-11-13"),as.Date(fech_nac)),"years")) %>%
    dplyr::mutate(fech_nac=replace(fech_nac, is.na(Edad), NA)) %>% #LA EDAD ESTA MALA PORQUE LA FECHA DE NAC ESTÁ MALA
    dplyr::mutate(ano_nac=replace(ano_nac, is.na(Edad), NA)) %>% #LA EDAD ESTA MALA PORQUE LA FECHA DE NAC ESTÁ MALA
    dplyr::select(-id_mod.TOP, -duplicated_HASH_date, -Edad.y, -Sexo.TOP, -Edad.TOP, -id.TOP) %>%  
    #dplyr::group_by(Edad) %>% summarise(n=n()) %>% View()
    as.data.frame() %>%
    assign("CONS_C1_df_dup_ENE_2020_prev4",., envir = .GlobalEnv) 
#PARA VER CÓMO SE COMPORTA CON IS.NA
  #CONS_C1_df_dup_ENE_2020_prev4 %>% dplyr::filter(is.na(Edad_error)) %>% dplyr::filter(!is.na(ID))
#CONS_C1_df_dup_ENE_2020 %>% dplyr::select(HASH_KEY, ano_bd, id, fech_ing, Edad_al_ing, fech_nac, Edad) %>%
  #dplyr::mutate(ano=as.numeric(fech_nac)/365.25) %>% dplyr::filter(is.na(Edad)) %>% View()
#CONS_C1_df_dup_ENE_2020_prev4 %>%
  #dplyr::filter(HASH_KEY=="17427b747a8e5d8ecdcdec6a781a277b"|HASH_KEY=="636046ed13f419997e2c05bfd3ac6ae6") %>%
  #print()
  #rows 57716 9972 6736, están perdidos en las bases de datos.
```
<br>
    
Still, in order to represent sufficiently, we must pay attention to HASH keys that have more than one age. Among them, there are `r CONS_C1_df_dup_ENE_2020_prev4 %>% dplyr::group_by(HASH_KEY,Edad) %>% dplyr::count() %>% dplyr::filter(n>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` different HASHs with more thn one age. Possibly, some datasets were retrieved in different dates than others from SENDA system. Considering that the age is calculated dynamically given the date of retrieval, this may added some variability among users. However, some of the differences in ages within HASHs could be caused by mistyping in the registry or others not related to the process of retrieval.

<br>
```{r , echo=T, cache=T, paged.print=TRUE}
 #mÁS DE UNA EDAD POR HASH
CONS_C1_df_dup_ENE_2020_prev4 %>% dplyr::mutate(concat_hash_edad=paste0(HASH_KEY,"_",Edad)) %>% 
  dplyr::distinct(concat_hash_edad, .keep_all = TRUE) %>% 
 #once here, n° of cases has been replaced by distinct or unique combinations of age and HASH keys.
 dplyr::filter(duplicated(HASH_KEY)) %>% dplyr::arrange(HASH_KEY) %>%  #filter cases in which there is more than one age, 
 #despite there is differents combinations of HASH and age, and then arrange age. This is possible only if a different HASH-Key contains more than one age or viceversa.
 #take distincts ages (exclude duplicated repeated IDs)
 #  dplyr::distinct(HASH_KEY) %>% nrow()
  dplyr::select(HASH_KEY) %>%
 assign("more_one_age_per_hash",., envir = .GlobalEnv)
# Differently put, take the distints HASHs per HASH-Key & ages, of the cases in which there are different combinations
# of ages and HASHs, and in each subgroup exists duplicated HASHs.

CONS_C1_df_dup_ENE_2020_prev4 %>% 
 dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(more_one_age_per_hash)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(HASH_KEY) %>% #ordeno por ids 
dplyr::select(row, ano_bd, id_mod, fech_nac, Edad, HASH_KEY, hash_rut_completo, sexo, fech_ing, fech_egres, tipo_de_plan, SENDA)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 12. HASHs with more than one Age",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")

#debo reemplazar a fech_nac, id, id_mod, Edad_al_ing, 
  
#    dplyr::select(Edad,HASH_KEY) %>% 
#  dplyr::group_by(HASH_KEY,Edad) %>% tally() %>%  dplyr::mutate(n_col=n) %>%  dplyr::filter(n>1) %>%   as.data.frame() %>%  #reshape::cast(.,Edad+HASH_KEY~n) %>% dplyr::arrange(Edad, HASH_KEY)
```

<br>

Must take note that many variables that may change among individuals can be duplicted per HASH. These are the individual variables that may change share more than one HASH.


- Age of Onset of Drug Use (edad_ini_cons)
- Age of Onset of Drug Use Principal Substance (edad_ini_sus_prin)
- Year of Birth (ano_nac) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(ano_nac_por_hash=n_distinct(ano_nac)) %>% ungroup() %>% dplyr::filter(ano_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Date of Birth (fech_nac) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(fech_nac_por_hash=n_distinct(fech_nac)) %>% ungroup() %>% dplyr::filter(fech_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Starting Substance (sus_ini)
- Sex (sexo) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(sexo_por_hash=n_distinct(sexo)) %>% ungroup() %>% dplyr::filter(sexo_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Age (Edad) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(Edad_por_hash=n_distinct(Edad)) %>% ungroup() %>% dplyr::filter(Edad_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Ethnicity (Etnia) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(Etnia_por_hash=n_distinct(Etnia)) %>% ungroup() %>% dplyr::filter(Etnia_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Nationallity (Nacionalidad) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(Nacionalidad_por_hash=n_distinct(Nacionalidad)) %>% ungroup() %>% dplyr::filter(Nacionalidad_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- SENDAs ID (id) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_por_hash=n_distinct(id)) %>% ungroup() %>% dplyr::filter(id_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Masked SENDAs ID (id_mod) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_mod_por_hash=n_distinct(id_mod)) %>% ungroup() %>% dplyr::filter(id_mod_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)

<!--- CONS_C1_df_dup_ENE_2020_prev4 %>%
    dplyr::group_by(HASH_KEY) %>% mutate(mas_id=n_distinct(id)) %>% dplyr::filter(mas_id>1)
--> 

In this stage we will change the Age, SENDAs ID, year of birth, and date of birth, excluiding any other variables not related to age. The main reason is that these variables come from an specific date of birth, that in this case is duplicated. **The rest of the variables may be subject of an analysis that should take into account other logical inconsistencies that may be resolved once data is deduplicated**.

In the first place, we replaced only cases which had more than one age per HASH. Then we checked whether each HASH Key had more than one ID. If there were more than one, we selected the most frequent value. If there were only two cases with different IDs, we selected data which comes from the most recent dataset (assuming that each of these entries had more control over each case), followed by the case with the greater age.  Finally, if there was only one ID by HASH, we selected cases in which there is only one ID.

<br>

```{r final_assignment, echo=F,cache=T, paged.print=TRUE}
#Join datasets 
require(lubridate)

#en esta base estará la edad máxima
CONS_C1_df_dup_ENE_2020_prev4 %>%
    #dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(more_one_age_per_hash)))))) %>% # Select HASHs of cited cases, reduzco la probabilidad de sumar casos que dupliquen las observaciones de mi base de datos.
    dplyr::select(HASH_KEY,id, id_mod,Edad, fech_nac, ano_nac) %>% #seleccionar todo lo que debo cambiar
    dplyr::group_by(HASH_KEY) %>% #primero genero la variable
    dplyr::slice(which.max(Edad))%>%
    assign("CONS_C1_df_dup_ENE_2020_prev4_max_age",., envir = .GlobalEnv) 
  #dplyr::filter(HASH_KEY=="00012586ea3036b7a18093c396847a87") #si se quiere ver un ejemplo

#en esta base será la edad más cercana a la que sería corregida teniendo como referencia la fecha de obtención de la BD.
CONS_C1_df_dup_ENE_2020_prev4 %>%
    dplyr::mutate(Edad_corr= lubridate::time_length(difftime(as.Date("2019-11-13"),as.Date(fech_nac)),"years")) %>%
    #dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(more_one_age_per_hash)))))) %>% 
    dplyr::mutate(Edad_diff=abs(Edad-Edad_corr)) %>%
    dplyr::select(HASH_KEY, id, id_mod,ano_bd, Edad, Edad_corr, fech_nac,Edad_diff, ano_nac) %>%
    dplyr::group_by(HASH_KEY) %>% #primero genero la variable
    dplyr::slice(which.min(Edad_diff))%>%
    #dplyr::filter(!duplicated(HASH_KEY)) %>% #para evitar duplicados en los casos en que se repiten
    #dplyr::filter(HASH_KEY=="00012586ea3036b7a18093c396847a87") #si se quiere ver un ejemplo
    assign("CONS_C1_df_dup_ENE_2020_prev4_min_diff",., envir = .GlobalEnv) 
  #dplyr::filter(HASH_KEY=="00012586ea3036b7a18093c396847a87") #si se quiere ver un ejemplo

#en esta será la base de datos más reciente
CONS_C1_df_dup_ENE_2020_prev4 %>%
    #dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(more_one_age_per_hash)))))) %>% 
    dplyr::select(HASH_KEY,id, id_mod, ano_bd, Edad, fech_nac, ano_nac) %>%
    dplyr::group_by(HASH_KEY) %>% #primero genero la variable
    dplyr::slice(which.max(ano_bd))%>%
    assign("CONS_C1_df_dup_ENE_2020_prev4_max_year_dataset",., envir = .GlobalEnv) 
    #dplyr::filter(HASH_KEY=="00012586ea3036b7a18093c396847a87")

CONS_C1_df_dup_ENE_2020_prev4 %>%
    #dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(more_one_age_per_hash)))))) %>% 
    dplyr::mutate(concat_hash_year=paste0(HASH_KEY,"_",Edad)) %>%
    dplyr::group_by(concat_hash_year) %>%
    dplyr::add_tally() %>% 
    dplyr::ungroup() %>%  
    dplyr::select(HASH_KEY,id, id_mod, ano_bd, Edad, fech_nac,ano_nac,n) %>%
    dplyr::group_by(HASH_KEY) %>% #primero genero la variable
    dplyr::slice(which.max(n))%>% 
    #dplyr::filter(HASH_KEY=="00a8e1377935f1639a28faa9c11ee03a")
    assign("CONS_C1_df_dup_ENE_2020_prev4_most_frequent_age_dataset",., envir = .GlobalEnv) 

#CONS_C1_df_dup_ENE_2020_prev4_max_age
#CONS_C1_df_dup_ENE_2020_prev4_min_diff
#CONS_C1_df_dup_ENE_2020_prev4_max_year_dataset
#CONS_C1_df_dup_ENE_2020_prev4_most_frequent_age_dataset

CONS_C1_df_dup_ENE_2020_prev4 %>%
  dplyr::group_by(HASH_KEY) %>% #primero genero la variable
  dplyr::mutate(edades_por_hash=n_distinct(Edad),ids_por_hash=n_distinct(id),bds_por_hash=n_distinct(ano_bd), HASH_reps = n()) %>%  #number of different variables by HASH.
  dplyr::ungroup() %>% #desagrupo
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev4_max_age, by="HASH_KEY", suffix= c("",".C1_max_age")) %>%
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev4_min_diff, by="HASH_KEY", suffix= c("",".C1_min_diff")) %>%
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev4_max_year_dataset, by="HASH_KEY", suffix= c("",".C1_max_year")) %>%
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev4_most_frequent_age_dataset, by="HASH_KEY", suffix= c("",".C1_mf_age")) %>%
  #nrow()  #para ver si se han agregado más filas.
  #si hay más de 1 ID y hay más de 2 casos por HASH
  dplyr::mutate(id= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps>2 & !is.na(id.C1_mf_age)),id.C1_mf_age, id)) %>%
  dplyr::mutate(id_mod= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps>2 & !is.na(id_mod.C1_mf_age)),id_mod.C1_mf_age, id_mod)) %>%
  dplyr::mutate(fech_nac= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps>2 & !is.na(fech_nac.C1_mf_age)),fech_nac.C1_mf_age, fech_nac)) %>%
  dplyr::mutate(ano_nac= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps>2 & !is.na(ano_nac.C1_mf_age)),ano_nac.C1_mf_age, ano_nac)) %>%
  dplyr::mutate(Edad= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps>2 & !is.na(Edad.C1_mf_age)),Edad.C1_mf_age, Edad)) %>% #edad al final
  #si hay más de 1 ID y sólo hay 2 casos
  dplyr::mutate(id= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps==2 & !is.na(id.C1_max_year)),id.C1_max_year, id)) %>%
  dplyr::mutate(id_mod= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps==2 & !is.na(id_mod.C1_max_year)),id_mod.C1_max_year, id_mod)) %>%
  dplyr::mutate(fech_nac= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps==2 & !is.na(fech_nac.C1_max_year)),fech_nac.C1_max_year, fech_nac)) %>%
  dplyr::mutate(ano_nac= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps==2 & !is.na(ano_nac.C1_max_year)),ano_nac.C1_max_year, ano_nac)) %>%
  dplyr::mutate(Edad= ifelse((edades_por_hash>1 & ids_por_hash>1 & HASH_reps==2 & !is.na(Edad.C1_max_year)),Edad.C1_max_year, Edad)) %>% #edad al final
  #si sólo hay 1 ID, SIN IMPORTAR LA CANTIDAD DE REPS
  dplyr::mutate(id= ifelse((edades_por_hash>1 & ids_por_hash==1 & !is.na(id.C1_min_diff)),id.C1_min_diff, id)) %>%
  dplyr::mutate(id_mod= ifelse((edades_por_hash>1 & ids_por_hash==1 & !is.na(id_mod.C1_min_diff)),id_mod.C1_min_diff, id_mod)) %>%
  dplyr::mutate(fech_nac= ifelse((edades_por_hash>1 & ids_por_hash==1 & !is.na(fech_nac.C1_min_diff)),fech_nac.C1_min_diff, fech_nac)) %>% 
  dplyr::mutate(ano_nac= ifelse((edades_por_hash>1 & ids_por_hash==1 & !is.na(ano_nac.C1_min_diff)),ano_nac.C1_min_diff, ano_nac)) %>% 
  dplyr::mutate(Edad= ifelse((edades_por_hash>1 & ids_por_hash==1 & !is.na(Edad.C1_min_diff)),Edad.C1_min_diff, Edad)) %>%
  dplyr::mutate(fech_nac= as.POSIXct(fech_nac, origin="1970-01-02")) %>%
  dplyr::mutate(fech_nac= stringi::stri_sub(as.character.Date(fech_nac),1,10)) %>%
  dplyr::mutate(fech_nac= lubridate::parse_date_time(fech_nac,"Ymd")) %>%
    #CONS_C1_df_dup_ENE_2020_prev4 %>%
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  dplyr::select(-edades_por_hash, #borrar columnas
               -ids_por_hash,
               -bds_por_hash,
               -HASH_reps,
               -id.C1_max_age,
               -id_mod.C1_max_age,
               -Edad.C1_max_age,
               -fech_nac.C1_max_age,
               -ano_nac.C1_max_age,
               -id.C1_min_diff,
               -id_mod.C1_min_diff,
               -ano_bd.C1_min_diff,
               -Edad.C1_min_diff,
               -Edad_corr,
               -fech_nac.C1_min_diff,
               -Edad_diff,
               -ano_nac.C1_min_diff,
               -id.C1_max_year,
               -id_mod.C1_max_year,
               -ano_bd.C1_max_year,
               -Edad.C1_max_year,
               -fech_nac.C1_max_year,
               -ano_nac.C1_max_year,
               -id.C1_mf_age,
               -id_mod.C1_mf_age,
               -ano_bd.C1_mf_age,
               -Edad.C1_mf_age,
               -fech_nac.C1_mf_age,
               -ano_nac.C1_mf_age,
               -n) %>% #Edad_al_ing
#probar   
#  dplyr::filter(HASH_KEY=="17427b747a8e5d8ecdcdec6a781a277b") %>%
#  dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(more_one_age_per_hash)))))) %>% # Select HASHs of
#  dplyr::select(row, ano_bd, id_mod, id, fech_nac, Edad, HASH_KEY, hash_rut_completo, Sexo, fech_ing, fech_egres, tipo_de_plan, SENDA,Edad_al_ing)%>%
#  dplyr::arrange(HASH_KEY,Edad) %>%
#  View()

#CONS_TOP_df_dup_ENE_2020_prev9 %>% group_by(row) %>% count() %>% dplyr::filter(n>1) #para ver si dejé casos duplicados

#dplyr::select(-edades_por_hash, ids_por_hash, bds_por_hash) %>% #UNA VEZ APLIQUE EL ASSIGN
as.data.frame() %>%
assign("CONS_C1_df_dup_ENE_2020_prev5",., envir = .GlobalEnv) 
#PARA VER CÓMO SE COMPORTA CON IS.NA
#CONS_C1_df_dup_ENE_2020 %>% dplyr::select(HASH_KEY, ano_bd, id, fech_ing, Edad_al_ing, fech_nac, Edad) %>% 
#
#PARA VER CÓMO VA FUNCIONANDO
#CONS_C1_df_dup_ENE_2020_prev5 %>% group_by(HASH_KEY) %>% dplyr::mutate(Edad_por_hash=n_distinct(Edad)) %>% ungroup() %>% #dplyr::filter(Edad_por_hash>1) %>% nrow()dplyr::arrange(HASH_KEY, Edad) %>%
#dplyr::select(row, ano_bd, id_mod, fech_nac, Edad, HASH_KEY, hash_rut_completo, sexo, fech_ing, fech_egres, tipo_de_plan, SENDA)%>%
#View()
```

By doing this, we lowered as much as possible the quantity of distinct information by HASH that may be contradictory. However, many of these inconsistencies can be resolved with SENDAs professionals. 

- Age (Edad) (`r CONS_C1_df_dup_ENE_2020_prev5 %>% group_by(HASH_KEY) %>% dplyr::mutate(Edad_por_hash=n_distinct(Edad)) %>% ungroup() %>% dplyr::filter(Edad_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- SENDAs ID (id) (`r CONS_C1_df_dup_ENE_2020_prev5 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_por_hash=n_distinct(id)) %>% ungroup() %>% dplyr::filter(id_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Masked SENDAs ID (id_mod) (`r CONS_C1_df_dup_ENE_2020_prev5 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_mod_por_hash=n_distinct(id_mod)) %>% ungroup() %>% dplyr::filter(id_mod_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Year of Birth (ano_nac) (`r CONS_C1_df_dup_ENE_2020_prev5 %>% group_by(HASH_KEY) %>% dplyr::mutate(ano_nac_por_hash=n_distinct(ano_nac)) %>% ungroup() %>% dplyr::filter(ano_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Date of Birth (fech_nac) (`r CONS_C1_df_dup_ENE_2020_prev5 %>% group_by(HASH_KEY) %>% dplyr::mutate(fech_nac_por_hash=n_distinct(fech_nac)) %>% ungroup() %>% dplyr::filter(fech_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)


```{r final_assignment_change_factors_recode, echo=F,cache=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020_prev5 %>%
  dplyr::filter(is.na(Tipo.de.Plan) | Tipo.de.Plan != "PAI LV") %>% #Deletion of cases in Parole. OJO, TAMBIÉN ELIMINO A NA'S, BAJO A 188086 CASOS. Rows= 57716, 9972 Y 6736.
# Ver si se pueden reemlpazar. La verdad es que no hay otro ingreso.
#CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(concat %in% c("ebc40285ab6f4db453d9830453ec578a_2014_5_19", #"72c54d822de128e52f10511f3eb2d19f_2009_12_14", "03390de37aa8a95707905d07c33c0a97_2010_7_30"))
#LV se elimina el tipo de plan
  dplyr::mutate(tipo_de_plan=dplyr::recode(Tipo.de.Plan,"M-PAI2"= "M-PAI", "M-PR2"="M-PR","PG PAI 2"="PG-PAI", "Otro"="PG-PR", "CALLE"="PG-PR"))%>%
#Table 10. Type of Plan by Gender Identity and Sex
#En SER 2020, dejé los Calle y Otro en PG-PAB, pero ahora lo dejaré en PG-PR
  dplyr::mutate(tipo_de_plan=ifelse(identidad.de.genero=="Masculino" & sexo=="Hombre" & tipo_de_plan=="M-PAI","PG-PAI", as.character(tipo_de_plan))) %>%
  dplyr::mutate(tipo_de_plan=ifelse(identidad.de.genero=="Masculino" & sexo=="Hombre" & tipo_de_plan=="M-PR","PG-PR", as.character(tipo_de_plan))) %>%
  dplyr::mutate(tipo_de_plan=ifelse(identidad.de.genero=="Masculino" & sexo=="Hombre" & tipo_de_plan=="M-PAB","PG-PAB", as.character(tipo_de_plan))) %>%
  dplyr::mutate(tipo_de_plan=as.factor(tipo_de_plan)) %>%
#Si la edad de inicio de consumo es mayor a la edad actual, lo mismo la edad de iniciación a la sustancia principal, las declaro perdidas.
  dplyr::mutate(edad_ini_cons= ifelse(Edad.Inicio.Consumo<=Edad, Edad.Inicio.Consumo, NA)) %>%
  dplyr::mutate(edad_ini_sus_prin= ifelse(Edad.Inicio..Sustancia.Principal.<=Edad, Edad.Inicio..Sustancia.Principal., NA)) %>%
  #CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(Edad.Inicio.Consumo>20) %>% dplyr::mutate(edad_ini_cons= ifelse(Edad.Inicio.Consumo<=Edad, Edad.Inicio.Consumo, NA)) %>% dplyr::select(Edad, Edad.Inicio.Consumo, edad_ini_cons)
#Si se inicia en la sustancia principal o inicia el consum a una edad menor a 5 años, lo declaro como perdido.
  dplyr::mutate(edad_ini_cons= ifelse(edad_ini_cons<5,NA,edad_ini_cons)) %>%
  dplyr::mutate(edad_ini_sus_prin= ifelse(edad_ini_sus_prin<5,NA,edad_ini_sus_prin)) %>%
  #CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(embarazo=="Si") %>% group_by(sexo) %>% summarise(n())
#Embarazos en hombres se declaran como perdidos
  dplyr::mutate(embarazo= ifelse(embarazo=="Si" & sexo=="Hombre",NA,as.character(embarazo))) %>%
  #dplyr::mutate(embarazo= dplyr::recode("1"="No","2"="Si")) %>%
  dplyr::mutate(embarazo=as.factor(embarazo)) %>%
#     mutate(mpg=replace(mpg, cyl==4, NA)) %>%
#CAMBIOS DIAS
  dplyr::mutate(dias_trat=replace(dias_trat,dias_trat<0, NA)) %>%
    assign("CONS_C1_df_dup_ENE_2020_prev6",., envir = .GlobalEnv) 

  #CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::mutate(dias_trat_alta_temprana=ifelse(dias_trat>90,0,1)) %>% dplyr::group_by(dias_trat_alta_temprana,motivodeegreso) %>% summarise(n())
  CONS_C1_df_dup_ENE_2020_prev6 %>% dplyr::mutate(dias_trat_alta_temprana=ifelse(dias_trat>=90,0,1)) %>%
  dplyr::mutate(dias_trat_alta_temprana=as.factor(dias_trat_alta_temprana)) %>%
  dplyr::mutate(dias_trat_alta_temprana= dplyr::recode(dias_trat_alta_temprana, "1"="Menos de 90 días", "0"="Mayor o igual a 90 días")) %>%
  dplyr::mutate(motivodeegreso_mod= ifelse(dias_trat_alta_temprana=="Menos de 90 días" & motivodeegreso=="Abandono", "Abandono Temprano",as.character(motivodeegreso))) %>% 
  dplyr::mutate(motivodeegreso_mod= ifelse(dias_trat_alta_temprana=="Mayor o igual a 90 días" & motivodeegreso=="Abandono", "Abandono Tardio",as.character(motivodeegreso_mod))) %>% 
  dplyr::mutate(motivodeegreso_mod=as.factor(motivodeegreso_mod)) %>%
  #data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Sustancia.Principal))
  dplyr::mutate(sus_principal= as.character(Sustancia.Principal)) %>%
  dplyr::mutate(sus_principal= dplyr::recode(sus_principal,
                                             "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                             "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                             "Anfetaminas"="Estimulante tipo anfetaminas",
                                             "Extasis"="Estimulante tipo anfetaminas",
                                             "Fenilciclidina"="Estimulante tipo anfetaminas",
                                             "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                             "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                             "LSD"="Alucinógenos",
                                             "Otros Alucinógenos"="Alucinógenos",
                                             "Crack"="Pasta Base",
                                             "Heroína"="Opioides",
                                             "Metadona"="Opioides",
                                             "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                             "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                             "Esteroides Anabólicos"="Otros")) %>%
dplyr::mutate(sus_principal=as.factor(sus_principal)) %>%
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Otras.Sustancias.nº1))
  dplyr::mutate(otras_sus1=as.character(Otras.Sustancias.nº1)) %>%
  dplyr::mutate(otras_sus1= dplyr::recode(otras_sus1,
                                              "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucinógenos"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Heroína"="Opioides",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>%
dplyr::mutate(otras_sus1= dplyr::na_if(otras_sus1, "SIN CONSUMO")) %>%
dplyr::mutate(otras_sus1=as.factor(otras_sus1)) %>%        
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Otras.Sustancias.nº2))
  dplyr::mutate(otras_sus2=as.character(Otras.Sustancias.nº2)) %>%
  dplyr::mutate(otras_sus2= dplyr::recode(otras_sus2,
                                              "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucinógenos"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Heroína"="Opioides",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>%
dplyr::mutate(otras_sus2= dplyr::na_if(otras_sus2, "SIN CONSUMO")) %>%
dplyr::mutate(otras_sus2=as.factor(otras_sus2)) %>%    
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Otras.Sustancias.nº3))
  dplyr::mutate(otras_sus3=as.character(Otras.Sustancias.nº3)) %>%
  dplyr::mutate(otras_sus3= dplyr::recode(otras_sus3,
                                              "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucinógenos"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Heroína"="Opioides",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>%
dplyr::mutate(otras_sus3= dplyr::na_if(otras_sus3, "SIN CONSUMO")) %>%
dplyr::mutate(otras_sus3=as.factor(otras_sus3)) %>%    
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Sustancia.de.Inicio))
dplyr::mutate(sus_ini=as.character(Sustancia.de.Inicio)) %>%
dplyr::mutate(sus_ini= dplyr::recode(sus_ini,
                                              "Hipn?os "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbit?os, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucin?os"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Hero?"="Opioides",
                                              "Coca?"="Cocaína",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analg?cos: morfina, code?, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, ?o nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>% 
dplyr::mutate(sus_ini=as.factor(sus_ini)) %>%    
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Estado.Conyugal))
#marital status (single, married/with partner, separated/divorced, widow)
dplyr::mutate(estado_conyugal=ifelse(as.character(Estado.Conyugal)=="Casado"|as.character(Estado.Conyugal)=="Conviviente"|as.character(Estado.Conyugal)=="conviviente civil", "Casado/Conviviente",stringr::str_trim(as.character(Estado.Conyugal)))) %>%
dplyr::mutate(estado_conyugal=ifelse(estado_conyugal=="Separado"|estado_conyugal=="Divorciado"|estado_conyugal=="Anulado", "Separado/Divorciado",estado_conyugal)) %>% 
dplyr::mutate(estado_conyugal=ifelse(estado_conyugal=="Nocontesta",NA,estado_conyugal)) %>%
dplyr::mutate(estado_conyugal=as.factor(estado_conyugal)) %>%
#occupational status (inactive, unemployed, employed)  
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Condicion.Ocupacional))
#
#Esta variable busca establecer si la persona desarrolló alguna actividad laboral o productiva, es decir, si participó en la producción de un bien o servicio para la venta o para el autoconsumo, por un mínimo de una hora semanal en la semana anterior (lunes a domingo) a la entrevista. Los quehaceres del hogar no son considerados una actividad productiva o ‘razón de ocupación’.
#Si la respuesta es afirmativa se debe seleccionar la opción “Trabajando actualmente” Si la persona No Trabajó, interesa saber si está Desocupada (“busca trabajo por primera vez” o “cesante”) o Inactiva (que corresponde al resto de la opciones, quehaceres del hogar, estudiando, jubilado, etc.) 
#
#Inactivo, desempleado, empleado
#     Buscando trabajo por primera vez |        245        0.21        0.21
#                              Cesante |     43,299       36.67       36.87
#              Estudiando sin trabajar |      1,353        1.15       38.02
#Incapacitado permanente para trabajar |        294        0.25       38.27
#                                   NA |          1        0.00       38.27
#                     No busca Trabajo |      1,250        1.06       39.33
#                           Otra razón |      1,348        1.14       40.47
#   Pensionado o jubilado sin trabajar |      1,872        1.59       42.05
#                 Quehaceres del hogar |      7,683        6.51       48.56
#                             Rentista |         78        0.07       48.63
#                        Sin actividad |      7,449        6.31       54.93
#               Trabajando actualmente |     53,120       44.98       99.92
#              Trabajando y estudiando |         97        0.08      100.00
dplyr::mutate(estatus_ocupacional=ifelse(Condicion.Ocupacional=="Trabajando actualmente","Empleado",
                                         ifelse(Condicion.Ocupacional=="Buscando trabajo por primera vez"|Condicion.Ocupacional=="Cesante",
                                                "Desempleado","Inactivo"))) %>%
dplyr::mutate(estatus_ocupacional=as.factor(estatus_ocupacional)) %>%
#Comprende la relación entre una persona económicamente activa y su trabajo o empleo. Sólo se aplica aquellas personas que se encuentran trabajando al momento de ingresar a tratamiento (las que respondieron 1 en la pregunta anterior). Para las personas que no están trabajando (estudiantes, cesante, etc.) esta opción estará bloqueada.
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Categoría.Ocupacional))
dplyr::mutate(cat_ocupacional=ifelse(Condicion.Ocupacional!="Trabajando actualmente",NA,as.character(Categoría.Ocupacional))) %>%
dplyr::mutate(cat_ocupacional=as.factor(cat_ocupacional)) %>%
#18-24, 25- 29, 30-35, 36-45, and 45+.
dplyr::mutate(Edad_grupos=ifelse(Edad>45,">45",
      ifelse(Edad>=36,"36-45",
      ifelse(Edad>=30,"30-35",
      ifelse(Edad>=25,"25-29",
      ifelse(Edad>=18,"18-24",
      NA)))))) %>%
dplyr::mutate(Edad_grupos=as.factor(Edad_grupos)) %>%
# motive of admission to treatment (spontaneous consultation, referral from a health center, indicated in the judicial system, other)
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Origen.de.Ingreso))
dplyr::mutate(origen_ingreso=ifelse(as.character(Origen.de.Ingreso)=="Consulta Espontánea", "Consulta Espontánea",as.character(Origen.de.Ingreso))) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Establecimiento Educacional"|origen_ingreso=="Otros"|origen_ingreso=="Trabajo (empresa o empleador)"|origen_ingreso=="Servicios Sociales u otros (iglesia, Mideplan, ser. comunitarios, etc.)", "Otros",origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Juzgado con Competencia en Crimen"|origen_ingreso=="Juzgado de Garantía"|origen_ingreso=="Libertad Vigilada"|origen_ingreso=="Juzgado de Familia"|origen_ingreso=="Juzgado de Policía"|origen_ingreso=="Otros (fiscalía)","Sector Justicia",origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Otros de la Red de Salud General Privado"|origen_ingreso=="Estab. de APS"|origen_ingreso=="Estab. de APS "|origen_ingreso=="Otros de la Red de Salud General Público", "Sector Salud", origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Otro Centro Tratamiento Drogas"|origen_ingreso=="FONODROGAS"|origen_ingreso=="Previene","Otro Centro Tratamiento Drogas/FONODROGAS/Previene",origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=as.factor(origen_ingreso)) %>%
# education attainment (completed primary school or less, completed or incomplete high school, more that high school)
# data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Escolaridad..último.año.cursado.))
dplyr::mutate(escolaridad=ifelse(as.character(Escolaridad..último.año.cursado.)=="BASICA COMPLETA"|as.character(Escolaridad..último.año.cursado.)=="BASICA INCOMPLETA"|as.character(Escolaridad..último.año.cursado.)=="SIN ESTUDIOS","Ed Primaria Completa o Menor",as.character(Escolaridad..último.año.cursado.))) %>%
dplyr::mutate(escolaridad=ifelse(escolaridad=="MEDIA COMPLETA"|escolaridad=="MEDIA INCOMPLETA","Ed Secundaria Completa o Menor",
      ifelse(escolaridad=="NO SABE O NO SE APLICA",NA,
      ifelse(escolaridad %in% c("TECNICA COMPLETA", "TECNICA INCOMPLETA", "UNIVERSITARIA COMPLETA O MAS", "UNIVERSITARIA INCOMPLETA"), "Mayor a Ed Secundaria",escolaridad)))) %>%
dplyr::mutate(escolaridad=as.factor(escolaridad)) %>%
# pattern of drug used (daily, 4 to 6 days a week, 2 to 3 days a week, 1 day a week or less),
    #data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Vía.Administración..Sustancia.Principal.))
dplyr::mutate(via_adm_sus_ini=as.character(Vía.Administración..Sustancia.Principal.))%>%
dplyr::mutate(via_adm_sus_ini=ifelse(via_adm_sus_ini== "No sabe",NA,as.character(via_adm_sus_ini))) %>%
dplyr::mutate(via_adm_sus_ini=as.factor(via_adm_sus_ini)) %>%
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Frecuencia.de.Consumo..Sustancia.Principal.))
dplyr::mutate(freq_cons_sus_ini=as.character(Frecuencia.de.Consumo..Sustancia.Principal.))%>%
dplyr::mutate(freq_cons_sus_ini=ifelse(freq_cons_sus_ini== "Desconocida",NA,as.character(freq_cons_sus_ini))) %>%
dplyr::mutate(freq_cons_sus_ini=as.factor(freq_cons_sus_ini)) %>%
as.data.frame(.) %>%  
assign("CONS_C1_df_dup_ENE_2020",., envir = .GlobalEnv)
  
codebook::val_labels(CONS_C1_df_dup_ENE_2020$Diagnóstico.Trs..Psiquiátrico.CIE.10) <- c('En estudio(NA)' = 1,
'Esquizofrenia, trastorno esquizotípico y trastornos de ideas delirantes(F20-29)' = 2,
'Retraso Mental(F70-79)' = 3,
'Sin trastorno(NA)' = 4,
'Trastornos de la conducta alimentaria(F50)' = 5,
'Trastornos de la personalidad y del comportamiento del adulto(F60-69)' = 6,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 7,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos(F50-59)' = 8,
'Trastornos del Desarrollo Psicológico(F80-89)' = 9,
'Trastornos del humor (afectivos).(F30-39)' = 10,
'Trastornos mentales orgánicos, incluidos los sintomáticos(F00-09)' = 11,
'Trastornos neuróticos, secundarios a situaciones estresantes y somatomorfos(F40-49)' = 12,
'Trs. del comportamiento y de las emociones de comienzo habitual en la infancia y adolescencia(F90-98)' = 13)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$X2.Diagnóstico.Trs..Psiquiátrico.CIE.10) <- c('En estudio(NA)' = 1,
'Esquizofrenia, trastorno esquizotípico y trastornos de ideas delirantes(F20-29)' = 2,
'Retraso Mental(F70-79)' = 3,
'Sin trastorno(NA)' = 4,
'Trastornos de la conducta alimentaria(F50)' = 5,
'Trastornos de la personalidad y del comportamiento del adulto(F60-69)' = 6,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 7,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos(F50-59)' = 8,
'Trastornos del Desarrollo Psicológico(F80-89)' = 9,
'Trastornos del humor (afectivos).(F30-39)' = 10,
'Trastornos mentales orgánicos, incluidos los sintomáticos(F00-09)' = 11,
'Trastornos neuróticos, secundarios a situaciones estresantes y somatomorfos(F40-49)' = 12,
'Trs. del comportamiento y de las emociones de comienzo habitual en la infancia y adolescencia(F90-98)' = 13)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$X3.Diagnóstico.Trs..Psiquiátrico.CIE.10) <- c('En estudio(NA)' = 1,
'Esquizofrenia, trastorno esquizotípico y trastornos de ideas delirantes(F20-29)' = 2,
'Retraso Mental(F70-79)' = 3,
'Sin trastorno(NA)' = 4,
'Trastornos de la conducta alimentaria(F50)' = 5,
'Trastornos de la personalidad y del comportamiento del adulto(F60-69)' = 6,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 7,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos(F50-59)' = 8,
'Trastornos del Desarrollo Psicológico(F80-89)' = 9,
'Trastornos del humor (afectivos).(F30-39)' = 10,
'Trastornos mentales orgánicos, incluidos los sintomáticos(F00-09)' = 11,
'Trastornos neuróticos, secundarios a situaciones estresantes y somatomorfos(F40-49)' = 12,
'Trs. del comportamiento y de las emociones de comienzo habitual en la infancia y adolescencia(F90-98)' = 13)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10) <- c('Abuso de sustancias que no producen dependencia(F55X)' = 1,
'Delirium no inducido por alcohol u otras sustancias psicotropas(F059)' = 2,
'Demencia en enfermedades clasificadas en otro lugar(F02)' = 3,
'Demencia sin especificación(F03)' = 4,
'Demencia vascular(F01)' = 5,
'Episodios depresivos(F32)' = 6,
'Factores psicológicos y del comportamiento en trastornos o enfermedades clasificados en otro lugar(F54)' = 7,
'Otros trastornos de ansiedad(F41)' = 8,
'Otros trastornos de la personalidad y del comportamiento del adulto(F68)' = 9,
'Otros trastornos de las emociones y del comportamiento de comienzo habitual en la infancia y adolescencia(F98)' = 10,
'Otros trastornos del desarrollo psicológico(F88)' = 11,
'Otros trastornos del humor (afectivos)(F38)' = 12,
'Otros trastornos mentales debidos a lesión o disfunción cerebral o a enfermedad somática(F06)' = 13,
'Otros trastornos neuróticos(F48)' = 14,
'Otros trastornos psicóticos no orgánicos(F28)' = 15,
'Psicosis no orgánica sin especificación(F29)' = 16,
'Reacciones a estrés grave y trastornos de adaptación(F43)' = 17,
'Síndrome amnésico orgánico no inducido por alcohol u otras sustancias psicotropas(F04)' = 18,
'Transformación persistente de la personalidad no atribuible a lesión o enfermedad cerebral(F62)' = 19,
'Trastorno bipolar(F31)' = 20,
'Trastorno de ideas delirantes inducidas(F24)' = 21,
'Trastorno de la personalidad y del comportamiento del adulto sin especificación(F69)' = 22,
'Trastorno del desarrollo psicológico sin especificación(F89)' = 23,
'Trastorno depresivo recurrente(F33)' = 24,
'Trastorno específico del desarrollo mixto(F83)' = 25,
'Trastorno esquizotípico.(F21)' = 26,
'Trastorno generalizado del desarrollo sin especificación(F849)' = 27,
'Trastorno mental orgánico o sintomático sin especificación(F09)' = 28,
'Trastorno mental sin especificación(F99)' = 29,
'Trastorno obsesivo-compulsivo(F42)' = 30,
'Trastornos de ideas delirantes persistentes.(F22)' = 31,
'Trastornos de la identidad sexual(F64)' = 32,
'Trastornos de la inclinación sexual(F65)' = 33,
'Trastornos de la personalidad y del comportamiento debidos a enfermedad, lesión o disfunción cerebral(F07)' = 34,
'Trastornos de las emociones de comienzo habitual en la infancia(F93)' = 35,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 36,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos sin especificación(F59)' = 37,
'Trastornos del comportamiento social de comienzo habitual en la infancia y adolescencia(F94)' = 38,
'Trastornos del humor (afectivos) persistentes(F34)' = 39,
'Trastornos disociales(F91)' = 40,
'Trastornos disociales y de las emociones mixtos(F92)' = 41,
'Trastornos disociativos (de conversión)(F44)' = 42,
'Trastornos específicos de la personalidad(F60)' = 43,
'Trastornos específicos del desarrollo del aprendizaje escolar(F81)' = 44,
'Trastornos esquizoafectivos(F25)' = 45,
'Trastornos generalizados del desarrollo(F84)' = 46,
'Trastornos Hipercineticos(F90)' = 47,
'Trastornos mentales y del comportamiento en el puerperio no clasificados en otro lugar(F53)' = 48,
'Trastornos mixtos y otros trastornos de la personalidad(F61)' = 49,
'Trastornos no orgánicos del sueño(F51)' = 50,
'Trastornos psicológicos y del comportamiento del desarrollo y orientación sexuales(F66)' = 51,
'Trastornos psicóticos agudos y transitorios(F23)' = 52,
'Trastornos somatomorfos(F45)' = 53)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10) <- c('Abuso de sustancias que no producen dependencia(F55X)' = 1,
'Delirium no inducido por alcohol u otras sustancias psicotropas(F059)' = 2,
'Demencia en enfermedades clasificadas en otro lugar(F02)' = 3,
'Demencia en la enfermedad de Alzheimer(F00)' = 4,
'Disfunción sexual no orgánica(F52)' = 5,
'Episodios depresivos(F32)' = 6,
'Factores psicológicos y del comportamiento en trastornos o enfermedades clasificados en otro lugar(F54)' = 7,
'Otros trastornos de ansiedad(F41)' = 8,
'Otros trastornos de la personalidad y del comportamiento del adulto(F68)' = 9,
'Otros trastornos de las emociones y del comportamiento de comienzo habitual en la infancia y adolescencia(F98)' = 10,
'Otros trastornos del desarrollo psicológico(F88)' = 11,
'Otros trastornos del humor (afectivos)(F38)' = 12,
'Otros trastornos mentales debidos a lesión o disfunción cerebral o a enfermedad somática(F06)' = 13,
'Otros trastornos neuróticos(F48)' = 14,
'Otros trastornos psicóticos no orgánicos(F28)' = 15,
'Psicosis no orgánica sin especificación(F29)' = 16,
'Reacciones a estrés grave y trastornos de adaptación(F43)' = 17,
'Síndrome amnésico orgánico no inducido por alcohol u otras sustancias psicotropas(F04)' = 18,
'Transformación persistente de la personalidad no atribuible a lesión o enfermedad cerebral(F62)' = 19,
'Trastorno bipolar(F31)' = 20,
'Trastorno de ideas delirantes inducidas(F24)' = 21,
'Trastorno de la personalidad y del comportamiento del adulto sin especificación(F69)' = 22,
'Trastorno del desarrollo psicológico sin especificación(F89)' = 23,
'Trastorno depresivo recurrente(F33)' = 24,
'Trastorno esquizotípico.(F21)' = 25,
'Trastorno generalizado del desarrollo sin especificación(F849)' = 26,
'Trastorno mental orgánico o sintomático sin especificación(F09)' = 27,
'Trastorno mental sin especificación(F99)' = 28,
'Trastorno obsesivo-compulsivo(F42)' = 29,
'Trastornos de ideas delirantes persistentes.(F22)' = 30,
'Trastornos de la conducta alimentaria(F50)' = 31,
'Trastornos de la identidad sexual(F64)' = 32,
'Trastornos de la inclinación sexual(F65)' = 33,
'Trastornos de la personalidad y del comportamiento debidos a enfermedad, lesión o disfunción cerebral(F07)' = 34,
'Trastornos de las emociones de comienzo habitual en la infancia(F93)' = 35,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 36,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos sin especificación(F59)' = 37,
'Trastornos del comportamiento social de comienzo habitual en la infancia y adolescencia(F94)' = 38,
'Trastornos del humor (afectivos) persistentes(F34)' = 39,
'Trastornos disociales(F91)' = 40,
'Trastornos disociales y de las emociones mixtos(F92)' = 41,
'Trastornos disociativos (de conversión)(F44)' = 42,
'Trastornos específicos de la personalidad(F60)' = 43,
'Trastornos específicos del desarrollo del aprendizaje escolar(F81)' = 44,
'Trastornos esquizoafectivos(F25)' = 45,
'Trastornos generalizados del desarrollo(F84)' = 46,
'Trastornos Hipercineticos(F90)' = 47,
'Trastornos mixtos y otros trastornos de la personalidad(F61)' = 48,
'Trastornos no orgánicos del sueño(F51)' = 49,
'Trastornos psicóticos agudos y transitorios(F23)' = 50,
'Trastornos somatomorfos(F45)' = 51)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10) <- c('Delirium no inducido por alcohol u otras sustancias psicotropas(F059)' = 1,
'Demencia vascular(F01)' = 2,
'Episodios depresivos(F32)' = 3,
'Factores psicológicos y del comportamiento en trastornos o enfermedades clasificados en otro lugar(F54)' = 4,
'Otros trastornos de ansiedad(F41)' = 5,
'Otros trastornos de la personalidad y del comportamiento del adulto(F68)' = 6,
'Otros trastornos de las emociones y del comportamiento de comienzo habitual en la infancia y adolescencia(F98)' = 7,
'Otros trastornos del desarrollo psicológico(F88)' = 8,
'Otros trastornos del humor (afectivos)(F38)' = 9,
'Otros trastornos mentales debidos a lesión o disfunción cerebral o a enfermedad somática(F06)' = 10,
'Otros trastornos neuróticos(F48)' = 11,
'Otros trastornos psicóticos no orgánicos(F28)' = 12,
'Psicosis no orgánica sin especificación(F29)' = 13,
'Reacciones a estrés grave y trastornos de adaptación(F43)' = 14,
'Síndrome amnésico orgánico no inducido por alcohol u otras sustancias psicotropas(F04)' = 15,
'Transformación persistente de la personalidad no atribuible a lesión o enfermedad cerebral(F62)' = 16,
'Trastorno bipolar(F31)' = 17,
'Trastorno de ideas delirantes inducidas(F24)' = 18,
'Trastorno de la personalidad y del comportamiento del adulto sin especificación(F69)' = 19,
'Trastorno del desarrollo psicológico sin especificación(F89)' = 20,
'Trastorno depresivo recurrente(F33)' = 21,
'Trastorno específico del desarrollo mixto(F83)' = 22,
'Trastorno específico del desarrollo psicomotor(F82)' = 23,
'Trastorno esquizotípico.(F21)' = 24,
'Trastorno mental orgánico o sintomático sin especificación(F09)' = 25,
'Trastorno mental sin especificación(F99)' = 26,
'Trastorno obsesivo-compulsivo(F42)' = 27,
'Trastornos de ideas delirantes persistentes.(F22)' = 28,
'Trastornos de la conducta alimentaria(F50)' = 29,
'Trastornos de la identidad sexual(F64)' = 30,
'Trastornos de la inclinación sexual(F65)' = 31,
'Trastornos de la personalidad y del comportamiento debidos a enfermedad, lesión o disfunción cerebral(F07)' = 32,
'Trastornos de las emociones de comienzo habitual en la infancia(F93)' = 33,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 34,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos sin especificación(F59)' = 35,
'Trastornos del comportamiento social de comienzo habitual en la infancia y adolescencia(F94)' = 36,
'Trastornos del humor (afectivos) persistentes(F34)' = 37,
'Trastornos disociales y de las emociones mixtos(F92)' = 38,
'Trastornos disociativos (de conversión)(F44)' = 39,
'Trastornos específicos de la personalidad(F60)' = 40,
'Trastornos específicos del desarrollo del aprendizaje escolar(F81)' = 41,
'Trastornos esquizoafectivos(F25)' = 42,
'Trastornos Hipercineticos(F90)' = 43,
'Trastornos mixtos y otros trastornos de la personalidad(F61)' = 44,
'Trastornos no orgánicos del sueño(F51)' = 45,
'Trastornos psicológicos y del comportamiento del desarrollo y orientación sexuales(F66)' = 46,
'Trastornos psicóticos agudos y transitorios(F23)' = 47,
'Trastornos somatomorfos(F45)' = 48)

#http://www.edras.cl/wg/data.edras.cl/resources-files-repository/Clasificacion_de_trastornos_mentales_CIE10.pdf
```

```{r generate data in csv, echo=F, paged.print=TRUE}
write.csv2(CONS_C1_df_dup_ENE_2020, file ="CONS_C1_df_dup_ENE_2020.csv")
```

&nbsp;
<br>

## 5. Probabilistic Deduplication

In Table 13 we can see that most of the cases had at least one case with the same combination of HASH-Key and date of admission. We replaced the age of cases with the same HASH-Key and date of admission.

<br>

```{r duplicated rows, echo=T, paged.print=TRUE}
#create the duplicated dataset, following the recommendation to separate columns
duplicated_rows_concat <- data.frame(duplicated_HASH_date = duplicated(CONS_C1_df_dup_ENE_2020[,c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")]), 
                                     row_dup_HASH_date = 1:nrow(CONS_C1_df_dup_ENE_2020[,c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")])) #%>%
  #arroja 117,620 casos únicos, aunque son muchos menos
as.data.table(CONS_C1_df_dup_ENE_2020)[, dup_hash_date := .N, by = c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")] %>% ##dim() #arroja 117,190 casos únicos. PERO CUIDADO: EN LOS QUE TIENEN 2, 3, 4, 5 Y MÁS, HAY CASOS QUE SON ÚNICOS TAMBIÉN (POR ESO UN DISTINCT NO LOS CAPTURA)
  dplyr::group_by(dup_hash_date) %>%
  dplyr::summarise(n=n()) %>%
  dplyr::mutate(perc = round(n / sum(n),2)*100) %>%
  dplyr::mutate(perc = paste0(perc,"%")) %>%
  dplyr::mutate(Tot.Cases = n/dup_hash_date) %>%
# Duplicated rows
#  data.frame(table(duplicated_rows_concat$duplicated_HASH_date,exclude=NULL),
#            `%`=paste0(round(prop.table(table(duplicated_rows_concat$duplicated_HASH_date,exclude=NULL)),3)*100,"%")) %>%
# as.data.frame(.) %>%  
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 13. Times that the combination of HASH-Key & Date of Admission may appear in the dataset", 
               col.names= c("Times", " Frequencies", "Percentage", "Unique Cases"),  align =rep('c', 4))  %>%
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12)
```

<br>

In Figure 2 we can see every case and the distribution of duplicated cases in terms of the same and exact HASH key and the same date of admission.

<br>

```{r dup rows, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F}
require(zoo)
#CONS_C1_df_dup_ENE_2020 %>%
as.data.table(CONS_C1_df_dup_ENE_2020)[, dup_hash_date := .N, by = c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")] %>% 
  dplyr::mutate(fech_ing_qrt=zoo::as.yearqtr(fech_ing)) %>%
  dplyr::select(fech_ing_qrt,dup_hash_date) %>%  dplyr::group_by(fech_ing_qrt) %>% 
  dplyr::summarise(duplicated = sum(dup_hash_date>1),n = sum(dup_hash_date), perc_dup=duplicated/n) %>%
  dplyr::filter(fech_ing_qrt>=2007) %>%
  ggplot2::ggplot(aes(x = fech_ing_qrt, y = perc_dup, label = paste0("n=",n))) +
  geom_line(color = "#0076A8", size=1) +
  #geom_text(aes(x = fech_ing_qrt, y = perc_dup-0.05, label = paste0(n)), vjust = -1,hjust = 0, angle=45, size=3) +
  sjPlot::theme_sjplot2() +
  labs(y="% of Duplicated Data",x="Years & Quarters, Date of Admission",caption="Note. Two cases with date of admission before 2007 were ignored; Percentages indicate the number of entries that have the \n same HASH & date of admission one or more times divided by the number of cases that are admitted in each quarter and \nyear.") + ggtitle( "Figure 2. Duplicated entries by year and quarter")+
  scale_y_continuous(limits=c(0, .075),labels = scales::percent) +
  scale_x_yearqtr(format="%YQ%q", n=20) +
  theme(axis.text.x = element_text(vjust = 0.5,hjust = 0.5,angle = 60), plot.caption=element_text(hjust=0)) 
```

&nbsp;

<br>

Cases shown in Table 13 represent exact matches. But in order to catch some differences that would probabilistically match in terms of HASH-Key and date of admission, we ran data into a package in the software Stata called **`dtalink`**, with the following criteria:

1. Hash Key, with a weight applied of 25 points, in case this variable match, but minus 25 in case that does not match
2. SENDA's ID, with a weight applied of 25 points, in case this variable match, but minus 25 in case that does not match
3. Sex, with a weight applied of 10 points, in case this variable match
4. Center's ID, with a weight applied of 10 points, in case this variable match
5. Date of Admission, with a weight applied of 30 points, in case this variable match, but minus 30 in case that does not match, and a calliper of 5 days to consider as a match a difference of 5 days or less
6. Blocking variable of Age, in order to reduce time of computation and match each cases within people with the same Age.
7. Matches will be considered as significant if the match accumulates at least 70 points.

<br>

The code used in stata is shown here:

&nbsp;
<br>

```{stata, collectcode=TRUE}
import delimited "G:\Mi unidad\Alvacast\SISTRAT 2019 (github)\SUD_CL\CONS_C1_df_dup_ENE_2020.csv", delimiter(";") clear 

cap gen date_in = mdy(real_fech_ing_mes, real_fech_ing_dia, real_fech_ing_ano)
cap gen date_in = mdy(fech_ing_mes, fech_ing_dia, fech_ing_ano)

generate id_match = _n
cap drop _id
dtalink hash_key 25 -25 id 25 -25 sexo 10 0 idcentro 10 0 date_in 30 -30 5, block(edad) cutoff(70)
drop if missing(_score)
qui save "G:\Mi unidad\Alvacast\SISTRAT 2019 (github)\Stata Duplicates Match\_CONS_C1_df_match70_2020_02_11.dta", replace
```

```{r  dta_import, include=T, echo=T, eval=T, cache=T}
matches_from_stata_c1 <- haven::read_dta("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/Stata Duplicates Match/_CONS_C1_df_match70_2020_02_11.dta")
matches_from_stata_c1 <-matches_from_stata_c1 %>% dplyr::rename(score = 3, matchID = 1, row_id=2) 
matches_from_stata_c1  %>%
  dplyr::arrange(score,matchID,hash_key) %>%
  dplyr::select(score, matchID, hash_key, ano_bd, idcentro, date_in, fech_ing, fech_egres, edad, dias_trat) %>%
  as.data.frame() %>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 14. Preliminary View of Matches from Stata", align =rep('c', 100)) %>%
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
    kableExtra::scroll_box(width = "100%", height = "350px")
```
<br>

An a analysis of probabilistic matches between events by the requirements listed above, showed us 1 case with a missing value in the date of admission, (correspondent to the HASH KEY "6c409c18bf7cc518819dc63c4e8e98ef"), `r matches_from_stata_c1 %>% dplyr::filter(score<100) %>% nrow()/2` matches with a value of 90 points, and `r matches_from_stata_c1 %>% dplyr::filter(score==100) %>% nrow()/2` matches with 100 points (`r matches_from_stata_c1 %>% group_by(score) %>% count() %>% ungroup() %>% mutate(perc=paste0(round(n/sum(n),2)*100,"%")) %>% filter(score==100) %>% dplyr::select(-score,-n) %>% as.data.table(.)%>%as.character()`). Must note that around a 93% of HASHs involved in matching appear around `r matches_from_stata_c1 %>% group_by(hash_key) %>% summarise(n=n()) %>% summarise(quantile(n,c(.93))) %>% as.numeric()` times (very possible considering the match would be produced by the coincidence of HASH Keys), and the remaining 7%, 4 times or more.

<br>

```{r  Case with no date of admission, include=F, eval=F}
CONS_C1 %>%
  dplyr::filter(HASH_KEY=="6c409c18bf7cc518819dc63c4e8e98ef") %>%
  #dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres, dias_trat,tipo_de_plan, tipo_de_programa, ID.centro, Edad) %>%
  head()
CONS_C1_df_dup_ENE_2020 %>%
  dplyr::filter(HASH_KEY=="6c409c18bf7cc518819dc63c4e8e98ef") %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres, dias_trat,tipo_de_plan, tipo_de_programa, ID.centro, Edad) %>%
  head()
```

```{r  Fig 3, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F}
#quantile(matches_hash_freq$n, .80)
#summary(matches_hash_freq)
#
#quantile(Duplicates_Matching_ene_2020$n, prob)
matches_from_stata_c1 %>% group_by(hash_key) %>% summarise(n=n()) %>% as.data.frame() %>%dplyr::select(n) %>% 
ggplot(aes(n)) +
  geom_histogram(alpha=.5)+
  labs(title=paste0("Figure 3. Histogram of HASH Keys in matches (n=",matches_from_stata_c1 %>% group_by(hash_key) %>% summarise(n=n()) %>% nrow(), ")"), y = "Freq.")+
  scale_x_continuous(name="Repetitions", breaks=seq(0,12,2)) +
  theme_classic()
```

<br>

An analysis of duplicated events showed that many ranges between the dates of admission and discharge are overlapping due to derivations, principally by changes in the center of treatment, being the following the most repeated among cases: Centro Tratamiento Adicciones Unidos, Hospital Santa Cruz; and Centro de Tratamiento adicciones Esperanza, Hospital Santa Cruz. This could be seen in the fact that many users may move from centers 221 to 591, 147 to 358, 164 to 325, or 200 to 203. However, **to identify overlappings in treatments it is necessary to obtain the missing dates, and clean the dates that may be wrong**.

&nbsp;
<br>

Figure 4 let us observe how many treatments overlap. Many users start from 2000 to nowadays. This graphic may be seem a bit noisy, but we should see less black colored regions and more white areas between lines. Regarding Figure 4.2, we selected 25 cases randomly assigned of a list of cases that may have overlapping treatments, in order to make possible an interpretation graphically, and we may appreciate that some horizontal lines (HASHs) may have more than one color (treatments) over time, each color above the other. In contrast, Figure 4.3 shows four examples of clean trajectories which does not have overlaps over time.

<br>

<div class="superbigimage">
```{r  Fig 4, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F, cache=T}
CONS_C1_df_dup_intervals<- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::rename("HASH_KEY_2"="HASH_KEY", "row2"="row") %>%
  dplyr::select(row2,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso, SENDA) %>% 
  dplyr::filter(motivodeegreso!="Derivación") %>%
  data.table::as.data.table()
require(sqldf)
require(gridExtra)
  overlap_dates_C1 <- janitor::clean_names(sqldf("SELECT *
                 FROM CONS_C1_df_dup_intervals AS x  
                 INNER JOIN CONS_C1_df_dup_intervals AS y 
                 ON x.HASH_KEY_2 == y.HASH_KEY_2 AND 
                 x.fech_ing_num2 < y.fech_egres_num2 AND x.fech_egres_num2 > y.fech_ing_num2 AND x.row2 != y.row2"))  
  #busca mismo hash, distinto row,pero fecha de ingreso menor o igual a la fecha de egreso del otro, y fecha de egreso mayor o igual a la fecha de ingreso del otro. ESTO ES PARA VER SI SE SUPERPONEN.
as.data.table(overlap_dates_C1) %>%
    dplyr::arrange(hash_key_2, fech_ing_num2, row2) %>% ggplot(.) + 
  geom_segment(aes(x = fech_ing, xend = fech_egres,
                   y = hash_key_2, yend = hash_key_2)) + theme(axis.line=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_text(""),legend.position="none",
          panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),plot.background=element_blank()) +
  theme(plot.caption = element_text(hjust = 0, face= "italic")) +
    labs(x = "Dates of admission and discharge", y = "", caption="Note. Only users that share characteristics and overlap between them")+
    ggtitle("Figure 4.1 Trajectories of HASHs from dates of admission to discharge")
```
</div>

```{r  Fig 4_v2, fig.height=14, fig.width=8, warning=FALSE, fig.align = "center", message=F, cache=T}
c26 <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "gray16", "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown", "gray40")

  set.seed(4321)
  random<-round(runif(1, 1, 100),0)
sample_plot <- overlap_dates_C1 %>% 
    dplyr::arrange(hash_key_2, fech_ing_num2, row2) %>% 
  dplyr::slice(random:(random+25)) %>%
  mutate(Date = format(as.Date(fech_ing, format = "%Y-%m-%d"))) %>% 
  ggplot(aes(x=Date)) + 
  geom_segment(aes(x = fech_ing, xend = fech_egres,
                   y = hash_key_2, yend = hash_key_2,colour=as.factor(row2),size=1/100)) + theme(axis.line=element_blank(),axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_text(""),legend.position="none",axis.title.y=element_text("HASHs"),
          panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),plot.background=element_blank()) +
  #scale_x_date(breaks = scales::date_breaks("1 year"), date_labels = "%b %d") +
    theme(plot.caption = element_text(hjust = 0, face= "italic")) +
  scale_color_manual(values=c26) +
    labs(x = "Dates of admission and discharge", y = "", caption="Note. Only users that share characteristics overlap between them",
         subtitle="Sample of 25 cases. Colored lines represent different rows in the dataset, but same HASH")+
    ggtitle("Figure 4.2 Trajectories of every HASH from dates of admission to discharge")
    #+
  #geom_text(vjust = -0.5, hjust=0, size = 1,
  #          aes(x = start_date, y = membershipID, 
  #              label = paste(round(mo_dur, 2), "months")))

clean_plot <- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(HASH_KEY_2=HASH_KEY) %>%
  dplyr::select(row,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso, SENDA)%>%     as.data.table() %>%
  dplyr::filter(HASH_KEY_2 %in% c("07b0d5b1e32b62374685e48039ae6a67",	"0b810dfb7988e5e795b03a9cadc771fe", "0c3aa4566acbeb996e4bf645c7210f83", "01a95b45fa9acf445fe1a7106f2f6664")) %>%
  dplyr::arrange(HASH_KEY_2, fech_ing_num2, row) %>% 
  mutate(Date = format(as.Date(fech_ing, format = "%Y-%m-%d"))) %>% 
  ggplot(aes(x=Date)) + 
  geom_segment(aes(x = fech_ing, xend = fech_egres,
                   y = HASH_KEY_2, yend = HASH_KEY_2,colour=as.factor(row),size=1/100)) + 
  theme(axis.line=element_blank(),
          axis.ticks=element_blank(),axis.title.y=element_text("HASHs"),axis.text.y=element_blank(),
          axis.title.x=element_text(""),legend.position="none",
          panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),plot.background=element_blank(), plot.title = element_text(hjust = 0))+
  #scale_x_date(breaks = scales::date_breaks("1 year"), date_labels = "%b %d") +
    theme(plot.caption = element_text(face= "italic",hjust = 0)) +
    labs(x = "Dates of admission and discharge", y="HASHs", caption="Note. Only users that share characteristics overlap between them",
         subtitle="Example of 4 clean trajectories. Colored lines represent different rows in the dataset, but same HASH")+
    ggtitle("Figure 4.3 Trajectories of every HASH from dates of admission to discharge")

grid.arrange(sample_plot, clean_plot)
```

In Figure 4, we may notice that `r nrow(overlap_dates_C1)` matches of entries that may share the same HASH Key, but the date of admission is lesser than the date of discharge of another entry in the dataset, and the date of discharge is greater than the date of admission of that other case; and does not include derivation as a cause of discharge. These conditions let us see how many cases overlap with another entry in the dataset.

As can be seen in Table 15, many treatment discharge dates were NULL values, deriving in a misleading count of treatment days, which were calculated as the difference between the date in which the datasets were retrieved and the date of admission. This one of the reasons that this variable may confound the analysis of duplicated data because it can be explained by different but overlapping treatments, or by duplicated treatments. However, it is necessary to clarify the intervals in which cases were overlapping, by getting the days of treatment and determine whether an specific HASH may already have finished a treatment or not. Table 14 shows the entries with missing dates of discharge, and the difference between the date that the dataset were possibly retrieved (Second week of november of 2019), and the days of treatment showed, by each yearly dataset obtained.  NA's show cases in which even the number of treatment days was not available.  Considering the numbers exposed, we think that **cases in datasets from 2018 and after may be available and not be a part of incompleteness due to right censoring because they may still be in treatment up until the date of retrieval of the datasets (leaving an approximate of 272 HASHs and date of admissions left to analyse). We asked for this information to SENDAs professionals.**

<br>

```{r diff between dates,echo=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020 %>%
  dplyr::filter(is.na(fech_egres)) %>%
  dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), dias_trat_trans= as.numeric(as.Date("2019-11-13"))-fech_ing_num, 
                diff_treat_days=dias_trat-dias_trat_trans) %>% #fecha del día de hoy 
  dplyr::select(HASH_KEY, id_mod, ano_bd, sexo, fech_ing, fech_ing_num, dias_trat_trans,dias_trat,diff_treat_days) %>%
  dplyr::group_by(diff_treat_days, ano_bd) %>%
  dplyr::summarize(n=n()) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 15. Missing Date of Discharge, Difference between Treatment Dates", col.names= c("Treat Days", "Year of Dataset", "N"),  align =rep('c', 3))  %>%
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 10) %>%
  kableExtra::add_footnote(c("Assuming the date of retrieval, 2019-11-13"), notation = "none")
#number of hash and date of admission.
#   HASHs_w_o_date_discharge %>%
#            dplyr::mutate(HASH_fecha_ingreso=paste0(HASH_KEY,"_",fech_ing_num)) %>% 
#            dplyr::left_join(combinacion_reemplazada,by="HASH_fecha_ingreso") %>%
#            dplyr::mutate(ano_bd.x=as.numeric(ano_bd.x)) %>%
#            dplyr::filter(is.na(HASH_KEY.y),ano_bd.x<=2017) %>%
#            dplyr::mutate(fech_ingres=as.Date(fech_ing_num)) %>% 
#            dplyr::select(c(1,2,14)) %>%
#            dplyr::rename("HASH"=HASH_KEY.x,"Ano_Base_Datos" =ano_bd.x, "Fecha_Ingreso"=fech_ingres) #%>% nrow()
```

&nbsp;
<br>

Considering that some cases may have the same HASH and date of admission  along the dataset, we found that 20 cases would not be included in the Table 15, because they can be replaced with a propper date of discharge  or inferred by more recent records, according to the information available.

<br>

```{r saving dates w o discharge date,echo=T, paged.print=TRUE,message=F}
HASHs_w_o_date_discharge<- CONS_C1_df_dup_ENE_2020 %>%
          dplyr::filter(is.na(fech_egres)) %>%
          dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), dias_trat_trans= as.numeric(as.Date("2019-11-13"))-fech_ing_num, 
                        diff_treat_days=dias_trat-dias_trat_trans,fech_egres_num=as.numeric(as.Date(fech_egres))) %>% #fecha del día de hoy 
          dplyr::select(row, HASH_KEY, id_mod, ano_bd, sexo, fech_ing, fech_ing_num, fech_egres_num, dias_trat_trans,dias_trat,diff_treat_days) %>%
          dplyr::select(HASH_KEY, ano_bd, fech_ing_num) %>%        
          dplyr::distinct(HASH_KEY,fech_ing_num)# %>% dim() 8142

CONS_C1_df_egres2<- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(HASH_KEY_2=HASH_KEY) %>%
  dplyr::filter(!is.na(fech_egres)) %>%
  dplyr::select(row,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso) %>% 
  as.data.table()

require(data.table) #v>=1.9.8
 
#54 cases of C1 that do not have dates of discharge,  that can be replaced with cases in C1 that have available dates of discharge but with a date of admission equal  or greater than  the not   available.
CONS_C1_df_egres2[HASHs_w_o_date_discharge, on = .(HASH_KEY_2=HASH_KEY,fech_ing_num2 >= fech_ing_num), nomatch = 0,
      .(row,HASH_KEY,id_mod, ano_bd,fech_ing, fech_egres,Edad,Nombre.Centro,motivodeegreso)] %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
              caption="Table 16. Cases with the same HASH and date of admission, that had a more recent date of discharge", align =rep('c', 101)) %>% 
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 9) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
#Update of 31-12-2019, nomatch= 0 may be wrong. Finally, it was right for this analysis. Similar to left join:
#CONS_C1_df_egres[HASHs_w_o_date_discharge, on = .(HASH_KEY_2=HASH_KEY,fech_ing_num >= fech_ing_num), #nomatch = 0, its an inner join
#      .(row,HASH_KEY,id_mod, ano_bd,fech_ing, fech_egres,Edad,Nombre.Centro,motivodeegreso)]  %>%      dplyr::filter(!is.na(HASH_KEY))
#fuzzyjoin::fuzzy_left_join(as_tibble(HASHs_w_o_date_discharge),as_tibble(CONS_C1_df_egres2),
#                           by = c("HASH_KEY" = "HASH_KEY", "fech_ing_num" <= "fech_ing_num2"), 
#                           match_fun = list(`==`, `>`))
# OR
#sqldf("
#SELECT *
#FROM HASHs_w_o_date_discharge  
#INNER JOIN CONS_C1_df_egres2 
#ON HASHs_w_o_date_discharge.HASH_KEY == CONS_C1_df_egres2.HASH_KEY AND 
#  HASHs_w_o_date_discharge.fech_ing_num <= CONS_C1_df_egres2.fech_ing_num2") 
```

&nbsp;
<br>

In Table 17, we offer a table of each HASH and dates of discharge. This Table may permit to estimate if one of the dates may be replaced by the last date or definetly erase the case. **As stated in the meeting of Jan. 13 of 2020, an alternative would be to impute days of treatment and generate a new date of discharge by adding the days of treatment to the date of admission.**

<br>


```{r analyzing replace of dates w o discharge date,echo=T, paged.print=TRUE, message=F, cache=T}
HASHs_w_o_date_discharge<- CONS_C1_df_dup_ENE_2020 %>%
          dplyr::filter(is.na(fech_egres)) %>%
          dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), dias_trat_trans= as.numeric(as.Date("2019-11-13"))-fech_ing_num, 
                        diff_treat_days=dias_trat-dias_trat_trans,fech_egres_num=as.numeric(as.Date(fech_egres))) %>% #fecha del día de hoy 
          dplyr::select(row, HASH_KEY, id_mod, ano_bd, sexo, fech_ing, fech_ing_num, fech_egres_num, dias_trat_trans,dias_trat,diff_treat_days) %>%
          dplyr::select(HASH_KEY, ano_bd, fech_ing_num) %>%        
          dplyr::distinct(HASH_KEY,fech_ing_num)# %>% dim() 8142

CONS_C1_df_egres2<- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(HASH_KEY_2=HASH_KEY) %>%
  dplyr::filter(!is.na(fech_egres)) %>%
  dplyr::select(row,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso) %>% 
  as.data.table()
#153394 rows

require(data.table) #v>=1.9.8
#54 cases of C1 that do not have dates of discharge,  that can be replaced with cases in C1 that have available dates of discharge but with a date of admission equal  or greater than  the not   available.
CONS_C1_df_dup_w_date_discharge <- CONS_C1_df_egres2[HASHs_w_o_date_discharge, on = .(HASH_KEY_2=HASH_KEY,fech_ing_num2 >= fech_ing_num), nomatch = 0,
                  .(row,HASH_KEY,id_mod, ano_bd,fech_ing, fech_egres, fech_egres_num2, Edad,Nombre.Centro,motivodeegreso)]
#select hashs for analysis
CONS_C1_df_dup_w_date_discharge_HKEY <-CONS_C1_df_dup_w_date_discharge %>% distinct(HASH_KEY)

dplyr::left_join(CONS_C1_df_dup,CONS_C1_df_dup_w_date_discharge, by = "HASH_KEY", suffix = c("", ".disch")) %>% # dim()
dplyr::mutate(fech_egres_corr= ifelse(is.na(fech_egres),fech_egres_num2,as.character(fech_egres))) %>% 
  dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_w_date_discharge_HKEY)))))) %>%
  dplyr::select(row,ano_bd, HASH_KEY, fech_ing, fech_egres, fech_ing.disch, fech_egres.disch, fech_egres_corr) %>%
  dplyr::arrange(HASH_KEY, fech_ing) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
              caption="Table 17. HASHs with more recent date of discharge, for analysis and replace", align =rep('c', 101)) %>% 
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 9) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")

#NO SE PUEDEN RESCATAR DE TOPs
#CONS_C1_df_dup_ENE_2020_w_date_disch <- CONS_C1_df_dup_ENE_2020 %>% dplyr::filter(is.na(fech_egres)) #no puedo rescatar de TOP
#CONS_TOP %>%
#  dplyr::mutate(fech_ing= lubridate::parse_date_time(Fecha.de.Ingreso.a.Tratamiento, c("%d/%m/%Y"),exact=T)) %>% #no fallan casos en ser transformados
#  dplyr::filter(TOP=="Egreso", Etapa.del.Tratamiento=="Egreso") %>%
#  dplyr::mutate(fech_ap_top= lubridate::parse_date_time(Fecha.Aplicación.TOP, c("%Y-%m-%d"),exact=T)) %>% #ni un caso falla en ser transformado
#  dplyr::mutate(concat=paste0(HASH_KEY,"_",fech_ing)) %>%
#  dplyr::right_join(CONS_C1_df_dup_ENE_2020_w_date_disch,by="concat") %>% 
#  dplyr::filter(!is.na(fech_ap_top)) %>%
#  dplyr::select(HASH_KEY.x, fech_ing.x,concat,fech_egres,fech_ap_top) %>%View()
```

```{r change labels,echo=F, paged.print=TRUE}
#TODAVÍA NO ES POSIBLE HACER EL TRASPASO DE ESAS FECHAS TAN IMPORTANTES AL HASH.
#NO SE PUEDEN RESCATAR DE TOPs
#CONS_C1_df_dup_ENE_2020_w_date_disch <- CONS_C1_df_dup_ENE_2020 %>% dplyr::filter(is.na(fech_egres)) #no puedo rescatar de TOP
#CONS_TOP %>%
#  dplyr::mutate(fech_ing= lubridate::parse_date_time(Fecha.de.Ingreso.a.Tratamiento, c("%d/%m/%Y"),exact=T)) %>% #no fallan casos en ser transformados
#  dplyr::filter(TOP=="Egreso", Etapa.del.Tratamiento=="Egreso") %>%
#  dplyr::mutate(fech_ap_top= lubridate::parse_date_time(Fecha.Aplicación.TOP, c("%Y-%m-%d"),exact=T)) %>% #ni un caso falla en ser transformado
#  dplyr::mutate(concat=paste0(HASH_KEY,"_",fech_ing)) %>%
#  dplyr::right_join(CONS_C1_df_dup_ENE_2020_w_date_disch,by="concat") %>% 
#  dplyr::filter(!is.na(fech_ap_top)) %>%
#  dplyr::select(HASH_KEY.x, fech_ing.x,concat,fech_egres,fech_ap_top) %>%View()

  metadata(CONS_C1_df_dup_ENE_2020)$name <- "Agreement 1 SENDA"
  metadata(CONS_C1_df_dup_ENE_2020)$description <- "Information About Agreement 1 of SENDA and MINSAL"
  
codebook::var_label(CONS_C1_df_dup_ENE_2020) <- list(row = 'Numerador de los eventos presentes en la Base de Datos/Events in the Dataset',
TABLE = 'Origen de los Datos (de los archivos por año)/Source of Data (of files per year)',
HASH_KEY = 'Codificación del RUT/Masked Identifier (RUT)',
ano_bd = 'Año de la Base de Datos/Year of the Dataset (Source)',
id = 'Codigo Identificación de SENDA/SENDAs ID',
Nombre.Centro = 'Nombre del Centro de Tratamiento/Treatment Center',
tipo_centro = 'Tipo de Centro/Type of Center',
Región.del.Centro = 'Región del Centro/Chilean Region of the Center',
Servicio.de.Salud = 'Servicio de Salud/Health Service',
Tipo.de.Programa = '(original, Recodificado en tipo_de_programa)/',
Tipo.de.Plan = '(original, Recodificado en tipo_de_plan)/',
SENDA = 'SENDA/SENDA',
dias_trat = 'Días de Tratamiento/Days of Treatment',
nmesesentratamiento = 'Número de Meses en Tratamiento/Number of Months in Treatment',
Dias.en.SENDA = 'Días en SENDA/Days in SENDA',
N.Meses.en.SENDA = 'Número de Meses en SENDA/Number of Months in SENDA',
Sexo = '(original, Recodificado en sexo)/',
Edad = 'Edad (número entero)/Year (Discrete Number)',
Nombre.Usuario = 'Nombre del Usuario (OCULTO y no accesible)/Name of the User (Not Accessible)',
Comuna.Residencia = 'Comuna de Residencia/Municipality of Residence',
Origen.de.Ingreso = '(original, Recodificado en origen_ingreso)/',
País.Nacimiento = 'País de Nacimiento/Country of Birth',
Nacionalidad = 'Nacionalidad/Nationallity',
Etnia = 'Etnia/Ethnicity',
Estado.Conyugal = '(original, Recodificado en estado_conyugal)/',
Número.de.Hijos = 'Número de Hijos/Number of Children',
Número.de.Hijos.Ingreso.Tratamiento.Residencial = 'Número de Hijos para Ingreso a Tratamiento Residencial/Number of Children to Residential Treatment',
Parentesco.con.el.Jefe.de.Hogar = '(Sólo presenta valores perdidos)/',
Numero.de.Tratamientos.Anteriores = 'Número de Tratamientos Anteriores/Number of Previous Treatments',
Fecha.Ultimo.Tratamiento = 'Fecha del Último Tratamiento (aún no formateada como fecha)/Date of the Last Treatment',
Sustancia.de.Inicio = '(original, Recodificado en sus_ini)/',
Edad.Inicio.Consumo = '(original, Recodificado en edad_ini_cons)/', 
X.Se.trata.de.una.mujer.embarazada. = 'Mujer Embarazada al Ingreso/Pregnant at Admission',
Escolaridad..último.año.cursado. = '(original, Recodificado en escolaridad)/', 
Condicion.Ocupacional = '(original, Recodificado en estatus_ocupacional)/', 
Categoría.Ocupacional = '(original, Recodificado en cat_ocupacional)/',
Rubro.Trabaja = 'Rubro de Trabajo/Area of Work',
Con.Quién.Vive = 'Persona con la que vive el Usuario/People that Share Household with the User',
Tipo.de.vivienda = 'Tipo de Vivienda/Type of Housing',
Tenencia.de.la.vivienda = 'Tenencia de la Vivienda/Tenure status of Households',
Sustancia.Principal = '(original, Recodificado en sus_principal)/',
Otras.Sustancias.nº1 = '(original, Recodificado en otras_sus1)/',
Otras.Sustancias.nº2 = '(original, Recodificado en otras_sus2)/',
Otras.Sustancias.nº3 = '(original, Recodificado en otras_sus3)/',
Frecuencia.de.Consumo..Sustancia.Principal. = '(original, Recodificado en freq_cons_sus_ini)/',
Edad.Inicio..Sustancia.Principal. = '(original, Recodificado en edad_ini_sus_prin)/',
Vía.Administración..Sustancia.Principal. = '(original, Recodificado en via_adm_sus_ini)/',
Diagnóstico.Trs..Consumo.Sustancia = 'Diagnósico de Trastorno por Consumo de Sustancias/Diagnosed of Substance Use Disorder',
Diagnóstico.Trs..Psiquiátrico.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV/Diagnosis of Psychiatric Disorders, DSM-IV criteria',
Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification)',
X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (2)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (2)',
X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion) (2)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (2)',
X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (3)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (3)',
X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion) (3)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (3)',
Diagnóstico.Trs..Psiquiátrico.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10/Diagnosis of Psychiatric Disorders, CIE-10 criteria',
Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification)',
X2.Diagnóstico.Trs..Psiquiátrico.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (2)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (2)',
X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion) (2)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (2)',
X3.Diagnóstico.Trs..Psiquiátrico.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (3)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (3)',
X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion) (3)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (3)',
Diagnóstico.Trs..Físico = 'Diagnóstico de Trastorno Físico/Diagnosis of Physical Disorder',
Otros.Problemas.de.Atención.de.Salud.Mental = 'Otros Problemas de Atención Vinculados a Salud Mental/Other problems linked to Mental Health',
Compromiso.Biopsicosocial = 'Compromiso Biopsicosocial/Biopsychosocial Involvement',
DIAGNOSTICO.GLOBAL.DE.NECESIDADES.DE.INTEGRACION.SOCIAL = 'Diagnóstico Global de Necesidades de Integración Social/Global Diagnosis of Social Integration',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.HUMANO = 'Diagnóstico de Necesidades de Integración Social en Capital Humano/Global Diagnosis of Social Integration in Human Capital',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.FISICO = 'Diagnóstico de Necesidades de Integración Social en Capital Físico/Global Diagnosis of Social Integration in Physical Capital',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.SOCIAL = 'Diagnóstico de Necesidades de Integración Social en Capital Social/Global Diagnosis of Social Integration in Social Capital',
fech_ing = 'Fecha de Ingreso a Tratamiento/Date of Admission to Treatment',
Fecha.Ingreso.a.Convenio.SENDA = 'Fecha de Ingreso a Convenio SENDA (aún no formateada como fecha)/Date of Admission to SENDA Agreement',
Usuario.de.Tribunales..Tratamiento.Drogas = 'Usuario de modalidad Tribunales de Tratamiento de Drogas/User of Drug Treatment Courts Modality',
Consentimiento.Informado = 'Consentimiento Informado/Informed Consent',
fech_egres = 'Fecha de Egreso de Tratamiento/Date of Discharge from Treatment',
motivodeegreso = 'Motivo de Egreso/Cause of Discharge',
Tipo.Centro.Derivación = 'Tipo de Centro al que el Usuario es Derivado/Type of Center of Derivation',
evaluacindelprocesoteraputico = 'Evaluación del Proceso Terapéutico/Evaluation of the Therapeutic Process',
eva_consumo = 'Evaluación al Egreso Respecto al Patrón de consumo/Evaluation at Discharge regarding to Consumption Pattern',
eva_fam = 'Evaluación al Egreso Respecto a Situación Familiar/Evaluation at Discharge regarding to Family Situation',
eva_relinterp = 'Evaluación al Egreso Respecto a Relaciones Interpersonales/Evaluation at Discharge regarding to Interpersonal Relations',
eva_ocupacion = 'Evaluación al Egreso Respecto a Situación Ocupacional/Evaluation at Discharge regarding to Occupational Status',
eva_sm = 'Evaluación al Egreso Respecto a Salud Mental/Evaluation at Discharge regarding to Mental Health',
eva_fisica = 'Evaluación al Egreso Respecto a Salud Física/Evaluation at Discharge regarding to Physical Health',
eva_transgnorma = 'Evaluación al Egreso Respecto a Trasgresión a la Norma Social/Evaluation at Discharge regarding to Transgression to the Norm',
Diagnóstico.Trastorno.Psiquiátrico.CIE.10.al.Egreso = '(Sólo presenta valores perdidos)/',
DIAGNOSTICO.GLOBAL.DE.NECESIDADES.DE.INTEGRACION.SOCIAL.1 = 'Diagnóstico Global de Necesidades de Integración Social (1)/Global Diagnosis of Social Integration (1)',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.HUMANO.1 = 'Diagnóstico de Necesidades de Integración Social en Capital Humano (1)/Global Diagnosis of Social Integration in Human Capital (1)',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.FISICO.1 = 'Diagnóstico de Necesidades de Integración Social en Capital Físico (1)/Global Diagnosis of Social Integration in Physical Capital (1)',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.SOCIAL.1 = 'Diagnóstico de Necesidades de Integración Social en Capital Social (1)/Global Diagnosis of Social Integration in Social Capital (1)',
TIENE.MENORES.DE.EDAD.A.CARGO = 'Menores de Edad A Cargo/Minor Dependants',
Motivo.de.egreso.Alta.Administrativa = 'Motivo de Egreso Alta Administrativa/Cause of Discharge ',
Consorcio = 'Sociedades de Tratamiento, Servicios de Salud, Fundaciones, entre otras entidades encargadas de los centros/Consortium',
ID.centro = 'ID de Centro/Center ID',
Ha.estado.embarazada.egreso. = '¿Ha estado embarazada? (al Egreso)/Have you been Pregnant (at Discharge)',
identidad.de.genero = 'Identidad de Género/Gender Identity',
discapacidad = 'Presenta Discapacidad/Disability',
hash_rut_completo = 'HASH alternativo, en el escenario en que se asuma que el individuo al que se le codificó el RUT presente mayor edad/Alternative HASH-Key',
Opción.discapacidad = 'Origen de Discapacidad/Cause of Disability',
sexo = 'Sexo Usuario/Sex of User',
embarazo = 'Embarazo/Pregnant',
tipo_de_plan = 'Tipo de Plan/Type of Plan',
tipo_de_programa = 'Tipo de Programa de Tratamiento/Type of Program',
fech_egres_sin_fmt = 'Fecha de Egreso de Tratamiento (Sin Formato de Fecha)/Date of Discharge',
id_mod = 'ID de SENDA para Presentación en Página Web (enmascara caracteres 5 y 6)/SENDAs ID (mask characters 5 & 6)',
ano_nac = 'Año de Nacimiento (numérico)/Year of Birth (numeric)',
fech_ing_ano = 'Año de Ingreso (numérico)/Year of Admission (numeric)',
fech_ing_mes = 'Mes de Ingreso (numérico)/Month of Admission (numeric)',
fech_ing_dia = 'Día de Ingreso (numérico)/Day of Admission (numeric)',
concat = 'ID de SENDA y HASH Concatenado (permite discriminar más de un HASH en un mismo ID)/Combination of SENDAs ID & HASH',
dias_trat_inv = 'Días de Tratamiento Invertidos (fecha más reciente, menor valor numérico)/Treatment Days (Reversed)',
fech_nac = 'Fecha de Nacimiento/Date of Birth',
Edad_al_ing = 'Edad a la Fecha de Ingreso a Tratamiento (numérico continuo)/Age at Admission to Treatment',
edad_ini_cons= 'Edad de Inicio de Consumo/ Age of Onset of Drug Use',
edad_ini_sus_prin =  'Edad de Inicio de Consumo Sustancia Principal/ Age of Onset of Drug Use Principal Substance',
dias_trat_alta_temprana = 'Días de tratamiento (<90)/ Less than 90 days in treatment',
motivodeegreso_mod = 'Motivo de Egreso (con abandono temprano y tardío)/Cause of Discharge (with late and early withdrawal)',
sus_principal = 'Sustancia Principal de Consumo/Main Substance of Consumption',
otras_sus1= 'Otras Sustancias (1)/Other Substances (1)',
otras_sus2= 'Otras Sustancias (2)/Other Substances (2)',
otras_sus3= 'Otras Sustancias (3)/Other Substances (3)',
sus_ini= 'Sustancia de Inicio/Starting Substance',
estado_conyugal='Estado Conyugal/Marital Status',
estatus_ocupacional= 'Condición Ocupacional/Occupational Status',
cat_ocupacional= 'Categoría Ocupacional/Occupational Category',
Edad_grupos	= 'Edad agrupada/Age in groups',
origen_ingreso= 'Origen de Ingreso/Motive of Admission to Treatment',
escolaridad= 'Escolaridad: Nivel Eduacional/Education Attainment',
freq_cons_sus_ini = 'Frecuencia de Consumo de la Sustancia Principal/Frequency of Consumption of the Main Substance',
via_adm_sus_ini = 'Vía de Administración de la Sustancia Principal/Route of Administration of the Main Substance')

#PARA EXPORTAR LABELS A EXCEL
#data.table::data.table(table(CONS_C1_df_dup_ENE_2020$identidad.de.genero, exclude=NULL)) %>% mutate(export=paste0(row_number(),".",V1)) %>% select(-V1) %>% select(export,N)%>% copiar_nombres()

#save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/3.Rdata")
```

```{r saving dataset in 3 Rdata, echo=F, paged.print=TRUE}
save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/3.Rdata")
```

<br>

Leaving behind the last questions that may condition the analysis, we ran a probabilistic match based on the criteria defined above in the **`dtalink`** software. In Table 17 there is a selection of probabilistics matches that have elements that are worth of discussion.  Most of them have many information in common, describing derivations to another center or parallel treatments, and others do not overlap but were match due to the span of +/-5 days as calliper in the date of admission. However, some characteristics change and are different between them, requiring to be precautious to not automatically delete one of them and drop information that might be useful.

* JOCA1**071981	shares the same date of admission and center. One of the cases is not part of the SENDA Program. The type of plan changes.
* JOMA1**031956	have three dates of admission in the same center in the same dates and was derived one time, passed through a therapeutic discharge and then is dervided again. The type of plan changes. One of the registries have a difference of two days of 2 days in the admission.
* LEMO2**101983	shares the same dates of admission and the same centre, but the type of plan changes. Both do not have a date of discharge.
* ALOL1**101981	have a clear transition from being one day into a treatment for one day that he abandoned and was not considered a program of SENDA. Then he went to a treatment and did not left it until the day the dataset was retrieved.
* Different is the case of DAAS2**091996: both treatments share the date of admission, but she was admitted in a treatment for 5 days that overlapped the next treatment. Although, this treatment was not considered as a SENDA program.
* VAPR2**041981	have two programs with the same date of admission in the same center. Both programs are financed by SENDA but have different plans.
* GAPE1**121980 registries	were obtained from the same yearly dataset, and share the date of admission and center, but not the date of discharge. Both are financed by SENDA.
* JOSE1**121964	registries were obtained from the same yearly dataset, and share the date of admission and center, but not the date of discharge and plan of treatment. All are financed by SENDA.
* ALNU1**051977 share the same date of admission but not the date of discharge.	Do not share the same treatment plan. It shows more days in treatment in a program not financed by SENDA.
* ALNE1**101974	registries were obtained from the same yearly dataset, and share the date of admission and center, but not the plan and the date of discharge.
* PAGA2**121972	registries were obtained from the same yearly dataset, and share the same date of admission. but not the same date of discharge or type of plan.
* BACA1**011979	share the same date of admission but different center and date of discharge, both labelled as therapeutic discharge as a cause of discharge.
* CLCA2**051976	have a difference of threee days in the date of admission between two treatments in different centers.
* CLTO2**101979	share the same date of admission, but one of the treatments only lasted 6 days, being derived into the second one.
* LUCA1**051994	have a clear transition from being two days in a treatment in one center to another.
* MEGU2**121979	have a diference of two days in the date of admission in their treatments, and different dates of discharge and plans of their treatments.
* MIOY1**031990 have a difference of two days in the date of admission in their treatments, and do not share center or date of discharge.
* MOVA1**041983	registries were obtained from the same yearly dataset, have a difference of five days between the different dates of admission, both treatments overlapping by three days. Thet have different plans of treatment and center.
* PAHE1**111981	have a difference of three days in the date of admission with a program of 0 days posterior to the first admission. Also they have different plans of treatment and center.
* ROMA1**011979	registries were obtained from the same yearly dataset, but their dates of admission are different by one day, and centers and dates of discharge are different. Only one of the programs is financed by SENDA.
* YAPO2**121989	registries were obtained from the same yearly dataset and share the same date of admission and date of discharge, but not the same center, being one of them not financed by SENDA.

<br>

```{r saving dates_w_o_discharge_date, echo=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020 %>%
dplyr::filter(row %in% c(149670,142875,8809,6864,151245,145140,160070,160066,135212,135017,85501,44753,41263,32299,12180,8809,14057,12517,14057
,8752, 8013, 13040,6202,8799,6334,5571,2319,5530,3865,71542,54760,66467,46349,66785,54953,90796,83766,67549,58436,54973,47284,73114,72579,51619,45002,61572,61353,52659,54383)) %>% 
  dplyr::arrange(factor(row, levels = c(149670,142875,8809,6864,12180,151245,145140,160070,160066,135212,135017,85501,44753,41263,32299,14057,12517,8752,8013,13040,6202,8799,6334,5571,2319,5530,3865,71542,54760,66467,46349,66785,54953,90796,83766,67549,58436,54973,47284,73114,72579,51619,45002,61572,61353,52659,54383))) %>%
  dplyr::select(row,HASH_KEY, ano_bd, id_mod,Edad,Sexo,Nombre.Centro,ID.centro,fech_ing,fech_egres,dias_trat,motivodeegreso,tipo_de_programa,tipo_de_plan,SENDA) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               col.names= c("Row", "HASH_KEY", "Year of\nDataset", "ID","Year", "Sex", "Name of\nthe Center", "Center ID", "Date of\nAdmission", "Date of\n Discharge", "Treatment Days", "Cause of\nDischarge", "Type of\nProgram", "Type of\nplan", "SENDA\nProgram"),
                   caption="Table 18. Example of probabilistic matches", align =rep('c', 101)) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8)  %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```
&nbsp;
<br>

## 6. Preliminary Summary in January 2020

Many selections for the purposes of the study are still being necessary until today, in order to  keep the greater amount of information about each event. 

```{r image-ref-for-in-text, echo=T, fig.align='center', message=FALSE}
knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/Figure_Duplicates.svg")
```

<!--- SÍ O SÍ, HACER LA LIMPIEZA DE LOS SENDA NO, PRINCIPALMENTE DE LOS QUE SE SUPERPONGAN, TAMBIÉN PREGUNTAR A ACC SI LOS CON 0 DÍAS DE TRATAMIENTO SE BORRARÁN O NO; DE AHI EMPEZAR A NORMALIZAR LOS PROGRAMAS Y PLANES DE ACUERDO CON CRITERIOS MAUREEN, PARA NO GENERAR DIFERENCIAS AHI Y PODER DEDUPLICAR TRANQUILO --->

<!--- tipo_centro, convertir en factor 1. Privado, 2. Público; DataExplorer::create_report(CONS_1_4)  --->
