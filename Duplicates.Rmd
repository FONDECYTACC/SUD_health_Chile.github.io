---
title: "Duplicated/ Repeated Cases in SISTRAT C1"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide  
    toc: true # table of content true
    toc_depth: 5  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
---

<style type="text/css">
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid black;
        }
.centrado {
    text-align: center;
}
.table.center {
    margin-left:auto; 
    margin-right:auto;
  }
.table_wrapper{
    display: block;
    overflow-x: auto;
    white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
      text-align: justify;
  }
.superbigimage{
    overflow-y:scroll;
    white-space: nowrap;
}
.superbigimage img{
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px; text-align: justify;}
</style>

```{r prev, include=FALSE, cache=T}
rm(list=ls());gc()
unlink('SUD_CL/Duplicates_cache', recursive = TRUE)
unlink('Duplicates--UMAYOR-_cache', recursive = TRUE)
```

```{r load, include=FALSE, cache=T}
#setwd("H:/sud_cl/")
load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/1.Rdata")
if(!require(dplyr)){install.packages("dplyr")}
if(!require(data.table)){install.packages("data.table")}
require(data.table)
require(dplyr)
CONS_C1_df%>%
  dplyr::mutate(fech_ing_ano = lubridate::year(fech_ing), 
                fech_ing_mes = lubridate::month(fech_ing), 
                fech_ing_dia = lubridate::day(fech_ing)) %>%
  dplyr::mutate(concat=paste0(HASH_KEY,"_",fech_ing_ano,"_",fech_ing_mes,"_",fech_ing_dia)) %>%
  dplyr::mutate(duplicated_HASH_date = duplicated(concat)) %>%
  as.data.table() %>%
  assign("CONS_C1_df_dup",.,envir = .GlobalEnv)
#45526 trues
```

```{r setup, include = FALSE, cache=T}
#Libraries used in the routine. Dont change the order
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})
copiar_nombres <- function(x,row.names=FALSE,col.names=TRUE,dec=",",...) {
  if(class(ungroup(x))[1]=="tbl_df"){
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)    
        }
  } else {
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)       
  }
 }
}  

#https://github.com/RevolutionAnalytics/checkpoint
if(!require(checkpoint)){install.packages("checkpoint")}
if(!require(here)){install.packages("here")}

#checkpoint::checkpoint("2020-02-11",project=here::here(),checkpointLocation=paste0(here::here(),"/Duplicates"), use.lock=F, use.knitr=T, auto.install.knitr = T,scan.rnw.with.knitr=T, forceInstall=T,scanForPackages = TRUE)
#checkpointArchives(tempdir(), full.names = TRUE)
#getOption("repos")
#normalizePath(.libPaths(), winslash = "/")
#installed.packages(.libPaths()[1])[, "Package"]
#unCheckpoint()
#.libPaths()
if(!require(knitr)){install.packages("knitr")}
if(!require(tidyr)){install.packages("tidyr")}
if(!require(janitor)){install.packages("janitor")}
if(!require(stringi)){install.packages("stringi")}
if(!require(stringr)){install.packages("stringr")}
if(!require(ggplot2)){install.packages("ggplot2")}
if(!require(Hmisc)){install.packages("Hmisc")}
if(!require(kableExtra)){install.packages("kableExtra")}
if(!require(lubridate)){install.packages("lubridate")}
if(!require(rbokeh)){install.packages("rbokeh")}
if(!require(altair)){install.packages("altair")}
if(!require(zoo)){install.packages("zoo")}
if(!require(codebook)){install.packages("codebook")}
if(!require(broom)){install.packages("broom")}
if(!require(sqldf)){install.packages("sqldf")} 
if(!require(devtools)){install.packages("devtools")}
if(!require(Statamarkdown)){install_github("hemken/Statamarkdown", quiet=T,  upgrade="never")}
if(!require(haven)){install.packages("haven")}
if(!require(glue)){install.packages("glue")}
if(!require(ggiraph)){install.packages("ggiraph")}
if(!require(ggiraphExtra)){install.packages("plotly")}
if(!require(data.table)){install.packages("data.table")}
if(!require(dplyr)){install.packages("dplyr")}
if(!require(tidylog)){install.packages("tidylog")}
if(!require(radiant)){install.packages("radiant", repos = "https://radiant-rstats.github.io/minicran/")}
if(!require(neuralnet)){install.packages("neuralnet")}
if(!require(radiant.update)){install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")}
#install.packages( repos = "https://radiant-rstats.github.io/minicran/")
#install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")
tryCatch(source("https://raw.githubusercontent.com/radiant-rstats/minicran/gh-pages/update.R"), error = function(e) print("updated package, radiant"))
#radiant::update_radiant()
```
<br>

To  assess the main goals of the study, we focused on **distinguishing each user** throughout the yearly datasets obtained from SENDA (1); then **separate each treatment of each user** (2). Finally, **normalize, standardize, and clean each treatment** (3). These stages may be conceptually separated and sequential, but interdependent (e.g., we needed to standardize some variables to detect duplicated entries). 

<br>

In this page, we use the terms “rows” and “cases” as equal to refer to the entries of the dataset.

<br>

## 1. Drop duplicated entries

&nbsp;
<br>
Many treatments lasts more than one year. Hence, entries may come from different yearly datasets but refer to the same treatment. We detected duplicated rows in almost every variable, excepting the row number of the entry in the whole consolidated dataset, and the year of the dataset of retrieval.

<br>

```{r tab1, echo=T, cache=T, paged.print=TRUE}
#create vector with variable names
names_c1 <- names(CONS_C1_df_dup[,c(3,5:106)])
#Group by duplicated rows 
as.data.table(CONS_C1_df_dup)[, dup_todo := .N, by = names_c1] %>%
  data.table::as.data.table() %>%
  assign("CONS_C1_df_dup_ENE_2020_prev",.,envir = .GlobalEnv)
#summarise duplicates and times
as.data.table(CONS_C1_df_dup)[, dup_todo := .N, by = names_c1] %>%
  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd)) %>%
  dplyr::group_by(dup_todo) %>%
  dplyr::summarise(n()) %>%
  data.frame() %>%
  dplyr::rename("Times present in Dataset"=dup_todo, "Number of Rows"=`n..`) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 1. Duplicated cases in almost every variable",
                 align ="cccc")  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 10)
```

```{r dataset_creation, echo=T, warning=FALSE, cache=T, paged.print=TRUE}
data.table::data.table(CONS_C1_df_dup_ENE_2020_prev) %>%
  dplyr::arrange(desc(ano_bd)) %>%
  dplyr::mutate(OBS=case_when(dup_todo>1 ~ "1.1. Duplicated Cases in Almost Every Variable", 
                              TRUE ~ "")) %>%
  #dplyr::distinct_(.dots = names_c1, .keep_all = TRUE) %>%
  dplyr::distinct_at(.vars=names_c1, .keep_all = TRUE) %>%
  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd), desc(fech_egres)) %>%
  data.table::as.data.table() %>%
  assign("CONS_C1_df_dup_ENE_2020_prev",.,envir = .GlobalEnv)
#Unlike base sorting with sort(), NA are: always sorted to the end for local data, even when wrapped with desc().
```

<br>

Since these duplicated rows contained the same values, **we do not lose additional information if we delete these rows**. Therefore, we selected only `r formatC(nrow(CONS_C1_df_dup), format="f", big.mark=",", digits=0)` rows of the original `r formatC(nrow(CONS_C1_df_dup_ENE_2020_prev), format="f", big.mark=",", digits=0)` cases.

<br>

We still needed to identify which of the repeated treatments has more recent information regarding a specific treatment. Hence, we eliminated duplicated rows but **kept events with more days of treatment, or from a more recent yearly dataset**. But how can we do it in some cases with negative days of treatment? Table 2 shows HASHs with some entries with negative days of treatment. **It was necessary to clarify some dates to avoid overlap between treatments. As can be seen in Table 2, it is possible to replace a few with an event with similar dates, but others were declared as missing and would be imputed once the dataset is normalized**.

<br>

```{r tab2_neg_treat_days, echo=T, paged.print=TRUE, message=F}
require(dplyr)
require(data.table)
HASHS_of_negtive_days_treat <- CONS_C1_df_dup_ENE_2020_prev %>% 
  dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), fech_egres_num= as.numeric(as.Date(fech_egres)),discharge_before_treatment=fech_egres_num-fech_ing_num) %>%
  dplyr::filter(discharge_before_treatment<0) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, dias_trat, SENDA) %>% dplyr::distinct(HASH_KEY)
#
CONS_C1_df_dup_ENE_2020_prev %>% 
    dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(HASHS_of_negtive_days_treat)))))) %>%
    dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd)) %>%
    dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, dias_trat, SENDA) %>% 
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 2 Negative days of treatment", align =rep('c', 101)) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::add_footnote( c("Assuming the date of retrieval, 2019-11-13"), notation = "none") %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>

The second stage required to **eliminate rows that contained duplicated values in some variables related to treatments and drug-use**. The following were selected:

- HASH Key (HASH_KEY)
- date of admission (fech_ing)
- Type of Center (tipo_centro)
- Center ID (ID.centro)
- Type of Program (Tipo.de.Programa)
- Type of Plan (Tipo.de.Plan)
- SENDA program (SENDA)
- Main Substance of Consumption (Sustancia.Principal)
- Other Substances (first, second, and third) (Otras.Sustancias.)
- Frequency of Consumption of the Main Substance (Frecuencia.de.Consumo..Sustancia.Principal)
- Starting Substance (Sustancia.de.Inicio) 
- Age of Onset of Drug Use (Edad.Inicio.Consumo)

<br>

Additionally, we ordered the data by the inverse of the year of the dataset (more recent), inverse of the date of admission, the inverse of the date of discharge, and the inverse of the date of treatment (but treating negative treatment days as 0).

<br>

```{r dataset_iteration1, echo=T, paged.print=TRUE, cache=T, warning=F, message=F}
require(data.table)
names_c1_stage2 <- c("HASH_KEY","fech_ing", "tipo_centro", "ID.centro", "Tipo.de.Programa", "Tipo.de.Plan", "SENDA", "Sustancia.Principal", "Otras.Sustancias.nº1","Otras.Sustancias.nº2","Otras.Sustancias.nº3", "Frecuencia.de.Consumo..Sustancia.Principal.","Sustancia.de.Inicio", "Edad.Inicio.Consumo")
#genero una lista de los casos que tienen algún tipo de duplicados.
dup_partes<-data.table::as.data.table(CONS_C1_df_dup_ENE_2020_prev)[, dup_partes := .N, by = names_c1_stage2]%>%dplyr::filter(dup_partes>1) %>% distinct(row)

#40 missing treatment days
#CONS_C1_df_dup_ENE_2020_prev %>%
#  dplyr::filter(is.na(fech_egres), !is.na(dias_trat)) %>% nrow()

#9394 missing dates of discharge
#CONS_C1_df_dup_ENE_2020_prev %>%
#  dplyr::filter(is.na(fech_egres), !is.na(dias_trat)) %>% nrow()

require(dplyr)
data.table::data.table(CONS_C1_df_dup_ENE_2020_prev) %>%
  #A VECES DA UN ERROR INEXPLICABLE DE QUE NO ENCUENTRA OBS, EN ESE CASO, BORRAR CACHÉ, CORRER LA PARTE DE PREV2 DE NUEVO Y VER QUÉ PASA
  dplyr::mutate(OBS=case_when(dias_trat<0 ~ glue::glue("{OBS};1.2. Negative Days of Treatment, Changed Date of Discharge"),
                              TRUE ~ OBS))%>% # APLICADO EN ABRIL 2020, PARA HACER UN CONTROL A LOS CASOS EXTRAÑOS
  #dplyr::mutate(fech_egres=case_when(dias_trat<0 ~ NA,
  #                                   TRUE ~ as.character(fech_egres)))%>% 
  # APLICADO EN ABRIL 2020, AL VER QUE 9 CASOS FUERON OBVIADOS. CORREGIDO NUEVAMENTE, BORRABA CASOS. Posteriormente tuve que volver a corregirlo.
  dplyr::mutate(fech_egres=if_else(dias_trat>=0,as.character(fech_egres),"",missing=as.character(fech_egres)))%>%
  dplyr::mutate(fech_egres=lubridate::parse_date_time(fech_egres, c("%Y-%m-%d"),exact=T))%>%
  dplyr::mutate(dias_trat=if_else(!is.na(fech_egres), as.numeric(difftime(fech_egres,fech_ing, units="days")),as.numeric(dias_trat)))%>%
  dplyr::mutate(dias_trat=ifelse(is.na(fech_egres)&dias_trat==0,NA,dias_trat))%>%
  dplyr::mutate(dias_trat=ifelse(as.numeric(dias_trat)<0,NA,as.numeric(dias_trat)))%>%
  dplyr::mutate(dias_trat_inv=ifelse(dias_trat<0,0,dias_trat*-1))%>% #transforma los erroneos en 0
  #dplyr::group_by(dias_trat_inv) %>%summarise(n()) %>% View() para probarlo
  #INCORPORADO EN ABRIL 2020, PARA PESQUISAR CASOS DEDUPLICADOS
  dplyr::arrange(desc(ano_bd),HASH_KEY, desc(fech_ing), dias_trat_inv) %>% ##ABRIL 2020, SAQUÉ FECHA DE EGRESO COMO ORDENADOR
# dplyr::filter(row %in% as.character(as.vector(unlist(as.data.table(unlist(dup_partes))))))
  dplyr::mutate(OBS=case_when(row %in% as.character(as.vector(unlist(as.data.table(unlist(dup_partes))))) ~ paste0(as.character(OBS),";","1.3. Duplicated Cases In Treatment and Substance Use Characteristics"), 
                              TRUE ~ as.character(OBS))) %>%
  #dplyr::distinct_(.dots = names_c1_stage2, .keep_all = TRUE) %>%
  dplyr::distinct_at(.vars=names_c1_stage2, .keep_all = TRUE) %>%
# dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd)) %>%
  data.table::as.data.table() %>% #para contar las filas
# dplyr::select(row) %>%  summarise(mean(row), sd(row)) #, lo mismo que en STATA. Se supone que una row es sensible a cambios distintos.
  assign("CONS_C1_df_dup_ENE_2020_prev2",.,envir = .GlobalEnv)

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#VER CASOS PERDIDOS POR LA NORMALIZACION DE FECHAS
#CONS_C1_df_dup_ENE_2020_prev2%>%
#    dplyr::filter(!is.na(fech_egres_sin_fmt),is.na(fech_egres))%>%
#    dplyr::select(row, HASH_KEY, fech_ing, fech_egres, fech_egres_sin_fmt,dias_trat)
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

#Lo mismo que en STATA: Ahora hay 118,121. Una vez que introduje 
#  dplyr::arrange(HASH_KEY, fech_ing, desc(ano_bd), desc(fech_egres)) %>% criterio anterior
```
<br>

A total of `r formatC(nrow(CONS_C1_df_dup_ENE_2020_prev2), format="f", big.mark=",", digits=0)` cases were selected. **Still, most of these variables were not standardized, so maybe there would be more duplicated cases once this process is done**. Of them, `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(hash_rut_completo!="") %>% nrow()` had an alternative HASH key if the first HASH does not match any of the HASHs of other datasets  (For more information about this process, visit the [encryption phase](https://fondecytacc.github.io/SUD_health_Chile.github.io/Encript.html)). 

```{r tab3, echo=T, paged.print=TRUE}
#Cases by year.
CONS_C1_df_dup_ENE_2020_prev2 %>% 
      dplyr::group_by(ano_bd) %>% 
      dplyr::tally() %>%
      as.data.frame() %>%
      dplyr::mutate(ano_bd=as.numeric(ano_bd)) %>%
      assign("cant_ano",., envir = .GlobalEnv)
CONS_C1_df_dup_ENE_2020_prev2 %>% 
  dplyr::group_by(ano_bd) %>% 
  distinct(HASH_KEY) %>% 
  dplyr::summarize(n=n()) %>% 
  dplyr::mutate(ano_bd= as.numeric(ano_bd)) %>%
  dplyr::left_join(cant_ano,by="ano_bd") %>% 
  mutate(dif=`n.y`-`n.x`, "%"=paste0(round(100 * dif/`n.y`, 1), "%")) %>%
  dplyr::rename("Year"=ano_bd, "Unique HASHs"=n.x, "Total Cases"=n.y, "Diff."=dif) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 3. Differences between HASHs and unique HASHs by year",
                 align ="cccc")  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 10)

perc_total<-CONS_C1_df_dup_ENE_2020_prev2 %>% 
  dplyr::group_by(ano_bd) %>% 
  distinct(HASH_KEY) %>% 
  dplyr::summarize(n=n()) %>% 
  dplyr::mutate(ano_bd= as.numeric(ano_bd)) %>%
  dplyr::left_join(cant_ano,by="ano_bd") %>% 
  mutate(dif=`n.y`-`n.x`, "%"= dif/`n.y`) %>%
  summarise(mean(`%`))
```
<br>

In Table 3, we can see that, on average, around `r scales::percent(perc_total[[1]])` of HASHs appear more than one time per yearly datasets. This means that users could have more than one treatment over a year, or treatments may be duplicated within each yearly dataset.

&nbsp;

## 2. Identification of HASH-Keys and ID's from SENDA

&nbsp;

<div class = "blue">
**At this point, we did not know if the masked ID number generated by the application created by the informatic is effectively creating a valid number that lets us distinguish each user from each other**.
</div>

<br>

There were `r CONS_C1_df_dup_ENE_2020_prev2 %>%  dplyr::distinct(HASH_KEY, .keep_all = TRUE) %>% nrow()  %>% formatC(, format="f", big.mark=",", digits=0)` unique HASHs, and `r CONS_C1_df_dup_ENE_2020_prev2 %>%  dplyr::distinct(id, .keep_all = TRUE) %>% nrow()  %>% formatC(, format="f", big.mark=",", digits=0)` unique IDs. One option was to look at the consistency between two identifiers: SENDA’s ID (encryption of the ID, provided by SENDA) and the generated HASH Key by the informatics professional in the context of this research. Of the `r CONS_C1_df_dup_ENE_2020_prev2 %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)` cases, around `r CONS_C1_df_dup_ENE_2020_prev2 %>%  mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)` had a unique combination of SENDAs ID and HASH. Nonetheless, some cases showed more than one different HASH per ID or vice versa, **meaning that one of them could not be representing adequately the official identification number (RUT)**.

<br>

We found `r CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(HASH_KEY)) %>% dplyr::arrange(HASH_KEY) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` HASHs with duplicated ID's en each hash, which represents `r paste0(round((CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(HASH_KEY)) %>% dplyr::arrange(HASH_KEY) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow()/nrow(CONS_C1_df_dup_ENE_2020_prev2))*100,1),"%")` of the total cases. A great number that could mean that **HASH could be less likely to represent more than one user, compared to SENDAs ID.**

<br>

Instead, there were `r CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(id)) %>% dplyr::arrange(id) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` users with duplicated HASH's in each ID, which represents `r paste0(round((CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% dplyr::filter(duplicated(id)) %>% dplyr::arrange(id) %>%  dplyr::select(HASH_KEY,id,hash_rut_completo) %>% nrow()/ CONS_C1_df_dup_ENE_2020_prev2 %>% nrow())*100,1),"%")` of the total cases, as shown in Table 4.

<br>

```{r tab4_IDs w more than one hash, echo=T, paged.print=TRUE}
#Take which has a combination of IDs and HASH Keys distinct to the rest
#With this I may be subestimating the number of cases with a different concatenation.
#Considering all the distinct combinations, i take what they have a duplicate ID
#Select the duplicate IDs, it orders and...
#Filter only cases that has distinct id.
CONS_C1_df_dup_ENE_2020_prev2 %>% mutate(concat=paste0(id,"_",HASH_KEY)) %>% dplyr::distinct(concat, .keep_all = TRUE) %>% #once here, n° of cases has been replaced by distinct or unique combinations of IDs and HASH keys.
  dplyr::filter(duplicated(id)) %>% dplyr::arrange(id) %>%  #filter cases in which there is more than one ID, despite there is differents combinations of HASH and IDs, and then arrange IDs. This is possible only if a different HASH-Key contains more than one ID or viceversa.
  dplyr::distinct(id) %>% #take distincts IDs (exclude duplicated repeated IDs)
  assign("ids_more_one_hash",., envir = .GlobalEnv) # Differently put, take the distints IDs per HASH-Key, of the cases in which there are different combinations.
# of IDs and hash, and in which subgroup exists duplicated IDs.
 
#IMPORTANT: IF THE ID IS DUPLICATED, MIGHT NOT BE REFLECTED IN THIS RESUME IN TERMS OF QUANTITY.

# Then, apply these cases to the whole population
CONS_C1_df_dup_ENE_2020_prev2 %>%
dplyr::filter(id %in% as.character(as.vector(unlist(as.data.table(unlist(ids_more_one_hash)))))) %>% # Select IDs of cited cases
dplyr::arrange(id) %>% #ordeno por ids 
  #762 cases. 409 cases without duplicates.
      #dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101,-110,-11,-112) %>%
      dplyr::select(row, ano_bd, id_mod, HASH_KEY, hash_rut_completo ,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 4. Total cases that each ID have more than one HASH-KEY",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

&nbsp;

We expected to see repeated IDs due to the binding of yearly datasets and treatments that may appear in both years (possibly, because the treatment extended to the following years). A sum of `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::select(ano_bd,id,HASH_KEY) %>% dplyr::group_by(ano_bd,id) %>% tally() %>% dplyr::mutate(n_col=n) %>% dplyr::filter(n>1) %>% as.data.frame() %>% reshape::cast(.,ano_bd+id~n) %>% dplyr::arrange(ano_bd,id) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` SENDAs ID appears more than one time in each yearly dataset. Conversely, there were `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::select(ano_bd,id,HASH_KEY) %>% dplyr::group_by(ano_bd,HASH_KEY) %>% tally() %>%  dplyr::mutate(n_col=n) %>%  dplyr::filter(n>1) %>%   as.data.frame() %>%  reshape::cast(.,ano_bd+HASH_KEY~n) %>% dplyr::arrange(ano_bd, HASH_KEY) %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)` cases with more than one SENDA’s ID (could be different or repeated) by HASH in each yearly dataset.

<br>

For example, we can appreciate that an id like "MAMO108111971"contain different HASH_KEYs: `r  CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(id=="MAMO108111971") %>% dplyr::distinct(HASH_KEY) %>%  dplyr::filter(row_number()==1)` and `r  CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(id=="MAMO108111971") %>% dplyr::distinct(HASH_KEY) %>%  dplyr::filter(row_number()==2)`.

&nbsp;

```{r table5, echo=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020_prev2 %>% 
  dplyr::filter(id=="MASA124091985"|id=="NIAG108091996"|id=="JUGA108021973"|id=="MAMO108111971") %>%
  dplyr::arrange(id) %>%
      #dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101) %>%
      dplyr::select(row, ano_bd, id_mod,HASH_KEY, hash_rut_completo, fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 5. Examples of problematic IDs",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>

**UPDATE on January 30, 2020: According to indications from the professionals of SENDA, duplicated rows shown in Table 4 corresponded to different officials IDs (RUTs), meaning that different HASHs effectively represents different users, making it more reliable than SENDAs ID.**


## 3. Focus on Duplicated Cases and Dates of Admission

&nbsp;

**We needed to distinguish between duplicated cases and admissions from 2010 to 2019, so we could focus on ranges of dates of treatment within each user**. At this point, we had `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::group_by(HASH_KEY, fech_ing) %>% dplyr::mutate(rn=row_number(), dup2=max(rn)) %>% dplyr::filter(dup2>1) %>% nrow()` cases of users (HASHs) in treatments with an exact same date of admission throughout the dataset.

<br>

Additionally, as we deleted cases that we considered duplicated because they shared the same HASH and date of admission, some values could be missing and could be replaced by another entry within the dataset, as can be seen in Table 6.

```{r table6, echo=T, paged.print=TRUE, warning=F, message=F}
CONS_C1_df %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  #dplyr::filter(!row %in% as.character(as.vector(unlist(data.table::as.data.table(unlist(CONS_C1_df_dup_ENE_2020_prev2$row)))))) %>% # Select HASHs of cited cases
  assign("replace",.,envir=.GlobalEnv)
CONS_C1_df %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  dplyr::filter(!row %in% as.character(as.vector(unlist(data.table::as.data.table(unlist(CONS_C1_df_dup_ENE_2020_prev2$row)))))) %>% # Select HASHs of cited cases
  assign("replace_miss",.,envir=.GlobalEnv)

CONS_C1_df_dup_ENE_2020_prev2 %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  dplyr::filter(is.na(fech_egres)) %>%
  dplyr::left_join(dplyr::select(replace,hash_treat, fech_egres), "hash_treat") %>%
  dplyr::filter(!is.na(fech_egres.y)) -> replace_date_disch

CONS_C1_df_dup_ENE_2020_prev2 %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  dplyr::filter(is.na(dias_trat)|dias_trat<=0) %>%
  dplyr::left_join(dplyr::select(replace,hash_treat, dias_trat,fech_egres), "hash_treat") %>%
  dplyr::filter(dias_trat.y>0) -> replace_days_treat

CONS_C1_df_dup_ENE_2020_prev2 %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  dplyr::filter(is.na(motivodeegreso)) %>%
  dplyr::left_join(dplyr::select(replace,hash_treat, motivodeegreso), "hash_treat") %>%
  dplyr::filter(!is.na(motivodeegreso.y)) -> replace_caus_disch

CONS_C1_df_dup_ENE_2020_prev2 %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  dplyr::filter(is.na(fech_egres)) %>%
  dplyr::left_join(dplyr::select(replace_miss,hash_treat, fech_egres), "hash_treat") %>%
  dplyr::filter(!is.na(fech_egres.y)) -> replace_miss_date_disch

CONS_C1_df_dup_ENE_2020_prev2 %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  dplyr::filter(is.na(dias_trat)|dias_trat<=0) %>%
  dplyr::left_join(dplyr::select(replace_miss,hash_treat, dias_trat,fech_egres), "hash_treat") %>%
  dplyr::filter(dias_trat.y>0) -> replace_miss_days_treat

CONS_C1_df_dup_ENE_2020_prev2 %>%
  dplyr::mutate(hash_treat= paste0(HASH_KEY,"_",fech_ing)) %>%
  dplyr::filter(is.na(motivodeegreso)) %>%
  dplyr::left_join(dplyr::select(replace_miss,hash_treat, motivodeegreso), "hash_treat") %>%
  dplyr::filter(!is.na(motivodeegreso.y)) -> replace_miss_caus_disch


as.data.frame(cbind("Possible Replaces"=c("Date of Discharge", "Days of Treatment", "Cause of Discharge"), 
      "No. of Cases to Replace"=c(nrow(replace_days_treat),nrow(replace_days_treat),nrow(replace_caus_disch)),
      "No. of Cases to Replace \n From Discarded Data"=c(nrow(replace_miss_date_disch),nrow(replace_miss_days_treat),nrow(replace_miss_caus_disch)))) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 6. Possible Replaces from The Original Dataset", align =rep('c', 101)) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8)
#we saw that these values could not be replaced by the deleted cases
#Also,I made it with FEB 2020 Dataset, and none of the cases could be replaced posteriorly.

```

&nbsp;

Table 6 shows that values within the dataset could replace some missing values. Discarded values could only replace one case. **All of these cases were studied posteriorly**.

&nbsp;

## 4. Age in datasets

<br>

**The age is a unit-invariant variable that may contribute to standardize users, and subsequently distinguish treatments. At this point, we only had fuzzy criteria to separate between different admissions. That is why we need to adopt a casuistic approach to find duplicated treatments through [probabilistic deduplication](#6_exploratory_probabilistic_deduplication)**. We can find these strategies in the main [diagram of data preparation]( https://raw.githubusercontent.com/FONDECYTACC/SUD_health_Chile.github.io/master/Figures/RUT_Administraci%C3%B3n.svg). Nonetheless, **many cases had invalid ages** (n= `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18|Edad>90) %>% nrow() %>% formatC(, format="f", big.mark=",", digits=0)`). The first question is if we could **replace the missing ages from the dates of birth**.

<br>

Based on the meeting on Dec. 05 of 2019, one of the main challenges was to **check whether the age of birth is part of the last 4 numbers of each ID**.

<br>

```{r fig1_fecha_nac_edad, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F}
#plot(CONS_C1_df_dup_ENE_2020_prev2$ano_nac, CONS_C1_df_dup_ENE_2020_prev2$Edad, ylab="Age", xlab="Year of Birth")

#library(ggiraph)
#require(ggiraphExtra)
require(plotly)

#CONS_C1_df_dup_ENE_2020_prev2 %>%
#  dplyr::mutate(graph_info=paste("Row:", row, '<br>Year DB:', ano_bd)) %>%
# ggplot(data = ) +
#    geom_point_interactive(aes(x = ano_nac, y = Edad, color = ano_bd,
#    tooltip = graph_info, data_id = row)) + 
#  theme_minimal() -> gg_point 

#girafe(ggobj = gg_point)
plotly::plot_ly(CONS_C1_df_dup_ENE_2020_prev2,type="scatter", x = ~ano_nac, y = ~Edad, 
        text =  ~paste("Row: ", row, '<br>Year DB:', ano_bd),
        mode = "markers") %>% 
  layout(xaxis=list(title="Year of Birth"), 
      yaxis=list(title="Age"),
      title="Figure 1. Scatterplot of Year of Birth and Age")
```

<br>

As we can see in Figure 1, there is a clear relationship with a few residuals. If we regress the year of birth on age, we find that the intercept was `r coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[1] %>%  formatC(, format="f", big.mark=",", digits=2)`, and the slope was `r coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[2] %>%  formatC(, format="f", big.mark=",", digits=2)`. This intercept is equal to the date `r format(lubridate::date_decimal(coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[1]), "%Y-%m-%d")`. Once we add the slope, we get an approximate date of retrieval of `r as.character(format(lubridate::date_decimal(coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[1]-coef(lm(ano_nac ~Edad, data= CONS_C1_df_dup_ENE_2020_prev2))[2]), "%Y-%m-%d"))`. We identified the outliers, ending up with 3 cases in which the expected age and year of birth presented a difference greater than 1 year. Even so, some cases did not comply with this relationship.

<br>

```{r tab7_edad_fecha_nac, echo=T, paged.print=TRUE}
    CONS_C1_df_dup_ENE_2020_prev2 %>%
    dplyr::mutate(dif_edad=ano_nac-(2019-Edad)) %>%
      dplyr::filter(dif_edad!=0) %>%
      dplyr::arrange(desc(dif_edad)) %>%
      dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101) %>%
      dplyr::select(row, ano_bd, ano_nac, Edad, dif_edad,
                    HASH_KEY, hash_rut_completo, id_mod,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, 
                    ID.centro, everything()) %>%
      head() %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 7. Cases that have a different year of birth and age",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>

In Table 7, we can see the first 6 cases that had differences ordered by the magnitude of the difference. The rest of the `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::mutate(dif_edad=ano_nac-(2019-Edad)) %>% filter(dif_edad!=0) %>% nrow() %>% sum(-3) %>% formatC(, format="f", big.mark=",", digits=0)` had 12 months of difference. 

<br>

However, we may take account that there are `r paste0(round(CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18|Edad>90) %>% dplyr::summarise(n())/nrow(CONS_C1_df_dup_ENE_2020_prev2),3)*100,"%")` cases with invalid years, representing `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18) %>% dplyr::summarise(n()) %>% as.numeric() %>% formatC(, format="f", big.mark=",", digits=0)` cases with less than 18 years, and `r CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad>90) %>% dplyr::summarise(n()) %>% as.numeric() %>%  formatC(, format="f", big.mark=",", digits=0)` cases with more than 90 years. We might probably wonder **why we are getting invalid cases from the age at the date of retrieval, and not from the age at the time of admission; however, we replicated the rule applied by SENDAs professionals**. Additionally, many of the SENDAs IDs of these cases have the same values of the year and month of admission, as can be seen in Table 8:

<br>

```{r tab8_wrong_ages, echo=T, paged.print=TRUE}
  CONS_C1_df_dup_ENE_2020_prev2 %>% 
  dplyr::mutate(fech_nac=lubridate::parse_date_time(stringi::stri_sub(id,-8,-1),"dmY")) %>% 
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>% #AGREGADO EN APR 2020.
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>% #AGREGADO EN APR 2020.
  dplyr::select(row, HASH_KEY, id_mod, ano_nac, ano_bd,Edad,fech_ing,fech_nac, Edad_al_ing) %>%  #AGREGADO EN APR 2020.
  dplyr::filter(Edad<18|Edad>90) %>% 
  #dplyr::filter(Edad_al_ing<18|Edad_al_ing>90) %>% 
  #ACTUALIZACION A ABRIL 2020, SÓLO BAJA DE 445 A 444 CUANDO SELECCIONO POR EDAD DE INGRESO
  #nrow()
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 8. Cases that have a wrongly asigned age",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>

As advised at the beginning of this section, **these invalid values may condition the data linkage, given that if we assign a missing value to a user that in other registry has the correct age, cases that share the same HASH and date of admission won’t match within the block assigned**. To account for this possible bias, we checked whether with valid data of another case with the same HASH Key could replace missing or invalid ages (that is, the same user with another duplicated entry, or another treatment).

<br>

```{r tab9_wrong_ages_duplicates, echo=T,cache=T, paged.print=TRUE}
#list of distinct HASHs that have a wrongly assigned age
CONS_C1_df_dup_ENE_2020_prev2 %>% dplyr::filter(Edad<18|Edad>90) %>%
  dplyr::distinct(HASH_KEY) %>%
  assign("distinct_hash_wrong_age2",., envir = .GlobalEnv)

#Then, apply these cases to the whole population
CONS_C1_df_dup_ENE_2020_prev2 %>%
dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(distinct_hash_wrong_age2)))))) %>% # select hashs of wrongly assigned ages
dplyr::arrange(HASH_KEY) %>% #order by hashs 
  dplyr::filter(Edad>=18,Edad<=90) %>% #nrow() #if you want to see how many cases would be changed: 387.
  #dplyr::filter(!duplicated(HASH_KEY)) %>% nrow() # 211 DIFFERENT HASHS WERE CAPTURED.
      #dplyr::select(-id,-TABLE,-14,-16,-17,-26,-27,-28,-29,-35,-36,-37,-88,-93,-94,-96,-101) %>%
      dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,Edad, fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 9. Total cases with wrong ages but their HASH had a valid age along the dataset",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

```{r replace ages with users with other valid ages within  dataset, echo=T,cache=T, paged.print=TRUE}
#Capture every valid case distinct that has a valid age
CONS_C1_df_dup_age <- dplyr::select(CONS_C1_df, HASH_KEY, id, id_mod, Edad)%>% 
                      dplyr::filter(Edad>=18, Edad<=90) %>% #%>%  #dim rows 85490, 4 columns
                      dplyr::filter(!duplicated(HASH_KEY)) #lo mismo que  dplyr::distinct(HASH_KEY)
#Join datasets 
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev2,dplyr::select(CONS_C1_df_dup_age,HASH_KEY,Edad, id,id_mod), by = "HASH_KEY", suffix = c("", ".y")) %>% # dim()
  dplyr::mutate(OBS=case_when((Edad<18 & !is.na(Edad.y))|(Edad>90 & !is.na(Edad.y)) ~ paste0(OBS,";","1.4. Replaced invalid ages with same users within the dataset"), 
                              TRUE ~ OBS))%>%
    dplyr::mutate(id= ifelse((Edad<18 & !is.na(Edad.y))|(Edad>90 & !is.na(Edad.y)),id.y, id)) %>%
    dplyr::mutate(id_mod=ifelse((Edad<18 & !is.na(Edad.y))|(Edad>90 & !is.na(Edad.y)),id_mod.y,id_mod)) %>% 
    dplyr::mutate(Edad= ifelse(Edad<18|Edad>90,Edad.y, Edad)) %>% #treat as invalid
 dplyr::select(-id_mod.y, -id.y) %>%
    #dplyr::group_by(Edad) %>% summarise(n=n()) %>% View()
    assign("CONS_C1_df_dup_ENE_2020_prev3",., envir = .GlobalEnv) 
  #The modification of age must be in the end of the changes, so it does not affect the rest of variables
```

<br>

Considering that the age is a time-invariant variable, we identified the date of admission and the HASH Key. We found similar matches, leading to `r CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(Edad<18, Edad>90) %>% nrow()` invalid values in age (<18 or >90), but `r CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(is.na(Edad)) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` missing values with `r CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(is.na(Edad)) %>% distinct(HASH_KEY) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` different HASH keys.

<br>

```{r tab10_invalid values in age, echo=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020_prev3 %>% 
  dplyr::filter(is.na(Edad)) %>% 
  arrange(HASH_KEY) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, SENDA) %>%
 knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 10. Missing Ages among Users with Wrong Dates of Birth",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```
<br>

Table 10 shows users that do not present any other valid age throughout different cases. **Is it possible that some of these users could be present in another SENDAs dataset with a valid age?**, we checked into the Treatment Outcomes Profile dataset (more information on this dataset is available [here](https://fondecytacc.github.io/SUD_health_Chile.github.io/Data_prep_TOP)).

<br>

```{r invalid values in age replaced in TOP, echo=T, cache=T, paged.print=TRUE}
CONS_TOP_df_dup_age <- dplyr::select(CONS_TOP, HASH_KEY, ID, Sexo, Edad)%>% 
  dplyr::filter(Edad>=18, Edad<=90) %>% #%>%  #dim rowa 162449, 4 columns
  dplyr::mutate(id_mod=sub("(.{5}).", "\\1*",ID)) %>%
  dplyr::mutate(id_mod=sub("(.{6}).", "\\1*",id_mod)) %>%
  dplyr::mutate(id=ID) %>%
  dplyr::filter(!duplicated(HASH_KEY)) #dplyr::distinct(HASH_KEY) %>% nrow() #37124 rows, 5 columns
#merge datasets w CONS C1

replaceable<- CONS_C1_df_dup_ENE_2020_prev3  %>% 
      dplyr::filter(is.na(Edad)) %>% 
      arrange(HASH_KEY) %>%
      dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, SENDA) %>%
      dplyr::left_join(CONS_TOP_df_dup_age, by="HASH_KEY", suffix= c(".C1",".TOP")) %>%
      dplyr::filter(!is.na(id_mod.TOP)) 

CONS_C1_df_dup_ENE_2020_prev3  %>% 
  dplyr::filter(is.na(Edad)) %>% 
  arrange(HASH_KEY) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad, SENDA) %>%
  dplyr::left_join(CONS_TOP_df_dup_age, by="HASH_KEY", suffix= c(".C1",".TOP")) %>%
  dplyr::filter(!is.na(id_mod.TOP)) %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod.C1, ano_nac, ano_bd,fech_ing, fech_egres,tipo_de_plan, tipo_de_programa, ID.centro, Edad.C1, Edad.TOP,SENDA, id_mod.TOP) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 11. Replaced Ages from TOP dataset",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 9) %>%
  kableExtra::scroll_box(width = "100%", height = "175px")
```

```{r previous assignment, echo=T,cache=T, paged.print=TRUE}
#Join datasets 
CONS_TOP_df_dup_age <- dplyr::select(CONS_TOP, HASH_KEY, ID, Sexo, Edad)%>% 
  dplyr::filter(Edad>=18, Edad<=90) %>% #%>%  #dim rowa 162449, 4 columns
  dplyr::mutate(id_mod=sub("(.{5}).", "\\1*",ID)) %>%
  dplyr::mutate(id_mod=sub("(.{6}).", "\\1*",id_mod)) %>%
  dplyr::mutate(id=ID) %>%
  dplyr::filter(!duplicated(HASH_KEY)) %>%
  dplyr::select(-ID)
#CONS_C1_df_dup_ENE_2020_prev3 %>% group_by(Edad) %>% summarise() %>% View() #son puros NA's

  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev3, CONS_TOP_df_dup_age, by="HASH_KEY", suffix= c("",".TOP")) %>%
    #dplyr::mutate(Edad_error=Edad) %>%
  dplyr::mutate(OBS=case_when((is.na(Edad) & !is.na(id.TOP))~paste0(OBS,";","1.5. Replaced invalid ages with TOP information"),
                              TRUE ~ OBS))%>%
    dplyr::mutate(id= ifelse(is.na(Edad) & !is.na(id.TOP),id.TOP, id)) %>%
    dplyr::mutate(id_mod=ifelse(is.na(Edad) & !is.na(id_mod.TOP),id_mod.TOP,id_mod)) %>% 
    dplyr::mutate(Edad= ifelse(is.na(Edad) & !is.na(Edad.TOP),Edad.TOP, Edad)) %>%
    dplyr::mutate(fech_nac=lubridate::parse_date_time(stringi::stri_sub(id,-8,-1),"dmY")) %>% 
    #dplyr::mutate(Edad_fech_nac= lubridate::time_length(difftime(as.Date("2019-11-13"),as.Date(fech_nac)),"years")) %>%
    dplyr::mutate(fech_nac=replace(fech_nac, is.na(Edad), NA)) %>% #LA EDAD ESTA MALA PORQUE LA FECHA DE NAC ESTÁ MALA
    dplyr::mutate(ano_nac=replace(ano_nac, is.na(Edad), NA)) %>% #LA EDAD ESTA MALA PORQUE LA FECHA DE NAC ESTÁ MALA
    dplyr::select(-id_mod.TOP, -duplicated_HASH_date, -Edad.y, -Sexo.TOP, -Edad.TOP, -id.TOP) %>%  
    #dplyr::group_by(Edad) %>% summarise(n=n()) %>% View()
    as.data.frame() %>%
    assign("CONS_C1_df_dup_ENE_2020_prev4",., envir = .GlobalEnv) 
#PARA VER CÓMO SE COMPORTA CON IS.NA
  #CONS_C1_df_dup_ENE_2020_prev4 %>% dplyr::filter(is.na(Edad_error)) %>% dplyr::filter(!is.na(ID))
#CONS_C1_df_dup_ENE_2020 %>% dplyr::select(HASH_KEY, ano_bd, id, fech_ing, Edad_al_ing, fech_nac, Edad) %>%
  #dplyr::mutate(ano=as.numeric(fech_nac)/365.25) %>% dplyr::filter(is.na(Edad)) %>% View()
#CONS_C1_df_dup_ENE_2020_prev4 %>%
  #dplyr::filter(HASH_KEY=="17427b747a8e5d8ecdcdec6a781a277b"|HASH_KEY=="636046ed13f419997e2c05bfd3ac6ae6") %>%
  #print()
  #rows 57716 9972 6736, están perdidos en las bases de datos.
```
<br>

As can be seen in Table 11, only `r nrow(replaceable)` cases could replace invalid ages from valid entries in the TOP dataset.

<br>

Still, **to group cases of the same user within the same block by age, we must pay attention to all the HASHs that have more than one age**. Among them, there are `r CONS_C1_df_dup_ENE_2020_prev4 %>% dplyr::group_by(HASH_KEY,Edad) %>% dplyr::count() %>% dplyr::filter(n>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)` different HASHs with more than one age. Possibly, some datasets were retrieved at different dates than others from the SENDA system.
    
<br>

```{r tab12_hash_w_more_one_age, echo=T, cache=T, paged.print=TRUE}
 #mÁS DE UNA EDAD POR HASH
CONS_C1_df_dup_ENE_2020_prev4 %>% dplyr::mutate(concat_hash_edad=paste0(HASH_KEY,"_",Edad)) %>% 
  dplyr::distinct(concat_hash_edad, .keep_all = TRUE) %>% 
 #once here, n° of cases has been replaced by distinct or unique combinations of age and HASH keys.
 dplyr::filter(duplicated(HASH_KEY)) %>% dplyr::arrange(HASH_KEY) %>%  #filter cases in which there is more than one age, 
 #despite there is differents combinations of HASH and age, and then arrange age. This is possible only if a different HASH-Key contains more than one age or viceversa.
 #take distincts ages (exclude duplicated repeated IDs)
 #  dplyr::distinct(HASH_KEY) %>% nrow()
  dplyr::select(HASH_KEY) %>%
 assign("more_one_age_per_hash",., envir = .GlobalEnv)
# Differently put, take the distints HASHs per HASH-Key & ages, of the cases in which there are different combinations
# of ages and HASHs, and in each subgroup exists duplicated HASHs.

CONS_C1_df_dup_ENE_2020_prev4 %>% 
 dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(more_one_age_per_hash)))))) %>% # Select HASHs of cited cases
 dplyr::arrange(HASH_KEY) %>% #ordeno por ids 
dplyr::select(row, ano_bd, id_mod, fech_nac, Edad, HASH_KEY, hash_rut_completo, sexo, fech_ing, fech_egres, tipo_de_plan, SENDA)%>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption="Table 12. HASHs with more than one Age",
                 align =rep('c', 101))  %>%
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::scroll_box(width = "100%", height = "375px")

#debo reemplazar a fech_nac, id, id_mod, Edad_al_ing, 
  
#    dplyr::select(Edad,HASH_KEY) %>% 
#  dplyr::group_by(HASH_KEY,Edad) %>% tally() %>%  dplyr::mutate(n_col=n) %>%  dplyr::filter(n>1) %>%   as.data.frame() %>%  #reshape::cast(.,Edad+HASH_KEY~n) %>% dplyr::arrange(Edad, HASH_KEY)
```

<br>

From Table 12, we can see some users with different ages because the age is obtained by the difference between the date of birth and the date of retrieval of each yearly dataset. This factor adds some variability among users (let’s say, differences of a few days may traduce in differences of age, depending the date of retrieval of the yearly dataset). Other differences in ages within HASHs could be caused by mistyping in the registry, or other reasons not related to the process of retrieval. The best way to tackle this problem is to replace birth dates of users that have more than one different date.

<br>

Must take note that many variables that may change among individuals can be duplicated per HASH. These are the individual variables that may change share more than one HASH.

- Age of Onset of Drug Use (edad_ini_cons) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(edad_ini_cons_por_hash=n_distinct(Edad.Inicio.Consumo)) %>% ungroup() %>% dplyr::filter(edad_ini_cons_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Age of Onset of Drug Use Principal Substance (edad_ini_sus_prin) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(edad_ini_sus_prin_por_hash=n_distinct(Edad.Inicio..Sustancia.Principal.)) %>% ungroup() %>% dplyr::filter(edad_ini_sus_prin_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Year of Birth (ano_nac) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(ano_nac_por_hash=n_distinct(ano_nac)) %>% ungroup() %>% dplyr::filter(ano_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Date of Birth (fech_nac) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(fech_nac_por_hash=n_distinct(fech_nac)) %>% ungroup() %>% dplyr::filter(fech_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Starting Substance (sus_ini)  (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(sus_ini_por_hash=n_distinct(Sustancia.de.Inicio)) %>% ungroup() %>% dplyr::filter(sus_ini_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Sex (sexo) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(sexo_por_hash=n_distinct(sexo)) %>% ungroup() %>% dplyr::filter(sexo_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Age (Edad) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(Edad_por_hash=n_distinct(Edad)) %>% ungroup() %>% dplyr::filter(Edad_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Ethnicity (Etnia) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(Etnia_por_hash=n_distinct(Etnia)) %>% ungroup() %>% dplyr::filter(Etnia_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Nationality (Nacionalidad) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(Nacionalidad_por_hash=n_distinct(Nacionalidad)) %>% ungroup() %>% dplyr::filter(Nacionalidad_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- SENDAs ID (id) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_por_hash=n_distinct(id)) %>% ungroup() %>% dplyr::filter(id_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Masked SENDAs ID (id_mod) (`r CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_mod_por_hash=n_distinct(id_mod)) %>% ungroup() %>% dplyr::filter(id_mod_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)

<!--- CONS_C1_df_dup_ENE_2020_prev4 %>%
    dplyr::group_by(HASH_KEY) %>% mutate(mas_id=n_distinct(id)) %>% dplyr::filter(mas_id>1)
--> 

###4.1.Rule-based solution to inconsistent dates of birth

<br>

In this stage, we changed the age, SENDAs ID, year of birth, and date of birth, but not changing any other variables not related to age. The main reason is that these variables come from a specific date of birth, that in this case, is duplicated.**The rest of the variables may be subject to an analysis that should take into account other logical inconsistencies that may we may resolve once data is deduplicated**.

<br>

```{r fig2_dec_tree_disc_dup_birthdate, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F,fig.cap="Figure 2a. Decision Tree for the Discard of Duplicated Date of Birth by User"}
#plot(CONS_C1_df_dup_ENE_2020_prev2$ano_nac, CONS_C1_df_dup_ENE_2020_prev2$Edad, ylab="Age", xlab="Year of Birth")
knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/Fig2_Date of Birth.svg")
```

<br>

First, we aimed to define a unique date of birth for each user, using the following criteria: recent database, most frequent values, and in the third place, how valid that value was. Additionally, we aimed to reduce the ties in dates of birth following the abovementioned criteria.

```{r date_of_birth_rule_based_replacement1, echo=T,cache=T, paged.print=TRUE}
#CONS_C1_df_dup_ENE_2020_prev4_edad <- CONS_C1_df_dup_ENE_2020_prev4 %>% group_by(HASH_KEY) %>% dplyr::mutate(edad_por_hash=n_distinct(Edad)) %>% ungroup() %>% dplyr::filter(edad_por_hash>1) %>% dplyr::distinct(HASH_KEY) %>% unlist() %>% as.character()

invisible_edad_fecha_nac=1
if (invisible_edad_fecha_nac==0){
  janitor::tabyl(is.na(CONS_C1_df_dup_ENE_2020_prev4$fech_nac),is.na(CONS_C1_df_dup_ENE_2020_prev4$Edad))
  #por lo visto tienen la misma cantidad de perdidos. No sé si la misma cantidad de inválidos.
}
#_#_#_#_#_#_#_
#DIAGNOSTICO
#_#_#_#_#_#_#_
# Para ver las diferencias agregadas entre usuarios en los valores distintos que tienen.
if (invisible_edad_fecha_nac==0){
  
invisible(try(
  CONS_C1_df_dup_ENE_2020_prev4 %>% 
    dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
    dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
    dplyr::mutate(Edad_al_ing_menos_18=case_when(Edad_al_ing<18~1,TRUE~0))%>%
    group_by(HASH_KEY) %>%
    dplyr::mutate(Edad_al_ing_menos_18=sum(Edad_al_ing_menos_18))%>%
    dplyr::mutate(edad_por_hash=n_distinct(Edad),fech_nac_por_hash=n_distinct(fech_nac),ano_bd_por_hash=n_distinct(ano_bd)) %>% add_tally(name="n_por_hash")%>%dplyr::arrange(HASH_KEY)%>%
    dplyr::filter(edad_por_hash>0,fech_nac_por_hash>1,ano_bd_por_hash>0,n_por_hash>0,Edad_al_ing_menos_18==0)%>% print()
))
}
summ_fech_nac<-CONS_C1_df_dup_ENE_2020_prev4 %>% 
  group_by(HASH_KEY) %>%
  dplyr::mutate(fechnac_por_hash=n_distinct(fech_nac),bds_por_hash=n_distinct(ano_bd), HASH_reps = n()) %>%
  dplyr::filter(fechnac_por_hash>1)%>%
  dplyr::mutate(fech_nac_num=as.numeric(lubridate::time_length(difftime(as.Date(fech_nac), as.Date("1900-01-01")),"days"))) %>%
  dplyr::mutate(fech_nac_num=replace(fech_nac_num, is.na(Edad), NA)) %>%
  # dplyr::select(HASH_KEY, Edad, fech_nac, fech_nac_num)
  add_tally()%>%
  summarise(n=mean(n), fech_nac_p25 = quantile(fech_nac_num, c(0.25),na.rm=T),fech_nac_p50 = quantile(fech_nac_num, c(0.50),na.rm=T),fech_nac_p75 = quantile(fech_nac_num, c(0.75),na.rm=T),
            fech_nacsd=sd(fech_nac_num,na.rm=T), min=min(fech_nac_num, na.rm = T),max=max(fech_nac_num, na.rm = T),mean=mean(fech_nac_num,na.rm=T),ranges=abs(max-min)) %>%
  ungroup()%>%
  dplyr::mutate(diff_p25_p50=abs(fech_nac_p50-fech_nac_p25),diff_p75_p50=abs(fech_nac_p75-fech_nac_p50),min_mean=abs(min-mean), max_mean=abs(max-mean))%>%
  summarise(avg_n=mean(n), sd_n=sd(n),avg_p25_p50=mean(diff_p25_p50),avg_p75_p50=mean(diff_p75_p50),avg_sd=mean(fech_nacsd,na.rm=T),avg_min_mean=mean(min_mean,na.rm=T),
            avg_max_mean=mean(max_mean,na.rm=T),avg_ranges=mean(ranges,na.rm=T),sd_ranges=sd(ranges,na.rm=T),p75_ranges=quantile(ranges, c(0.75),na.rm=T),
            p90_ranges=quantile(ranges, c(0.90),na.rm=T)) %>% 
  round(2) 

summ_edad<-CONS_C1_df_dup_ENE_2020_prev4 %>% 
  group_by(HASH_KEY) %>%
  dplyr::mutate(edad_por_hash=n_distinct(Edad),bds_por_hash=n_distinct(ano_bd), HASH_reps = n()) %>%
  dplyr::filter(edad_por_hash>1)%>%
  # dplyr::select(HASH_KEY, Edad, fech_nac, fech_nac_num)
  add_tally()%>%
  summarise(n=mean(n), Edad_p25 = quantile(Edad, c(0.25),na.rm=T),Edad_p50 = quantile(Edad, c(0.50),na.rm=T),Edad_p75 = quantile(Edad, c(0.75),na.rm=T),
            Edadsd=sd(Edad,na.rm=T), min=min(Edad, na.rm = T),max=max(Edad, na.rm = T),mean=mean(Edad,na.rm=T),ranges=abs(max-min)) %>%
  ungroup()%>%
  dplyr::mutate(diff_p25_p50=abs(Edad_p50-Edad_p25),diff_p75_p50=abs(Edad_p75-Edad_p50),min_mean=abs(min-mean), max_mean=abs(max-mean))%>%
  summarise(avg_n=mean(n), sd_n=sd(n),avg_p25_p50=mean(diff_p25_p50),avg_p75_p50=mean(diff_p75_p50),avg_sd=mean(Edadsd,na.rm=T),avg_min_mean=mean(min_mean,na.rm=T),
            avg_max_mean=mean(max_mean,na.rm=T),avg_ranges=mean(ranges,na.rm=T),sd_ranges=sd(ranges,na.rm=T),p75_ranges=quantile(ranges, c(0.75),na.rm=T),
            p90_ranges=quantile(ranges, c(0.90),na.rm=T)) %>% 
  round(2)
#_#_#_#_#_#_#_
#_#_#_#_#_#_#_
#_______________________
###PARA HACER LA CONVERSION
#_______________________

#_#_#_#_#_#_
##0a. menos 18
edad_al_ing_menos_18_0a<-
  CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18=case_when(Edad_al_ing<18~1,TRUE~0))%>%
  group_by(HASH_KEY) %>%
  dplyr::mutate(Edad_al_ing_menos_18=sum(Edad_al_ing_menos_18))%>%
  dplyr::mutate(edad_por_hash=n_distinct(Edad),fech_nac_por_hash=n_distinct(fech_nac),ano_bd_por_hash=n_distinct(ano_bd)) %>% add_tally(name="n_por_hash")%>%dplyr::arrange(HASH_KEY)%>%
  dplyr::filter(edad_por_hash>0,fech_nac_por_hash>1,ano_bd_por_hash>0,n_por_hash>0,Edad_al_ing_menos_18>0)%>% 
  distinct(HASH_KEY) %>% dplyr::ungroup()%>% data.frame()%>% unlist()%>% as.character()

CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  dplyr::filter(HASH_KEY %in% edad_al_ing_menos_18_0a) %>%
  dplyr::group_by(HASH_KEY)%>%
  dplyr::mutate(edad_por_hash=n_distinct(Edad),fech_nac_por_hash=n_distinct(fech_nac),ano_bd_por_hash=n_distinct(ano_bd)) %>% add_tally(name="n_por_hash")%>%dplyr::arrange(HASH_KEY)%>%
  dplyr::mutate(edad_inicio_sus_mayor_a_edad= dplyr::case_when(Edad.Inicio..Sustancia.Principal.>Edad_al_ing|Edad.Inicio.Consumo>Edad_al_ing~1,TRUE~0))%>%
  #Señala haber iniciado consumo después de ingresar
  dplyr::filter(edad_inicio_sus_mayor_a_edad==0)%>%
  dplyr::mutate(min_fech_ing_by_hash=min(fech_ing))%>%
  dplyr::mutate(Edad_al_ing_min=lubridate::time_length(difftime(as.Date(min_fech_ing_by_hash), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing_min=replace(Edad_al_ing_min, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18_min=case_when(Edad_al_ing_min<18&min_fech_ing_by_hash==fech_ing~1,TRUE~0))%>%
  #En caso de presentar una fecha de nacimiento en particular, la primera fecha de ingreso correspondería a un menor de edad
  #se descarta porque es peligroso incoporarlo, dado que hay muchas fechas que todavía están en los 17 años
  #dplyr::filter(Edad_al_ing_menos_18_min==0)%>% 
  dplyr::filter(!row %in% c('55669', '118299', '70823', '76', '6891', '66127', '73976', '54422', '11837', '54210', '115559', 
                           '72119', '70929', '53222', '68387', '73896', '76915', '72178', '69295', '56077', '48023', '85833', 
                           '76406', '53557', '55779', '45644', '113617', '63549', '119432', '127179'))%>%
  add_tally(name="n_por_hash")%>%
  dplyr::slice(which.min(fech_nac)) %>% 
  dplyr::select(HASH_KEY,fech_nac)%>%
  dplyr::arrange(HASH_KEY)%>% 
  as.data.frame()%>%
  dplyr::mutate(fech_nac=as.character(fech_nac))%>%
  assign("hash_fechnac_edad_ing_menos_18_0a",., envir = .GlobalEnv) #37 valores para 37 usuarios.

#_#_#_#_#_#_
#0b. misma edad- Reemplazar con la fecha de nacimiento promedio
misma_edad_0b<- CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18=case_when(Edad_al_ing<18~1,TRUE~0))%>%
  group_by(HASH_KEY) %>%
  dplyr::mutate(Edad_al_ing_menos_18=sum(Edad_al_ing_menos_18))%>%
  dplyr::mutate(edad_por_hash=n_distinct(Edad),fech_nac_por_hash=n_distinct(fech_nac),ano_bd_por_hash=n_distinct(ano_bd)) %>% add_tally(name="n_por_hash")%>%dplyr::arrange(HASH_KEY)%>%
  dplyr::filter(edad_por_hash==1,fech_nac_por_hash>1,ano_bd_por_hash>0,n_por_hash>0,Edad_al_ing_menos_18==0)%>% 
  summarise(mean_fech_nac=mean(fech_nac,na.rm=T))%>%
  dplyr::mutate(mean_fech_nac=as.character(as.Date.character(mean_fech_nac)))

CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::filter(HASH_KEY %in% as.character(unlist(misma_edad_0b[,"HASH_KEY"]))) %>%
  dplyr::group_by(HASH_KEY)%>%
  dplyr::arrange(HASH_KEY)%>% 
  dplyr::select(HASH_KEY, fech_nac)%>%
  summarise(mean_fech_nac=mean(fech_nac, na.rm=T))  %>%
  dplyr::mutate(mean_fech_nac=as.character(as.Date.character(mean_fech_nac)))%>%
  as.data.frame()%>%
  assign("hash_fechnac_misma_edad_0b",., envir = .GlobalEnv) 

#_#_#_#_#_#_
#1. distinta edad, bd tratamiento más reciente- Dejar la fecha del tratamiento más reciente
CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18=case_when(Edad_al_ing<18~1,TRUE~0))%>%
  group_by(HASH_KEY) %>%
  dplyr::mutate(Edad_al_ing_menos_18=sum(Edad_al_ing_menos_18))%>%
  dplyr::mutate(edad_por_hash=n_distinct(Edad),fech_nac_por_hash=n_distinct(fech_nac),ano_bd_por_hash=n_distinct(ano_bd)) %>% add_tally(name="n_por_hash")%>%dplyr::arrange(HASH_KEY)%>%
  dplyr::filter(edad_por_hash>1,fech_nac_por_hash>1,ano_bd_por_hash>1,n_por_hash>0,Edad_al_ing_menos_18==0, !is.na(fech_nac))%>% #incorporo perdidos en la fecha de nac.
  #fecha de ingreso mínima por hash contendría una edad menor a 18 años
  dplyr::mutate(min_fech_ing_by_hash=min(fech_ing))%>%
  dplyr::ungroup()%>%
  dplyr::mutate(Edad_al_ing_min=lubridate::time_length(difftime(as.Date(min_fech_ing_by_hash), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing_min=replace(Edad_al_ing_min, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18_min=case_when(Edad_al_ing_min<18&min_fech_ing_by_hash==fech_ing~1,TRUE~0))%>%
  dplyr::filter(Edad_al_ing_menos_18_min==0)%>% #hay 0
  #  
  dplyr::arrange(HASH_KEY,desc(ano_bd)) %>% #may 2020, agregué descendiente la edad, de más reciente a más antiguo
  dplyr::select(row, HASH_KEY, ano_bd, ano_nac, fech_nac, Edad,fech_ing,Edad_al_ing)%>%
  dplyr::group_by(HASH_KEY,fech_nac)%>%
  add_tally(name="no_of_comb_hash_key_fech_nac")%>%
  dplyr::ungroup()%>%
  group_by(HASH_KEY) %>%
  dplyr::mutate(max_ano=max(ano_bd))%>%
  #dplyr::slice(which.max(ano_bd)) %>% #MAY 2020, dejé como un procedimiento de APR 2020
  dplyr::filter(max_ano==ano_bd) %>% 
  dplyr::ungroup()%>%
  assign("hash_fech_nac_most_recent_db_1a",., envir = .GlobalEnv) %>% # MAY 2020 - 1,320 casos de 1154 usuarios
  dplyr::group_by(HASH_KEY)%>%
  distinct(fech_nac,.keep_all=T)%>%
  dplyr::mutate(n_dis=n_distinct(fech_nac)) %>%
  dplyr::filter(n_dis>1)%>% #45
  dplyr::mutate(fech_nac_=paste0("fech_nac_",row_number()))%>%#
  tidyr::pivot_wider(id_cols =HASH_KEY,names_from = fech_nac_, values_from = fech_nac,names_repair="minimal",values_fill = list(n = ""))%>%
  assign("hash_fech_nac_most_recent_db_more_one_value_1b",., envir = .GlobalEnv) #179, de 78 usuarios

hash_fech_nac_most_recent_db_1a <- hash_fech_nac_most_recent_db_1a%>% #1,076 casos con 1,076 hash distintos
  group_by(HASH_KEY)%>%
  distinct(fech_nac,.keep_all=T)%>%
  dplyr::mutate(n_dis=n_distinct(fech_nac)) %>%
  dplyr::filter(n_dis==1) %>%
  ungroup()%>%
  dplyr::mutate(fech_nac=as.character(fech_nac))%>%
  dplyr::select(HASH_KEY,fech_nac)
  #dplyr::select(-n_dis,-row,-ano_nac,-max_ano,no_of_comb_hash_key_fech_nac)    

#_#_#_#_#_#_
#2a. distinta edad, misma bd tratamiento, más de 2 casos- Dejar la fecha del tratamiento más frecuente

CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18=case_when(Edad_al_ing<18~1,TRUE~0))%>%
  group_by(HASH_KEY) %>%
  dplyr::mutate(Edad_al_ing_menos_18=sum(Edad_al_ing_menos_18))%>%
  dplyr::mutate(edad_por_hash=n_distinct(Edad),fech_nac_por_hash=n_distinct(fech_nac),ano_bd_por_hash=n_distinct(ano_bd)) %>% add_tally(name="n_por_hash")%>%dplyr::arrange(HASH_KEY)%>%
  dplyr::filter(edad_por_hash>1,fech_nac_por_hash>1,ano_bd_por_hash==1,n_por_hash>2,Edad_al_ing_menos_18==0, !is.na(fech_nac))%>%
  #fecha de ingreso mínima por hash contendría una edad menor a 18 años
  dplyr::mutate(min_fech_ing_by_hash=min(fech_ing))%>%
  dplyr::ungroup()%>%
  dplyr::mutate(Edad_al_ing_min=lubridate::time_length(difftime(as.Date(min_fech_ing_by_hash), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing_min=replace(Edad_al_ing_min, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18_min=case_when(Edad_al_ing_min<18&min_fech_ing_by_hash==fech_ing~1,TRUE~0))%>%
  dplyr::filter(Edad_al_ing_menos_18_min==0)%>% #hay 0
  #  
  dplyr::group_by(HASH_KEY,fech_nac) %>%
  dplyr::add_tally(name="n_por_hash") %>%    #agrego un nuevo n, para contar los distintos fech_naces
  dplyr::mutate(min_fech_ing_by_hash=min(fech_ing))%>%
  dplyr::ungroup()%>%
  dplyr::mutate(Edad_al_ing_min=lubridate::time_length(difftime(as.Date(min_fech_ing_by_hash), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing_min=replace(Edad_al_ing_min, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18_min=case_when(Edad_al_ing_min<18&min_fech_ing_by_hash==fech_ing~1,TRUE~0))%>%
  dplyr::filter(Edad_al_ing_menos_18_min==0)%>%
  dplyr::select(row, HASH_KEY, ano_bd, fech_nac,fech_ing,Edad,Edad_al_ing,dias_trat,SENDA, n_por_hash)%>%
  dplyr::ungroup() %>%
  dplyr::arrange(HASH_KEY,desc(ano_bd),desc(fech_ing),desc(n_por_hash))%>%
  distinct(HASH_KEY,fech_nac,.keep_all=T) %>%
  dplyr::group_by(HASH_KEY) %>%
  #dplyr::slice(which.max(n_por_hash)) %>% #me quedo con la concatenación por hash key que más se repite.
  dplyr::top_n(1,n_por_hash)%>%
  dplyr::ungroup()%>%
  assign("hash_fech_nac_most_freq_value",., envir = .GlobalEnv)%>% #136
  group_by(HASH_KEY)%>%
  add_tally()%>%
  dplyr::filter(n>1)%>% #45
  dplyr::mutate(fech_nac_=paste0("fech_nac_",row_number()))%>%
  tidyr::pivot_wider(id_cols =HASH_KEY,names_from = fech_nac_, values_from = fech_nac,names_repair="minimal",values_fill = list(n = ""))%>%
  dplyr::rename("fech_nac"="fech_nac_1")%>%
  assign("hash_fech_nac_most_freq_value_more_one_value_2a2",., envir = .GlobalEnv) #136

#seleccionar los casos en que en la misma base de datos hay sólo un caso que es mayor
hash_fech_nac_most_freq_value_2a1 <- hash_fech_nac_most_freq_value%>% 
  group_by(HASH_KEY)%>%
  add_tally()%>%
  dplyr::filter(n==1) %>%
  dplyr::mutate(fech_nac=as.character(fech_nac))%>%
  dplyr::select(HASH_KEY,fech_nac)

#2b. distinta edad, misma bd tratamiento, más de 2 casos- Dejar la fecha del tratamiento más frecuente. Casos con fecha de trat + reciente
CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::filter(HASH_KEY %in% as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_1b["HASH_KEY"])))%>%
  dplyr::group_by(HASH_KEY,fech_nac) %>%
  dplyr::add_tally(name="n_por_hash_fech_nac") %>%  
  dplyr::ungroup()%>%
  dplyr::group_by(HASH_KEY) %>%
  dplyr::add_tally(name="n_por_hash") %>%  
  dplyr::arrange(desc(n_por_hash_fech_nac))%>%
  #  dplyr::ungroup()%>%
  dplyr::top_n(1,n_por_hash_fech_nac)%>%
  dplyr::arrange(desc(n_por_hash),HASH_KEY)%>%
  dplyr::distinct(HASH_KEY,fech_nac,.keep_all=T)%>%
  dplyr::select(row, HASH_KEY, ano_bd, fech_nac,fech_ing,Edad,dias_trat,SENDA, n_por_hash,n_por_hash_fech_nac) %>%
  dplyr::group_by(HASH_KEY)%>%
  dplyr::add_tally(name="n_por_hash") %>%
  assign("hash_fech_nac_most_recent_db_more_one_value_mfv_2b1",., envir = .GlobalEnv)

hash_fech_nac_most_recent_db_more_one_value_mfv_2b1 %>%
  dplyr::filter(n_por_hash>1)%>% #45
  dplyr::mutate(fech_nac_=paste0("fech_nac_",row_number()))%>%
  tidyr::pivot_wider(id_cols =HASH_KEY,names_from = fech_nac_, values_from = fech_nac,names_repair="minimal",values_fill = list(n = ""))%>%
  dplyr::rename("fech_nac"="fech_nac_1")%>%
  assign("hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2",., envir = .GlobalEnv) 

hash_fech_nac_most_recent_db_more_one_value_mfv_2b1<-
  hash_fech_nac_most_recent_db_more_one_value_mfv_2b1%>%
  dplyr::filter(n_por_hash==1)%>%
  dplyr::mutate(fech_nac=as.character(fech_nac))%>%
  dplyr::select(HASH_KEY,fech_nac)

#_#_#_#_#_#_
# 3. Sólo 2 casos . fechas de nacimiento, en la misma base de datos anual.
CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18=case_when(Edad_al_ing<18~1,TRUE~0))%>%
  group_by(HASH_KEY) %>%
  dplyr::mutate(Edad_al_ing_menos_18=sum(Edad_al_ing_menos_18))%>%
  dplyr::mutate(edad_por_hash=n_distinct(Edad),fech_nac_por_hash=n_distinct(fech_nac),ano_bd_por_hash=n_distinct(ano_bd)) %>% add_tally(name="n_por_hash")%>%dplyr::arrange(HASH_KEY)%>%
  dplyr::filter(edad_por_hash>1,fech_nac_por_hash>1,ano_bd_por_hash==1,n_por_hash==2,Edad_al_ing_menos_18==0, !is.na(fech_nac))%>%
  
  dplyr::mutate(fech_nac_=paste0("fech_nac_",row_number()))%>%
  dplyr::arrange(HASH_KEY) %>%
  dplyr::ungroup()%>%
  tidyr::pivot_wider(id_cols =HASH_KEY,names_from = fech_nac_, values_from = fech_nac,names_repair="minimal",values_fill = list(n = ""))%>%
  data.frame() %>%
  assign("hash_fech_nac_misma_bd_2_casos_3",., envir = .GlobalEnv)  

#_#_#_#_#_#_EXPLORACION DE CASOS ANOMALOS
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_

invisible(
  CONS_C1_df_dup_ENE_2020_prev4 %>% 
    dplyr::filter(HASH_KEY %in% c(as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2["HASH_KEY"])),
                                  as.character(unlist(hash_fech_nac_most_freq_value_more_one_value_2a2["HASH_KEY"])),
                                  as.character(unlist(hash_fech_nac_misma_bd_2_casos_3["HASH_KEY"]))))%>%
    dplyr::select(row,HASH_KEY, id, Edad,ano_bd,fech_ing,fech_nac,`Escolaridad..último.año.cursado.`, Estado.Conyugal, 
                  `Número.de.Hijos`, `Número.de.Hijos.Ingreso.Tratamiento.Residencial`,Edad.Inicio.Consumo,Edad.Inicio..Sustancia.Principal.,
                  Fecha.Ultimo.Tratamiento)%>% 
    guardar_tablas("empates y 2 valores misma bd")
)

#Para revisar la mediana
summ_fech_nac_empates<-
    CONS_C1_df_dup_ENE_2020_prev4 %>% 
    dplyr::filter(HASH_KEY %in% c(as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2["HASH_KEY"])),
                                  as.character(unlist(hash_fech_nac_most_freq_value_more_one_value_2a2["HASH_KEY"])),
                                  as.character(unlist(hash_fech_nac_misma_bd_2_casos_3["HASH_KEY"]))))%>%
    group_by(HASH_KEY)%>%
    dplyr::mutate(fechnac_por_hash=n_distinct(fech_nac),bds_por_hash=n_distinct(ano_bd), HASH_reps = n()) %>%
    dplyr::filter(fechnac_por_hash>1)%>%
    dplyr::mutate(fech_nac_num=as.numeric(lubridate::time_length(difftime(as.Date(fech_nac), as.Date("1900-01-01")),"days"))) %>%
    dplyr::mutate(fech_nac_num=replace(fech_nac_num, is.na(Edad), NA)) %>%
    # dplyr::select(HASH_KEY, Edad, fech_nac, fech_nac_num)
    add_tally()%>%
    summarise(n=mean(n), fech_nac_p25 = quantile(fech_nac_num, c(0.25),na.rm=T),fech_nac_p50 = quantile(fech_nac_num, c(0.50),na.rm=T),fech_nac_p75 = quantile(fech_nac_num, c(0.75),na.rm=T),
              fech_nacsd=sd(fech_nac_num,na.rm=T), min=min(fech_nac_num, na.rm = T),max=max(fech_nac_num, na.rm = T),mean=mean(fech_nac_num,na.rm=T),ranges=abs(max-min)) %>%
    ungroup()%>%
    dplyr::mutate(diff_p25_p50=abs(fech_nac_p50-fech_nac_p25),diff_p75_p50=abs(fech_nac_p75-fech_nac_p50),min_mean=abs(min-mean), max_mean=abs(max-mean))%>%
    summarise(avg_n=mean(n), sd_n=sd(n),avg_p25_p50=mean(diff_p25_p50)/365.25,avg_p75_p50=mean(diff_p75_p50)/365.25,avg_sd=mean(fech_nacsd,na.rm=T)/365.25,
              avg_min_mean=mean(min_mean,na.rm=T)/365.25,avg_max_mean=mean(max_mean,na.rm=T)/365.25,avg_ranges=mean(ranges,na.rm=T)/365.25,sd_ranges=sd(ranges,na.rm=T)/365.25,
              p25_ranges=quantile(ranges, c(0.25),na.rm=T)/365.25,p50_ranges=quantile(ranges, c(0.5),na.rm=T)/365.25,p75_ranges=quantile(ranges, c(0.75),na.rm=T)/365.25,
              p90_ranges=quantile(ranges, c(0.90),na.rm=T)/365.25) %>% 
    round(2) 

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#ÚLTIMOS DESCARTES- MANUAL REVIEW, 2B2 2A2 Y 3
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

#1. Casos que tienen una edad menor a la fecha de inicio de consumo de sustancias
hash_fechnac_2b2_2a2_misma_bd_2_casos_3_edad_ini_con_4c<- 
      CONS_C1_df_dup_ENE_2020_prev4 %>% 
      dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
      dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
      dplyr::mutate(edad_inicio_sus_mayor_a_edad= dplyr::case_when(Edad.Inicio..Sustancia.Principal.>Edad_al_ing|Edad.Inicio.Consumo>Edad_al_ing~1,TRUE~0))%>%
      dplyr::filter(HASH_KEY %in% c(as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2["HASH_KEY"])),
                                    as.character(unlist(hash_fech_nac_most_freq_value_more_one_value_2a2["HASH_KEY"])),
                                    as.character(unlist(hash_fech_nac_misma_bd_2_casos_3["HASH_KEY"]))))%>%
      group_by(HASH_KEY)%>%
      dplyr::mutate(edad_inicio_sus_mayor_a_edad=sum(edad_inicio_sus_mayor_a_edad))%>%
      ungroup()%>%
      dplyr::filter(edad_inicio_sus_mayor_a_edad==1)%>%
      group_by(HASH_KEY)%>%
      dplyr::slice(which.min(fech_nac)) %>%
      dplyr::mutate(fech_nac=as.character(fech_nac))%>%
      dplyr::select(HASH_KEY,fech_nac)

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#2. Menor o igual de la mediana
hash_fechnac_2b2_2a2_misma_bd_2_casos_3_mediana_menor_hash<- 
      CONS_C1_df_dup_ENE_2020_prev4 %>% 
      dplyr::filter(HASH_KEY %in% c(as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2["HASH_KEY"])),
                                    as.character(unlist(hash_fech_nac_most_freq_value_more_one_value_2a2["HASH_KEY"])),
                                    as.character(unlist(hash_fech_nac_misma_bd_2_casos_3["HASH_KEY"]))))%>%
      dplyr::filter(!HASH_KEY %in% as.character(unlist(hash_fechnac_2b2_2a2_misma_bd_2_casos_3_edad_ini_con_4c["HASH_KEY"])))%>% #Casos que tienen una edad menor a la fecha de inicio de consumo de sustancias
      group_by(HASH_KEY)%>%
      dplyr::mutate(fech_nac_num=as.numeric(lubridate::time_length(difftime(as.Date(fech_nac), as.Date("1900-01-01")),"days"))) %>%
      dplyr::mutate(fech_nac_num=replace(fech_nac_num, is.na(Edad), NA)) %>%
      # dplyr::select(HASH_KEY, Edad, fech_nac, fech_nac_num)
      add_tally()%>%
      summarise(n=mean(n), fech_nac_p25 = quantile(fech_nac_num, c(0.25),na.rm=T),fech_nac_p50 = quantile(fech_nac_num, c(0.50),na.rm=T),fech_nac_p75 = quantile(fech_nac_num, c(0.75),na.rm=T),
                fech_nacsd=sd(fech_nac_num,na.rm=T), min=min(fech_nac_num, na.rm = T),max=max(fech_nac_num, na.rm = T),mean=mean(fech_nac_num,na.rm=T),ranges=abs(max-min)) %>%
      ungroup()%>%
      dplyr::filter(ranges<=as.numeric(summ_fech_nac_empates["p50_ranges"])*365.25)%>%
      as.data.frame()%>%
      distinct(HASH_KEY)%>%
      unlist()%>%
      as.character()
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#3. Mayor o igual de la mediana
hash_fechnac_2b2_2a2_misma_bd_2_casos_3_mediana_mayor_hash<- 
  CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::filter(HASH_KEY %in% c(as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2["HASH_KEY"])),
                                as.character(unlist(hash_fech_nac_most_freq_value_more_one_value_2a2["HASH_KEY"])),
                                as.character(unlist(hash_fech_nac_misma_bd_2_casos_3["HASH_KEY"]))))%>%
  dplyr::filter(!HASH_KEY %in% as.character(unlist(hash_fechnac_2b2_2a2_misma_bd_2_casos_3_edad_ini_con_4c["HASH_KEY"])))%>% #Casos que tienen una edad menor a la fecha de inicio de consumo de sustancias
  group_by(HASH_KEY)%>%
  dplyr::mutate(fech_nac_num=as.numeric(lubridate::time_length(difftime(as.Date(fech_nac), as.Date("1900-01-01")),"days"))) %>%
  dplyr::mutate(fech_nac_num=replace(fech_nac_num, is.na(Edad), NA)) %>%
  # dplyr::select(HASH_KEY, Edad, fech_nac, fech_nac_num)
  add_tally()%>%
  summarise(n=mean(n), fech_nac_p25 = quantile(fech_nac_num, c(0.25),na.rm=T),fech_nac_p50 = quantile(fech_nac_num, c(0.50),na.rm=T),fech_nac_p75 = quantile(fech_nac_num, c(0.75),na.rm=T),
            fech_nacsd=sd(fech_nac_num,na.rm=T), min=min(fech_nac_num, na.rm = T),max=max(fech_nac_num, na.rm = T),mean=mean(fech_nac_num,na.rm=T),ranges=abs(max-min)) %>%
  ungroup()%>%
  dplyr::filter(ranges>=as.numeric(summ_fech_nac_empates["p50_ranges"])*365.25)%>%
  as.data.frame()%>%
  distinct(HASH_KEY)%>%
  unlist()%>%
  as.character()
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#TRANSFORMACIÓN DE VARIABLES
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

#2. Sacar la media de los casos con valores menores a la mediana.
CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::filter(HASH_KEY %in% hash_fechnac_2b2_2a2_misma_bd_2_casos_3_mediana_menor_hash) %>%
  
  dplyr::arrange(HASH_KEY)%>% 
  #dplyr::select(HASH_KEY, fech_nac)%>%
  dplyr::group_by(HASH_KEY)%>%
  dplyr::mutate(min_fech_ing_by_hash=min(fech_ing))%>%
  dplyr::mutate(Edad_al_ing_min=lubridate::time_length(difftime(as.Date(min_fech_ing_by_hash), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing_min=replace(Edad_al_ing_min, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18_min=case_when(Edad_al_ing_min<18~1,TRUE~0))%>%
  dplyr::filter(Edad_al_ing_menos_18_min==0)%>%
  summarise(mean_fech_nac=mean(fech_nac,na.rm=T))%>%
  dplyr::mutate(mean_fech_nac=as.character(as.Date.character(mean_fech_nac)))%>%
  as.data.frame()%>%
  assign("promedio_fech_nac_2b2_2a2_4a",., envir = .GlobalEnv) 

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#3. Los casos más problemáticos, que están en la mediana para arriba en términos de rangos por usuarios
CONS_C1_df_dup_ENE_2020_prev4 %>% 
  dplyr::filter(HASH_KEY %in% hash_fechnac_2b2_2a2_misma_bd_2_casos_3_mediana_mayor_hash) %>%
  group_by(HASH_KEY)%>%
  dplyr::mutate(min_fech_ing_by_hash=min(fech_ing))%>%
  dplyr::mutate(Edad_al_ing_min=lubridate::time_length(difftime(as.Date(min_fech_ing_by_hash), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing_min=replace(Edad_al_ing_min, is.na(Edad), NA)) %>%
  dplyr::mutate(Edad_al_ing_menos_18_min=case_when(Edad_al_ing_min<18&min_fech_ing_by_hash==fech_ing~1,TRUE~0))%>%
  dplyr::filter(Edad_al_ing_menos_18_min==0)%>% #0.
  dplyr::select(row,HASH_KEY, id,Comuna.Residencia, Edad,ano_bd,fech_ing,fech_nac,`Escolaridad..último.año.cursado.`, Estado.Conyugal, 
                `Número.de.Hijos`, `Número.de.Hijos.Ingreso.Tratamiento.Residencial`,Edad.Inicio.Consumo,Edad.Inicio..Sustancia.Principal.,
                Fecha.Ultimo.Tratamiento)%>% 
  dplyr::arrange(HASH_KEY)%>%
  #desde aquí, empiezo a ver qué casos tienen más de una fecha de nacimiento, pero un caso con más de una edad. (4b1)
  dplyr::mutate(n_distinct_age_by_hash=n_distinct(fech_nac))%>% # distintas fechas de nacimiento por usuario
  dplyr::group_by(HASH_KEY,Edad)%>%
  dplyr::mutate(n_ages_by_hash=n())%>% # 
  dplyr::ungroup()%>%
  dplyr::mutate(conservar=if_else(n_distinct_age_by_hash>1&n_ages_by_hash>1,1,0,0))%>%
  dplyr::group_by(HASH_KEY)%>%
  dplyr::mutate(discard_por_hash=sum(conservar))%>%
  dplyr::mutate(discard_final=if_else(discard_por_hash>0&conservar==0,1,0,0))%>%
  dplyr::filter(discard_final!=1)%>%
  #:#:#:#:#:#:#:#### 4b1
  # Estos casos son de hash que tienen distintas fechas de nacimiento, pero más de un caso con la misma edad.
  #dplyr::filter(row %in% c("10331","114190","100401","67438","115299","95798","122674"))%>%  
  #dplyr::filter(!HASH_KEY %in% c("1b59e62ebd06769d773df3bfaaa76820","39f02a1487a3c26128a28036c059c570","56ab5055a4e57bea456d76e91ef50cca",
   #                             "b0f58a11b9a9ae46f44d2e3e57120269","cd5ab28ad842d4dd604ebf759cc4aebd","d892e8ce80db54e5c5ff500b0a954565"))%>%
  dplyr::slice(which.min(fech_nac))%>%
  dplyr::mutate(fech_nac=as.character(fech_nac))%>%
  dplyr::select(HASH_KEY,fech_nac, Edad)%>%
  assign("menor_fech_nac_2b2_2a2_3_4b",., envir = .GlobalEnv) 

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

#hash_fechnac_edad_ing_menos_18_0a
#hash_fechnac_misma_edad_0b
#hash_fech_nac_most_recent_db_1a #dttm
#hash_fech_nac_most_freq_value_2a1 #dttm
#hash_fech_nac_most_recent_db_more_one_value_mfv_2b1 #dttm
#hash_fechnac_2b2_2a2_misma_bd_2_casos_3_edad_ini_con_4c #dttm
#promedio_fech_nac_2b2_2a2_4a
#menor_fech_nac_2b2_2a2_3_4b #dttm

CONS_C1_df_dup_ENE_2020_prev4 %>%
  dplyr::left_join(hash_fechnac_edad_ing_menos_18_0a, by="HASH_KEY",suffix=c("","_0a")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(hash_fechnac_edad_ing_menos_18_0a["HASH_KEY"])))))~glue::glue("{OBS};1.6.01.0a"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_0a),fech_nac_0a,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_0a")) %>% 
  dplyr::left_join(hash_fechnac_misma_edad_0b, by="HASH_KEY",suffix=c("","_0b")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(hash_fechnac_misma_edad_0b["HASH_KEY"])))))~glue::glue("{OBS};1.6.02.0b"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(mean_fech_nac),mean_fech_nac,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_0b"),-mean_fech_nac) %>% 
  dplyr::left_join(hash_fech_nac_most_recent_db_1a, by="HASH_KEY",suffix=c("","_1a")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(hash_fech_nac_most_recent_db_1a["HASH_KEY"])))))~glue::glue("{OBS};1.6.03.1a"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_1a),fech_nac_1a,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_1a")) %>% 
  dplyr::left_join(hash_fech_nac_most_freq_value_2a1, by="HASH_KEY",suffix=c("","_2a1")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(hash_fech_nac_most_freq_value_2a1["HASH_KEY"])))))~glue::glue("{OBS};1.6.04.2a1"),TRUE~OBS))%>%
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_2a1),fech_nac_2a1,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_2a1")) %>% 
  dplyr::left_join(hash_fech_nac_most_recent_db_more_one_value_mfv_2b1, by="HASH_KEY",suffix=c("","_2b1")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_2b1["HASH_KEY"])))))~glue::glue("{OBS};1.6.05.2b1"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_2b1),fech_nac_2b1,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_2b1")) %>% 
  dplyr::left_join(hash_fechnac_2b2_2a2_misma_bd_2_casos_3_edad_ini_con_4c, by="HASH_KEY",suffix=c("","_4c")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(hash_fechnac_2b2_2a2_misma_bd_2_casos_3_edad_ini_con_4c["HASH_KEY"])))))~glue::glue("{OBS};1.6.06.4c"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_4c),fech_nac_4c,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_4c")) %>% 
  dplyr::left_join(promedio_fech_nac_2b2_2a2_4a, by="HASH_KEY",suffix=c("","_4a")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(promedio_fech_nac_2b2_2a2_4a["HASH_KEY"])))))~glue::glue("{OBS};1.6.07.4a"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(mean_fech_nac),mean_fech_nac,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_4a"),mean_fech_nac) %>% 
  dplyr::left_join(menor_fech_nac_2b2_2a2_3_4b, by="HASH_KEY",suffix=c("","_4b")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(menor_fech_nac_2b2_2a2_3_4b["HASH_KEY"])))))~glue::glue("{OBS};1.6.08.4b"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_4b),fech_nac_4b,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_4b")) %>% 
#as.Date(
  dplyr::mutate(id=`substr<-`(id,6,13,gsub("-", "",format(as.Date(lubridate::parse_date_time(as.Date(fech_nac),"Ymd")),"%d%m%Y")))) %>%
  #dplyr::mutate(id=`substr<-`(id,6,13,fech_nac)) %>%
  dplyr::mutate(id_mod=sub("(.{5}).", "\\1*",id)) %>%
  dplyr::mutate(id_mod=sub("(.{6}).", "\\1*",id_mod)) %>%
  dplyr::mutate(fech_nac=lubridate::parse_date_time(as.character(as.Date(fech_nac)),"Ymd")) %>%
  dplyr::mutate(ano_nac= as.numeric(stringi::stri_sub(as.character(fech_nac),1,4))) %>%
  dplyr::mutate(Edad= as.integer(lubridate::time_length(difftime(as.Date("2019-11-13"),as.Date(fech_nac)),"years"))) %>%
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  assign("CONS_C1_df_dup_ENE_2020_prev5",., envir = .GlobalEnv)
```


<br>

```{r fig2_dec_tree_disc_dup_birthdate2, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F,fig.cap="Figure 2b. Decision Tree for the Discard of Duplicated Date of Birth by User. Discard invalid data, <18 years at admission"}
#plot(CONS_C1_df_dup_ENE_2020_prev2$ano_nac, CONS_C1_df_dup_ENE_2020_prev2$Edad, ylab="Age", xlab="Year of Birth")
knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/Fig2b_Date of Birth._less_18.svg")
```

<br>

Subsequently, we aimed to rule out birth dates based on the validity of the age at admission (>=18 years at admission). If a user had a year at admission of 18 or less, and more than one date of birth, we replaced the date of birth with the oldest value, regardless of the criteria by which the invalid date was selected.

<br>

```{r date_of_birth_rule_based_replacement2_less18, echo=T,cache=T, paged.print=TRUE}
#_#_#_#_#PARA VER LOS MENORES A 18 AÑOS DE EDAD
#CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(HASH_KEY %in% menos_18_hash) %>% 
#  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
#  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
#  dplyr::arrange(HASH_KEY)%>% dplyr::select(HASH_KEY,id,id_mod,Edad,fech_nac,Edad_al_ing)

#CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(HASH_KEY %in% menos_18_hash) %>% dplyr::arrange(HASH_KEY)%>% dplyr::select(HASH_KEY,id,id_mod,fech_nac,Edad,Edad_al_ing)
#CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(HASH_KEY=="403b2b7d583202300ec9b1a22f62925f") %>% dplyr::arrange(HASH_KEY)%>% dplyr::select(HASH_KEY,id,id_mod,Edad,Edad_al_ing)
#CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(HASH_KEY=="7a4bf59c6210afe06194e942d349b900") %>% dplyr::arrange(HASH_KEY)%>% dplyr::select(HASH_KEY,id,id_mod,Edad,Edad_al_ing)

menos_18_hash<-
  CONS_C1_df_dup_ENE_2020_prev5 %>% as.data.frame() %>% dplyr::filter(Edad_al_ing<18) %>% distinct(HASH_KEY) %>% unlist() %>% as.character()
#183 filas; 175 hashs

less_18_hash_more_one_age<-CONS_C1_df_dup_ENE_2020_prev4 %>%
  dplyr::filter(HASH_KEY %in% menos_18_hash)%>%
  dplyr::arrange(HASH_KEY)%>%
  dplyr::select(HASH_KEY,id,id_mod,Edad,fech_nac)%>% 
  dplyr::group_by(HASH_KEY)%>% 
  dplyr::mutate(n=n_distinct(fech_nac)) %>% 
  dplyr::ungroup()%>%
  dplyr::filter(n>1)%>%
  dplyr::group_by(HASH_KEY)%>%
  dplyr::slice(which.min(fech_nac))%>%
  dplyr::ungroup()                

#CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(HASH_KEY %in% menos_18_hash) %>% dplyr::select(HASH_KEY,id,id_mod,Edad,Edad_al_ing)
menos_18_hash_caso_unico<-
  CONS_C1_df_dup_ENE_2020_prev5 %>%
  dplyr::filter(HASH_KEY %in% menos_18_hash)%>%
  dplyr::filter(!HASH_KEY %in% as.character(unlist(less_18_hash_more_one_age[,"HASH_KEY"])))%>% distinct(HASH_KEY)

#son 59 hash distintos que se verían afectados
invisible(distinct(less_18_hash_more_one_age,HASH_KEY))

CONS_C1_df_dup_ENE_2020_prev5 %>%
  dplyr::left_join(less_18_hash_more_one_age, by="HASH_KEY", suffix= c("","_more_age")) %>%
  dplyr::mutate(OBS= dplyr::case_when(!is.na(fech_nac_more_age)~paste0(as.character(OBS),";","1.6.XX.1.Age at admission less 18 years & had an older date of birth that could be replaced"), TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(fech_nac= dplyr::case_when(!is.na(fech_nac_more_age)~fech_nac_more_age,TRUE ~ fech_nac))%>%
  dplyr::mutate(id= dplyr::case_when(!is.na(id_more_age)~id_more_age,TRUE ~ id))%>%
  dplyr::mutate(id_mod= dplyr::case_when(!is.na(id_mod_more_age)~id_mod_more_age,TRUE ~ id_mod))%>%
  dplyr::mutate(id_mod=sub("(.{5}).", "\\1*",id)) %>%
  dplyr::mutate(id_mod=sub("(.{6}).", "\\1*",id_mod)) %>%
  dplyr::mutate(fech_nac= as.POSIXct(fech_nac, origin="1970-01-02")) %>%
  dplyr::mutate(fech_nac= stringi::stri_sub(as.character.Date(fech_nac),1,10)) %>%
  dplyr::mutate(fech_nac= lubridate::parse_date_time(fech_nac,"Ymd")) %>%
  dplyr::mutate(Edad= dplyr::case_when(!is.na(Edad_more_age)~Edad_more_age,TRUE ~ Edad))%>%
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  as.data.frame() %>%
  dplyr::select(-ends_with("_more_age"),-n,-mean_fech_nac)%>%
  dplyr::mutate(OBS= dplyr::case_when(HASH_KEY %in% as.character(unlist(menos_18_hash_caso_unico))~
                                        paste0(as.character(OBS),";","1.6.XX.2.Age at admission less 18 years & had another date of birth that could be replaced"), TRUE ~ as.character(OBS)))%>%
  assign("CONS_C1_df_dup_ENE_2020_prev52",., envir = .GlobalEnv) 

menos_18_hash_2<- CONS_C1_df_dup_ENE_2020_prev52 %>% as.data.frame() %>% dplyr::filter(Edad_al_ing<18) %>% distinct(HASH_KEY) %>% unlist() %>% as.character()

#16ffdf18efeffe5f0c9c78d547dc392_2014_6_13 1996-06-30
#616a9f5147684b5bb649eff9936db849_2014_1_15 1998-07-18
casos_emblematicos<-
    #CONS_C1_df_dup_ENE_2020_prev52 %>%
    CONS_C1_df_dup_ENE_2020_prev52 %>%
      dplyr::filter(HASH_KEY %in% menos_18_hash_2)%>%
      dplyr::filter(HASH_KEY %in% as.character(unlist(less_18_hash_more_one_age)))%>% 
      dplyr::select(HASH_KEY,id,fech_ing,Edad_al_ing, Edad,fech_nac)%>% data.frame()

invisible(
  #c("aqui se muestra que incluso la fecha de nacimiento más antigua", "sigue dejando una edad de ingreso menor a 18")
  CONS_C1_df_dup_ENE_2020_prev4 %>%
    dplyr::filter(HASH_KEY %in% menos_18_hash_2)%>%
    dplyr::filter(HASH_KEY %in% as.character(unlist(less_18_hash_more_one_age)))%>% 
    dplyr::select(HASH_KEY,id,fech_ing,Edad,fech_nac)%>% 
    dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
    dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
    data.frame()
)
#invisible(
 # CONS_C1_df_dup_ENE_2020_prev52 %>%
#    dplyr::filter(grepl("1.6.XX.2.",OBS))%>% glimpse()
#)

#1.6.XX.2.
```


After this process, we still ended with `r CONS_C1_df_dup_ENE_2020_prev52 %>%dplyr::filter(HASH_KEY %in% menos_18_hash_2)%>% dplyr::select(HASH_KEY,id,fech_ing,Edad_al_ing)%>% data.frame() %>% distinct(HASH_KEY) %>% nrow()` users that had at least one date of admission with less than 18 years old. Additionally, `r casos_emblematicos %>% distinct(HASH_KEY)%>% nrow()` users had both of distinct dates of birth with ages at admission of less than 18 years old. Lastly, `r CONS_C1_df_dup_ENE_2020_prev52 %>% dplyr::filter(is.na(fech_nac))%>% distinct(HASH_KEY) %>% nrow()` users did not have a valid date of admission.

<br>

###4.2.Imputation of inconsistent dates of birth through Neural Networks

We used a neural network model to obtain valid dates of birth for the `r CONS_C1_df_dup_ENE_2020_prev52 %>% dplyr::filter(is.na(fech_nac))%>% distinct(HASH_KEY) %>% nrow()` users that did not have a valid date of birth, and for those cases that had a date at admission of less than 15 years old. We did not selected the cutpoint at 16 years old, because one user (616a9f5147684b5bb649eff9936db849) had an age at admission of 15 years old, but also had another entry with the same date of birth in the dataset of 2019.  This led us to think that in specific cases, users of 15 years old could be admissible (n= `r   CONS_C1_df_dup_ENE_2020_prev52 %>% dplyr::filter(Edad_al_ing<15)%>% nrow()`).

<br>

```{r nnet_fech_nac, echo=T,cache=T, paged.print=TRUE}
library(radiant)          
no_es=1
          if (no_es==0){
            rstudioapi::jobRunScript(path = "path_to_Jobs_script", importEnv = TRUE)
          }
          
          #son puros casos que no tienen edad ni fecha de nacimiento ni un id correcto
          #table(is.na(CONS_C1_df_dup_MAY_2020_prev0$id)) = table(is.na(CONS_C1_df_dup_MAY_2020_prev0$edad))
          
          C1_fech_nac_nas<- CONS_C1_df_dup_ENE_2020_prev52 %>% dplyr::filter(is.na(fech_nac))%>% distinct(HASH_KEY)
          
          if (no_es==0){
            print(
            "Estos casos terminan siendo inválidos, por eso se declaran perdidos después. Tamopco tienen edad ni ID. 
            El problema es que al momento de elaboración de la base de datos, en prev3 de enero, estos casos siguen sin ser reconocidos."
                  )
          CONS_C1_df_dup_ENE_2020_prev3 %>% 
            dplyr::filter(HASH_KEY %in% as.character(unlist(C1_fech_nac_nas)))
          }
          #NAs
          # SELECCION DE LA MUESTRA, TODOS LOS CASOS QUE NO TIENEN PROBLEMAS
          #_#_#_#_#_
          set.seed(1245)
          C1_fech_nac_not_ties<-     
            CONS_C1_df_dup_ENE_2020_prev3 %>% 
            dplyr::filter(!HASH_KEY %in% c(as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2["HASH_KEY"])),
                                           as.character(unlist(hash_fech_nac_most_freq_value_more_one_value_2a2["HASH_KEY"])),
                                           as.character(unlist(C1_fech_nac_nas)),
                                           as.character(unlist(menos_18_hash_caso_unico["HASH_KEY"])),
                                           as.character(unlist(hash_fech_nac_misma_bd_2_casos_3["HASH_KEY"]))))%>%
            dplyr::mutate(fech_nac=lubridate::parse_date_time(stringi::stri_sub(id,-8,-1),"dmY")) %>% 
            dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years"))%>% #AGREGADO EN APR 2020.
            dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>% #AGREGADO EN APR 2020.
            dplyr::as_tibble()%>%
            janitor::clean_names()%>%
            dplyr::select(row,hash_key,fech_ing, edad_al_ing, ano_bd, escolaridad_ultimo_ano_cursado,estado_conyugal,
                          numero_de_hijos,numero_de_hijos_ingreso_tratamiento_residencial,
                          edad_inicio_consumo,edad_inicio_sustancia_principal,fecha_ultimo_tratamiento)%>%
           # sample_frac(.05)%>%
            na.omit()%>%
            dplyr::mutate(rn=row_number())
          
          #escolaridad último año cursado
          C1_fech_nac_not_ties_1<-
            C1_fech_nac_not_ties %>% 
            dplyr::mutate(var = 1) %>% 
            dplyr::select(var,escolaridad_ultimo_ano_cursado,rn)%>%
            tidyr::spread(escolaridad_ultimo_ano_cursado, var, fill = 0, sep = "_") %>% 
            left_join(C1_fech_nac_not_ties, by=c("rn"="rn"))
          
          #estado conyugal
          C1_fech_nac_not_ties_1<-
            C1_fech_nac_not_ties %>% 
            dplyr::mutate(var = 1) %>% 
            dplyr::select(var,estado_conyugal,rn)%>%
            tidyr::spread(estado_conyugal, var, fill = 0, sep = "_") %>% 
            left_join(C1_fech_nac_not_ties_1, by=c("rn"="rn"))
          
          #fecha último tratamiento
          C1_fech_nac_not_ties_summ<-
            C1_fech_nac_not_ties_1 %>% 
            dplyr::mutate(var = 1) %>%
            dplyr::select(var,fecha_ultimo_tratamiento,rn)%>%
            tidyr::spread(fecha_ultimo_tratamiento, var, fill = 0, sep = "_") %>% 
            left_join(C1_fech_nac_not_ties_1, by=c("rn"="rn")) %>% 
            dplyr::select(-estado_conyugal,-escolaridad_ultimo_ano_cursado,-fecha_ultimo_tratamiento,-rn)%>%
            dplyr::select(row:edad_inicio_sustancia_principal,starts_with("estado_conyugal"),
                          starts_with("escolaridad_ultimo"),starts_with("fecha_ultimo_trat"))
          
          #_#_#_#_#_#_#_
          #nunca poner na.omit aquí, porque necesitamos imputar todos los casos
          set.seed(1245)
          C1_fech_nac_ties<-     
            CONS_C1_df_dup_ENE_2020_prev3 %>% 
            dplyr::filter(HASH_KEY %in% c(as.character(unlist(hash_fech_nac_most_recent_db_more_one_value_mfv_more_one_value_2b2["HASH_KEY"])),
                                           as.character(unlist(hash_fech_nac_most_freq_value_more_one_value_2a2["HASH_KEY"])),
                                           as.character(unlist(C1_fech_nac_nas)),
                                           as.character(unlist(menos_18_hash_caso_unico["HASH_KEY"])),
                                           as.character(unlist(hash_fech_nac_misma_bd_2_casos_3["HASH_KEY"]))))%>%
            dplyr::mutate(fech_nac=lubridate::parse_date_time(stringi::stri_sub(id,-8,-1),"dmY")) %>% 
            dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>% #AGREGADO EN APR 2020.
            dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>% #AGREGADO EN APR 2020.
            dplyr::as_tibble()%>%
            janitor::clean_names()%>%
            dplyr::select(row,hash_key,edad,fech_nac,fech_ing, edad_al_ing, ano_bd, escolaridad_ultimo_ano_cursado,estado_conyugal,
                          numero_de_hijos,numero_de_hijos_ingreso_tratamiento_residencial,
                          edad_inicio_consumo,edad_inicio_sustancia_principal,fecha_ultimo_tratamiento)%>%
            # sample_frac(.05)%>%
            dplyr::mutate(rn=row_number())
          
          C1_fech_nac_ties_1<-
            C1_fech_nac_ties %>% 
            dplyr::mutate(var = 1) %>% 
            dplyr::select(var,escolaridad_ultimo_ano_cursado,rn)%>%
            tidyr::spread(escolaridad_ultimo_ano_cursado, var, fill = 0, sep = "_") %>% 
            left_join(C1_fech_nac_ties, by=c("rn"="rn"))
          
          #estado conyugal
          C1_fech_nac_ties_1<-
            C1_fech_nac_ties %>% 
            dplyr::mutate(var = 1) %>% 
            dplyr::select(var,estado_conyugal,rn)%>%
            tidyr::spread(estado_conyugal, var, fill = 0, sep = "_") %>% 
            left_join(C1_fech_nac_ties_1, by=c("rn"="rn"))
          
          #fecha último tratamiento
          C1_fech_nac_ties_summ<-
            C1_fech_nac_ties_1 %>% 
            dplyr::mutate(var = 1) %>%
            dplyr::select(var,fecha_ultimo_tratamiento,rn)%>%
            tidyr::spread(fecha_ultimo_tratamiento, var, fill = 0, sep = "_") %>% 
            left_join(C1_fech_nac_ties_1, by=c("rn"="rn")) %>% 
            dplyr::select(-estado_conyugal,-escolaridad_ultimo_ano_cursado,-fecha_ultimo_tratamiento,-rn)%>%
            dplyr::select(row:edad_inicio_sustancia_principal,starts_with("estado_conyugal"),
                          starts_with("escolaridad_ultimo"),starts_with("fecha_ultimo_trat"))%>%
            #dejo los nas como 0.
            dplyr::mutate(edad_inicio_consumo=replace_na(edad_inicio_consumo,0))%>%
            dplyr::mutate(numero_de_hijos_ingreso_tratamiento_residencial=replace_na(numero_de_hijos_ingreso_tratamiento_residencial,0))
            
          
          #C1_fech_nac_ties_summ: Para probar todos los NAs
          #nrow(C1_fech_nac_ties_summ[!complete.cases(C1_fech_nac_ties_summ), ])
          
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
          
          #nn: Neural Networks using nnet
          #https://rdrr.io/cran/radiant.model/man/nn.html
          #https://radiant-rstats.github.io/radiant.model/reference/nn.html
          #https://radiant-rstats.github.io/docs/model/nn.html
          #result <- radiant::nn(C1_fech_nac_ties, "fech_nac", "edad:edad_inicio_sustancia_principal", type = "regression")
            result_fech_nac0<- nn(
              C1_fech_nac_not_ties_summ, 
              rvar = "edad_al_ing", #The response variable in the model
              evar = c(
                "ano_bd",
                "numero_de_hijos", 
                "edad_inicio_consumo", 
                "edad_inicio_sustancia_principal"
              ), #Explanatory variables in the model
              type = "regression", #Model type (i.e., "classification" or "regression")
              #lev= The level in the response variable defined as _success_
              #size= Number of units (nodes) in the hidden layer
              #decay=  Parameter decay
              #wts=  Weights to use in estimation
              #seed= Random seed to use as the starting point
              #check=  Optional estimation parameters ("standardize" is the default)
              #data_filter= Expression entered in, e.g., Data > View to filter the dataset in Radiant. The expression should be a string (e.g., "price > 10000")
              #form=   Optional formula to use instead of rvar and evar // Ocupar formula
              seed = 1245
            )
          #The model can be “tuned” by changing the Size (i.e., the number of nodes in the hidden layer) 
            #and by adjusting the Decay rate. The higher the value set for Decay, the higher the penalty on 
            #the size of (the sum of squares of) the weights. When Decay is set to 0, the model has the most 
            #flexibility to fit the (training) data accurately. However, without Decay the model is also more 
            #likely to overfit.
            
          #The best way to determine the optimal values for Size and Decays is to use Cross-Validation. 
            #In radiant, you can use the cv.nn function for this purpose. 
            
            #cv.nn: Cross-validation for a Neural Network
            #https://radiant-rstats.github.io/radiant.model/reference/cv.nn.html
            #K= número de cv pasa para usar
            #repeats= cv repetido
            #decay= decaimiento en parámetros
            #size=número de nodos en la capa oculta
            #seed= semilla aleatoria como inicio
            #trace= imprimir progreso
            #fun= función para usar evaluación del modelo (auc para clasificación, RMSE para regresión; también está Rsq)
            #https://rdrr.io/cran/radiant.model/man/auc.html
            #https://rdrr.io/cran/radiant.model/man/RMSE.html
            #https://rdrr.io/cran/radiant.model/man/profit.html
            
            result_fech_nac_all_cv<- cv.nn(result_fech_nac0, K= 10, decay = seq(0, 1, .5), size = 1:5, fun = RMSE, trace=T, seed=1245)
            #cv.nn(result, decay = seq(0, 1, .5), size = 1:2, fun = profit, cost = 1, margin = 5)
            #30 minutos se demora en sacar size 1:4 con 4 fragmentos en decay
            
            #selecciono los parámetros que permitan hacer la mejor estimación
            nn_fech_nac_par<-result_fech_nac_all_cv[which(result_fech_nac_all_cv$`RMSE (mean)`==min(result_fech_nac_all_cv$`RMSE (mean)`)),c("decay","size","RMSE (mean)")]
            result_fech_nac<- nn(
                                C1_fech_nac_not_ties_summ[c("edad_al_ing", "ano_bd","numero_de_hijos","edad_inicio_consumo","edad_inicio_sustancia_principal")], 
                                rvar = "edad_al_ing",
                                evar = c(
                                  "ano_bd",
                                  "numero_de_hijos", 
                                  "edad_inicio_consumo", 
                                  "edad_inicio_sustancia_principal"
                                ), 
                                type = "regression", 
                                decay= as.numeric(nn_fech_nac_par[1]),
                                size= as.numeric(nn_fech_nac_par[2]),
                                seed = 1245
            )
            
            #33 MINUTOS DURA
            
          #predict(result, pred_cmd = "carat = 1:3")
            #https://radiant-rstats.github.io/radiant.model/reference/predict.nn.html
            #pred_data= Provide the dataframe to generate predictions (e.g., diamonds). The dataset must contain all columns used in the estimation
            #pred_cmd= Generate predictions using a command. For example, `pclass = levels(pclass)` would produce predictions 
              #for the different levels of factor `pclass`. To add another variable, create a vector of prediction strings, 
              #(e.g., c('pclass = levels(pclass)', 'age = seq(0,100,20)')
              #dec=  Number of decimals to show
              #envir= Environment to extract data from
            
  result_fech_nac_all_cv_pred<- predict(result_fech_nac, pred_data = C1_fech_nac_ties_summ)

          #debemos eliminar los NAs
            if (no_es==0){
              print(paste0("comprobar si se reemplazó los valores perdidos por un 0.", 
                    "Independiente de ello, si los lleno, al final los casos hacen un match perfecto a futuro"))
              C1_fech_nac_ties_1[!complete.cases(C1_fech_nac_ties_1[, c("ano_bd","numero_de_hijos", "edad_inicio_consumo", "edad_inicio_sustancia_principal")]),
                               c("ano_bd","numero_de_hijos", "edad_inicio_consumo", "edad_inicio_sustancia_principal")]
          }
            result_fech_nac_all_cv_pred<- 
              result_fech_nac_all_cv_pred %>%
              mutate(concat=paste0(ano_bd,"_",numero_de_hijos,"_",edad_inicio_consumo,"_",edad_inicio_sustancia_principal))
            
       #     rm(list= ls()[!(ls() %in% c('result_fech_nac','C1_fech_nac_ties_summ', 'result_fech_nac_all_cv','nn_fech_nac_par','result_fech_nac_all_cv_pred'))])
   
      C1_fech_nac_ties_summ <-C1_fech_nac_ties_summ%>%
                    mutate(concat=paste0(ano_bd,"_",numero_de_hijos,"_",edad_inicio_consumo,"_",edad_inicio_sustancia_principal))
      
      #para los que tienen empates:
      #saco un promedio de las edades al ingreso originales predichas.
      #veo cuál d e las edades empatadas se acerca más a este promedio.
      #me quedo con esa.
      fech_nac_edad_al_ing_replace_mas_un_caso <-
                  result_fech_nac_all_cv_pred%>%
                    dplyr::rename("numero_de_hijos2"="numero_de_hijos",
                                  "edad_inicio_consumo2"="edad_inicio_consumo",
                                  "edad_inicio_sustancia_principal2"="edad_inicio_sustancia_principal",
                                  "concat3"="concat")%>% 
                    cbind(C1_fech_nac_ties_summ[c("row","hash_key", "fech_nac","edad_al_ing","fech_ing")])%>%
                    dplyr::select(-starts_with("concat"))%>%
                    dplyr::mutate(fech_nac_corr= ifelse(ano_bd==2019,
                                                          as.Date("2019-11-13")-Prediction*365.25, #as.numeric(as.Date("2019-11-13")) 
                                                          as.Date("2019-11-05")-Prediction*365.25))%>%#18213 #as.numeric(as.Date("2019-11-05"))
                    dplyr::mutate(fech_nac_corr=zoo::as.Date(fech_nac_corr))%>%
                    dplyr::group_by(hash_key)%>%
                    dplyr::mutate(mean_pr=mean(fech_nac_corr),
                                  diff_pr_ed_ing=as.Date(as.character(fech_nac))-fech_nac_corr,
                                  n_por_hash=n())%>%
                    dplyr::filter(n_por_hash>=2,diff_pr_ed_ing==min(diff_pr_ed_ing))
      
      fech_nac_edad_al_ing_replace <-
                  result_fech_nac_all_cv_pred%>%
                    dplyr::rename("numero_de_hijos2"="numero_de_hijos",
                                  "edad_inicio_consumo2"="edad_inicio_consumo",
                                  "edad_inicio_sustancia_principal2"="edad_inicio_sustancia_principal",
                                  "concat3"="concat")%>% 
                    cbind(C1_fech_nac_ties_summ[c("row","hash_key", "fech_nac","edad_al_ing","fech_ing")])%>%
                    dplyr::select(-starts_with("concat"))%>%
                    dplyr::mutate(fech_nac_corr= ifelse(ano_bd==2019,
                                                          as.Date("2019-11-13")-Prediction*365.25, #as.numeric(as.Date("2019-11-13")) 
                                                          as.Date("2019-11-05")-Prediction*365.25))%>%#18213 #as.numeric(as.Date("2019-11-05"))
                    dplyr::mutate(fech_nac_corr=zoo::as.Date(fech_nac_corr))%>%
                    dplyr::group_by(hash_key)%>%
                    dplyr::mutate(mean_pr=mean(fech_nac_corr),
                                  diff_pr_ed_ing=as.Date(as.character(fech_nac))-fech_nac_corr,
                                  n_por_hash=n())
      
      fech_nac_edad_replace_nas <-
                    result_fech_nac_all_cv_pred%>%
                    dplyr::rename("numero_de_hijos2"="numero_de_hijos",
                                  "edad_inicio_consumo2"="edad_inicio_consumo",
                                  "edad_inicio_sustancia_principal2"="edad_inicio_sustancia_principal",
                                  "concat3"="concat")%>% 
                    cbind(C1_fech_nac_ties_summ[c("row","hash_key","edad", "fech_nac","edad_al_ing","fech_ing")])%>%
                    dplyr::select(-starts_with("concat"))%>%
                    dplyr::mutate(fech_nac_corr= ifelse(ano_bd==2019,
                                                        as.Date("2019-11-13")-Prediction*365.25, #as.numeric(as.Date("2019-11-13")) 
                                                        as.Date("2019-11-05")-Prediction*365.25))%>%#18213 #as.numeric(as.Date("2019-11-05")) #18213 -8
                    dplyr::mutate(fech_nac_corr=zoo::as.Date(fech_nac_corr))%>%
                    dplyr::group_by(hash_key)%>%
                    dplyr::mutate(n_por_hash=n())%>%
                    dplyr::filter(n_por_hash<2)%>%
                    dplyr::filter(is.na(edad))
```

<br>

To obtain valid dates, we predicted the date of admission of each case.  We generated a total of 10 cross-validations, with alternatives of 1 to 5 layers, and a threshold of 0, .5 and 1 in every model (10x5x3). The model that obtained the best fit (RMSE (mean)= `r round(nn_fech_nac_par[,3],2)`) had a size of `r result_fech_nac$size` layers, and a threshold for weights of `r result_fech_nac$decay` (L2 penalty). 

<br>

```{r fig3_NN_date_birth_PLOT, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F,fig.cap="Figure 3. Neural Network of Date of Birth"}
#plot(CONS_C1_df_dup_ENE_2020_prev2$ano_nac, CONS_C1_df_dup_ENE_2020_prev2$Edad, ylab="Age", xlab="Year of Birth")
mar <- par(mar = c(0, 0, 0, 0))

on.exit(par(mar = mar$mar))

plot(result_fech_nac, plots = "net", custom=T,size = 9, pad_x = 0.8, nrobs = -1,cex_val = 3)
```

```{r nnet_fech_nac_transformation, echo=T,cache=T, paged.print=TRUE}
#          C1_fech_nac_nas<- CONS_C1_df_dup_ENE_2020_prev52 %>% dplyr::filter(is.na(fech_nac))%>% distinct(HASH_KEY)

#plot(result_fech_nac, plots = "net", custom=T,size = 9, pad_x = 0.9, nrobs = -1,cex_val = 3)

summary(result_fech_nac)

CONS_C1_df_dup_ENE_2020_prev52_NA<-
 CONS_C1_df_dup_ENE_2020_prev52 %>%
  dplyr::filter(HASH_KEY %in% as.character(unlist(C1_fech_nac_nas[,c("HASH_KEY")])))%>%
    janitor::clean_names()%>%
            dplyr::select(row,hash_key,fech_nac,fech_ing, edad_al_ing, ano_bd, escolaridad_ultimo_ano_cursado,estado_conyugal,
                          numero_de_hijos,numero_de_hijos_ingreso_tratamiento_residencial,
                          edad_inicio_consumo,edad_inicio_sustancia_principal,fecha_ultimo_tratamiento)%>%
   dplyr::left_join(fech_nac_edad_replace_nas,"row", suffix=c("","_y"))%>%
   dplyr::rename("fech_nac_original"="fech_nac_y")%>%
   dplyr::select(-ends_with("_y"),-edad_inicio_sustancia_principal2, -edad_inicio_consumo2)%>%
   #sacar fechas de nacimiento inválidas, es decir, aquellas que son menores a la edad de inicio de consumo. Sólo un caso
   dplyr::mutate(edad_invalida=ifelse((edad_inicio_sustancia_principal>Prediction)|(edad_inicio_consumo>Prediction),1,0))%>%
   dplyr::filter(edad_invalida==0)%>%
    dplyr::mutate(fech_nac_corr=as.character(fech_nac_corr))

#39 usuarios
less_15_hash_more_one_age<-
      CONS_C1_df_dup_ENE_2020_prev52 %>%
      dplyr::filter(Edad_al_ing<15)%>%
        distinct(HASH_KEY)

CONS_C1_df_dup_ENE_2020_prev52_menos_15<-
CONS_C1_df_dup_ENE_2020_prev52 %>%
    dplyr::filter(HASH_KEY %in% as.character(unlist(less_15_hash_more_one_age[,c("HASH_KEY")])))%>%
   # dplyr::filter(HASH_KEY!="616a9f5147684b5bb649eff9936db849")%>%
    janitor::clean_names()%>%
            dplyr::select(row,hash_key,fech_nac,fech_ing, edad_al_ing, ano_bd, escolaridad_ultimo_ano_cursado,estado_conyugal,
                          numero_de_hijos,numero_de_hijos_ingreso_tratamiento_residencial,
                          edad_inicio_consumo,edad_inicio_sustancia_principal,fecha_ultimo_tratamiento)%>%
   dplyr::left_join(fech_nac_edad_al_ing_replace,"row", suffix=c("","_y"))%>%
   dplyr::rename("fech_nac_original"="fech_nac_y")%>%
   dplyr::select(-ends_with("_y"),-edad_inicio_sustancia_principal2, -edad_inicio_consumo2)%>%
   #sacar fechas de nacimiento inválidas, es decir, aquellas que son menores a la edad de inicio de consumo. Sólo un caso
   dplyr::mutate(edad_invalida=ifelse((edad_inicio_sustancia_principal>Prediction)|(edad_inicio_consumo>Prediction),1,0))%>%
   dplyr::filter(edad_invalida==0)%>%
    dplyr::mutate(fech_nac_corr=as.character(fech_nac_corr))


#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#HACER REEMPLAZO. 

#CONS_C1_df_dup_ENE_2020_prev52_NA
#CONS_C1_df_dup_ENE_2020_prev52_menos_16

CONS_C1_df_dup_ENE_2020_prev52 %>%
#NAs
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev52_NA, by=c("HASH_KEY"="hash_key"),suffix=c("","_NAs")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_ENE_2020_prev52_NA["hash_key"])))))~glue::glue("{OBS};1.6.XX.NAs_ANN"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_corr),as.character(fech_nac_corr),as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_NAs")) %>% 
  dplyr::select(-edad_al_ing, -escolaridad_ultimo_ano_cursado, -estado_conyugal, -numero_de_hijos,
                -numero_de_hijos_ingreso_tratamiento_residencial, -edad_inicio_consumo, -edad_inicio_sustancia_principal, -fech_nac_corr,
                -fecha_ultimo_tratamiento, -numero_de_hijos2, -edad, -fech_nac_original, -n_por_hash, -edad_invalida)%>% #fech_nac_corr
  # dplyr::filter(!is.na(fech_nac_corr))%>%
  dplyr::rename("Edad_al_ing_NAs"="Prediction")%>%
#menos 15
  dplyr::left_join(CONS_C1_df_dup_ENE_2020_prev52_menos_15, by=c("HASH_KEY"="hash_key"),suffix=c("","_menos_15")) %>%
  dplyr::mutate(OBS=case_when(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_ENE_2020_prev52_menos_15["hash_key"])))))~glue::glue("{OBS}1.6.XX.Age of less than 15 at admission"),TRUE~OBS))%>%  
  dplyr::mutate(fech_nac= ifelse(!is.na(fech_nac_corr),fech_nac_corr,as.character(fech_nac))) %>%
  dplyr::select(-ends_with("_menos_15")) %>% 
  dplyr::rename("Edad_al_ing_less15"="Prediction")%>%
  dplyr::select(-edad_al_ing, -escolaridad_ultimo_ano_cursado, -estado_conyugal, -numero_de_hijos, -numero_de_hijos_ingreso_tratamiento_residencial, -edad_inicio_consumo, -edad_inicio_sustancia_principal, -fecha_ultimo_tratamiento, -numero_de_hijos2, -fech_nac_original, -mean_pr, -diff_pr_ed_ing, -n_por_hash, -edad_invalida, -fech_nac_corr)%>%
#transformación de variables
  dplyr::mutate(id=`substr<-`(id,6,13,gsub("-", "",format(as.Date(lubridate::parse_date_time(as.Date(fech_nac),"Ymd")),"%d%m%Y")))) %>%
  #dplyr::mutate(id=`substr<-`(id,6,13,fech_nac)) %>%
  dplyr::mutate(id_mod=sub("(.{5}).", "\\1*",id)) %>%
  dplyr::mutate(id_mod=sub("(.{6}).", "\\1*",id_mod)) %>%
  dplyr::mutate(fech_nac=lubridate::parse_date_time(as.character(as.Date(fech_nac)),"Ymd")) %>%
  dplyr::mutate(ano_nac= as.numeric(stringi::stri_sub(as.character(fech_nac),1,4))) %>%
  dplyr::mutate(Edad= as.integer(lubridate::time_length(difftime(as.Date("2019-11-13"),as.Date(fech_nac)),"years"))) %>%
  dplyr::mutate(Edad_al_ing=lubridate::time_length(difftime(as.Date(fech_ing), as.Date(fech_nac)),"years")) %>%
  dplyr::mutate(Edad_al_ing=replace(Edad_al_ing, is.na(Edad), NA)) %>%
  assign("CONS_C1_df_dup_ENE_2020_prev53",., envir = .GlobalEnv)

#save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/2_5.Rdata")
```

<br>

### 4.3.Summary

By doing this, we lowered as much as possible the quantity of distinct information by HASH that may be contradictory. However, many of these inconsistencies can be resolved with SENDAs professionals. 

- Age (Edad) (`r CONS_C1_df_dup_ENE_2020_prev53 %>% group_by(HASH_KEY) %>% dplyr::mutate(Edad_por_hash=n_distinct(Edad)) %>% ungroup() %>% dplyr::filter(Edad_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- SENDAs ID (id) (`r CONS_C1_df_dup_ENE_2020_prev53 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_por_hash=n_distinct(id)) %>% ungroup() %>% dplyr::filter(id_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Masked SENDAs ID (id_mod) (`r CONS_C1_df_dup_ENE_2020_prev53 %>% group_by(HASH_KEY) %>% dplyr::mutate(id_mod_por_hash=n_distinct(id_mod)) %>% ungroup() %>% dplyr::filter(id_mod_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Year of Birth (ano_nac) (`r CONS_C1_df_dup_ENE_2020_prev53 %>% group_by(HASH_KEY) %>% dplyr::mutate(ano_nac_por_hash=n_distinct(ano_nac)) %>% ungroup() %>% dplyr::filter(ano_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)
- Date of Birth (fech_nac) (`r CONS_C1_df_dup_ENE_2020_prev53 %>% group_by(HASH_KEY) %>% dplyr::mutate(fech_nac_por_hash=n_distinct(fech_nac)) %>% ungroup() %>% dplyr::filter(fech_nac_por_hash>1) %>% nrow() %>%  formatC(, format="f", big.mark=",", digits=0)`)

<br>

## 5. Standardization of Some Variables

In this stage, we applied most of the recommendations made by SENDAs professionals:

- Deletion of cases in Parole (n= `r CONS_C1_df_dup_ENE_2020_prev53 %>% dplyr::filter(Tipo.de.Plan == "PAI LV") %>% nrow()`)
- Collapse the different plan types into the following: PG-PAB, PG-PAI, PG-PR, M-PAB, M-PAI, and M-PR.
- Standardize type of plan by sex and gender identity
- Declare as invalid the age of onset of drug use if they are higher than the actual age
- Declare as invalid if the age of drug use of the main substance.
- Declare pregnancy as invalid data in men
- Declare days treated as Invalid if their value is less than 0
- Define early and late drop-outs
- Collapse and Standardize Substances into the following categories: hallucinogens (such as LSD, mushrooms); cocaine; amphetamine-type stimulants (eg., methamphetamine, ecstasy); inhalants; marijuana; opioids (eg., heroin, methadone, painkillers); cocaine paste base and crack; other substances; sedatives, hypnotics and tranquilizers; and others (such as anabolic steroids)
- Declare as an invalid value the category “No substance use” in substance variables
- Collapse marital status into the following categories: Married or in shared living arrangements; separated or divorced; single; and widowed
- Collapse the occupational condition into an occupational status composed of three categories: Employed, Unemployed and Inactive
- Restrict the occupational category exclusively to users that responded being working
- Collapse Ages into five groups: More than 45 years, 36-45 years, 30-35 years, 25-29 years, and 18 to 24 years
- Collapse motive of admission to treatment into spontaneous consultation, referral from a health center (primary health care level or others from the private and public health network),referral from an SUD treatment center (or other drug-related programs such as FONODROGAS), stated from the judicial system (such as First instance and guarantee courts, family courts, or other attorneys offices), and other (such as the educational system, work, or social services not related to justice and health)
- Collapse educational attainment into three categories: completed primary school or less, completed or incomplete high school, more than high school
- Declare as an invalid value the category “Unknown” of the route of administration of the main substance
- Declare as an invalid value the category “Unknown” of the frequency of consumption of the main Substance

<br> 

```{r final_assignment_change_factors_recode, echo=T,cache=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020_prev53 %>%
  dplyr::filter(is.na(Tipo.de.Plan) | Tipo.de.Plan != "PAI LV") %>% #Deletion of cases in Parole. OJO, TAMBIÉN ELIMINO A NA'S, BAJO A 188086 CASOS. Rows= 57716, 9972 Y 6736. Con el is.na, los mantengo.
# Ver si se pueden reemlpazar. La verdad es que no hay otro ingreso.
#CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(concat %in% c("ebc40285ab6f4db453d9830453ec578a_2014_5_19", #"72c54d822de128e52f10511f3eb2d19f_2009_12_14", "03390de37aa8a95707905d07c33c0a97_2010_7_30"))
#LV se elimina el tipo de plan
  dplyr::mutate(OBS= case_when(Tipo.de.Plan %in% c("M-PAI2","M-PR2","PG PAI 2","Otro","CALLE") ~paste0(as.character(OBS),";","1.7.01. Collapsed Treatment Plans"),
                               TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(tipo_de_plan=dplyr::recode(Tipo.de.Plan,"M-PAI2"= "M-PAI", "M-PR2"="M-PR","PG PAI 2"="PG-PAI", "Otro"="PG-PR", "CALLE"="PG-PR"))%>%
#Table 10. Type of Plan by Gender Identity and Sex
#En SER 2020, dejé los Calle y Otro en PG-PAB, pero ahora lo dejaré en PG-PR
  dplyr::mutate(OBS= case_when(identidad.de.genero=="Masculino" & sexo=="Hombre" & tipo_de_plan %in% c("M-PAI", "M-PR", "M-PAB") ~paste0(as.character(OBS),";","1.7.02. Standardized Plans By Sex & Gender Id"),
                               TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(tipo_de_plan=ifelse(identidad.de.genero=="Masculino" & sexo=="Hombre" & tipo_de_plan=="M-PAI","PG-PAI", as.character(tipo_de_plan))) %>%
  dplyr::mutate(tipo_de_plan=ifelse(identidad.de.genero=="Masculino" & sexo=="Hombre" & tipo_de_plan=="M-PR","PG-PR", as.character(tipo_de_plan))) %>%
  dplyr::mutate(tipo_de_plan=ifelse(identidad.de.genero=="Masculino" & sexo=="Hombre" & tipo_de_plan=="M-PAB","PG-PAB", as.character(tipo_de_plan))) %>%
  dplyr::mutate(tipo_de_plan=as.factor(tipo_de_plan)) %>%
#Si la edad de inicio de consumo es mayor a la edad actual, lo mismo la edad de iniciación a la sustancia principal, las declaro perdidas.
  dplyr::mutate(OBS=case_when(Edad.Inicio.Consumo>Edad ~ paste0(as.character(OBS),";","1.7.03. Invalid Age Of Onset of Drug Use, Higher than age"),
                              TRUE ~ as.character(as.character(OBS))))%>% #dplyr::filter(Edad.Inicio.Consumo>Edad)
  dplyr::mutate(edad_ini_cons= ifelse(Edad.Inicio.Consumo<=Edad, Edad.Inicio.Consumo, NA)) %>%
  dplyr::mutate(OBS=case_when(Edad.Inicio..Sustancia.Principal.>Edad ~ paste0(as.character(OBS),";","1.7.04. Invalid Age Of Onset of Primary Substance, Higher than age"),
                           TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(edad_ini_sus_prin= ifelse(Edad.Inicio..Sustancia.Principal.<=Edad, Edad.Inicio..Sustancia.Principal., NA)) %>% #dplyr::filter(Edad.Inicio..Sustancia.Principal.>Edad)
  #CONS_C1_df_dup_ENE_2020_prev5 %>% dplyr::filter(Edad.Inicio.Consumo>20) %>% dplyr::mutate(edad_ini_cons= ifelse(Edad.Inicio.Consumo<=Edad, Edad.Inicio.Consumo, NA)) %>% dplyr::select(Edad, Edad.Inicio.Consumo, edad_ini_cons)
#Si se inicia en la sustancia principal o inicia el consum a una edad menor a 5 años, lo declaro como perdido.
  dplyr::mutate(OBS=case_when(edad_ini_cons<5 ~ paste0(as.character(OBS),";","1.7.05. Invalid Age Of Onset of Drug Use, < 5 yrs age"),
                              TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(edad_ini_cons= ifelse(edad_ini_cons<5,NA,edad_ini_cons)) %>%
  dplyr::mutate(OBS=case_when(edad_ini_sus_prin<5 ~ paste0(as.character(OBS),";","1.7.06. Invalid Age Of Onset of Primary Substance, < 5 yrs age"),
                              TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(edad_ini_sus_prin= ifelse(edad_ini_sus_prin<5,NA,edad_ini_sus_prin)) %>%
  #CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::filter(embarazo=="Si") %>% group_by(sexo) %>% summarise(n())
#Embarazos en hombres se declaran como perdidos
 #dplyr::mutate(OBS=if_else(embarazo=="Si" & sexo=="Hombre",paste0(as.character(OBS),";","1.7.07. Invalid Pregnancy= Pregnant Man"),  as.character(OBS)))%>%
   dplyr::mutate(OBS=case_when(embarazo=="Si" & sexo=="Hombre" ~paste0(as.character(OBS),";","1.7.07. Invalid Pregnancy= Pregnant Man"),
                                TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(embarazo= ifelse(embarazo=="Si" & sexo=="Hombre",NA,as.character(embarazo))) %>%
  #dplyr::mutate(embarazo= dplyr::recode("1"="No","2"="Si")) %>%
  dplyr::mutate(embarazo=as.factor(embarazo)) %>%
#     mutate(mpg=replace(mpg, cyl==4, NA)) %>%
#CAMBIOS DIAS
  dplyr::mutate(OBS=case_when(dias_trat<0 ~ paste0(as.character(OBS),";","1.7.08. Negative Treatment Days, Changed Treat Days"),
                           TRUE ~ as.character(OBS)))%>%
  dplyr::mutate(dias_trat=replace(dias_trat,dias_trat<0, NA)) %>%
    assign("CONS_C1_df_dup_ENE_2020_prev6",., envir = .GlobalEnv) 
#glue::glue("{OBS};1.7.07. Invalid Pregnancy= Pregnant Man"),OBS))
#157322 156785  dplyr::filter(row %in% c("157322", "156785"))
#dplyr::filter(row %in% c("157322", "156775","156785"))
#View(table(CONS_C1_df_dup_ENE_2020_prev6$OBS))
#View(table(CONS_C1_df_dup_ENE_2020$obs))

  #CONS_C1_df_dup_ENE_2020_prev3 %>% dplyr::mutate(dias_trat_alta_temprana=ifelse(dias_trat>90,0,1)) %>% dplyr::group_by(dias_trat_alta_temprana,motivodeegreso) %>% summarise(n())
  CONS_C1_df_dup_ENE_2020_prev6 %>% 
  dplyr::mutate(dias_trat_alta_temprana=ifelse(dias_trat>=90,0,1)) %>%
  dplyr::mutate(dias_trat_alta_temprana=as.factor(dias_trat_alta_temprana)) %>%
  dplyr::mutate(dias_trat_alta_temprana= dplyr::recode(dias_trat_alta_temprana, "1"="Menos de 90 días", "0"="Mayor o igual a 90 días")) %>%
  dplyr::mutate(motivodeegreso_mod= ifelse(dias_trat_alta_temprana=="Menos de 90 días" & motivodeegreso=="Abandono", "Abandono Temprano",as.character(motivodeegreso))) %>% 
  dplyr::mutate(motivodeegreso_mod= ifelse(dias_trat_alta_temprana=="Mayor o igual a 90 días" & motivodeegreso=="Abandono", "Abandono Tardio",as.character(motivodeegreso_mod))) %>% 
  dplyr::mutate(motivodeegreso_mod=as.factor(motivodeegreso_mod)) %>%
  #data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Sustancia.Principal))
  dplyr::mutate(sus_principal= as.character(Sustancia.Principal)) %>%
  dplyr::mutate(sus_principal= dplyr::recode(sus_principal,
                                             "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                             "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                             "Anfetaminas"="Estimulante tipo anfetaminas",
                                             "Extasis"="Estimulante tipo anfetaminas",
                                             "Fenilciclidina"="Estimulante tipo anfetaminas",
                                             "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                             "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                             "LSD"="Alucinógenos",
                                             "Otros Alucinógenos"="Alucinógenos",
                                             "Crack"="Pasta Base",
                                             "Heroína"="Opioides",
                                             "Metadona"="Opioides",
                                             "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                             "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                             "Esteroides Anabólicos"="Otros")) %>%
dplyr::mutate(sus_principal=as.factor(sus_principal)) %>%
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Otras.Sustancias.nº1))
  dplyr::mutate(otras_sus1=as.character(`Otras.Sustancias.nº1`)) %>%
  dplyr::mutate(otras_sus1= dplyr::recode(otras_sus1,
                                              "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucinógenos"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Heroína"="Opioides",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>%
dplyr::mutate(OBS=case_when(otras_sus1=="SIN CONSUMO" ~ paste0(OBS,";","1.7.09. Other Substances1, Invalid due to No Consumption"),
                            TRUE ~ OBS))%>%
dplyr::mutate(otras_sus1= dplyr::na_if(otras_sus1, "SIN CONSUMO")) %>%
dplyr::mutate(otras_sus1=as.factor(otras_sus1)) %>%        
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Otras.Sustancias.nº2))
  dplyr::mutate(otras_sus2=as.character(`Otras.Sustancias.nº2`)) %>%
  dplyr::mutate(otras_sus2= dplyr::recode(otras_sus2,
                                              "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucinógenos"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Heroína"="Opioides",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>%
dplyr::mutate(OBS=case_when(otras_sus2=="SIN CONSUMO"~paste0(OBS,";","1.7.10. Other Substances2, Invalid due to No Consumption"),
                         TRUE ~ OBS))%>%    
dplyr::mutate(otras_sus2= dplyr::na_if(otras_sus2, "SIN CONSUMO")) %>%
dplyr::mutate(otras_sus2=as.factor(otras_sus2)) %>%    
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Otras.Sustancias.nº3))
  dplyr::mutate(otras_sus3=as.character(`Otras.Sustancias.nº3`)) %>%
  dplyr::mutate(otras_sus3= dplyr::recode(otras_sus3,
                                              "Hipnóticos "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbitúricos, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucinógenos"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Heroína"="Opioides",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analgésicos: morfina, codeína, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, óxido nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>%
dplyr::mutate(OBS=case_when(otras_sus3=="SIN CONSUMO"~paste0(OBS,";","1.7.11. Other Substances3, Invalid due to No Consumption"),
                         TRUE ~ OBS))%>%    
dplyr::mutate(otras_sus3= dplyr::na_if(otras_sus3, "SIN CONSUMO")) %>%
dplyr::mutate(otras_sus3=as.factor(otras_sus3)) %>%    
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Sustancia.de.Inicio))
dplyr::mutate(sus_ini=as.character(Sustancia.de.Inicio)) %>%
dplyr::mutate(sus_ini= dplyr::recode(sus_ini,
                                              "Hipn?os "= "Tranquilizantes e Hipnóticos",
                                              "Sedantes:  diazepam, Valium, clonazepam, Ravotril, alprazolam, adax, barbit?os, fenobarbital." = "Tranquilizantes e Hipnóticos",
                                              "Anfetaminas"="Estimulante tipo anfetaminas",
                                              "Extasis"="Estimulante tipo anfetaminas",
                                              "Fenilciclidina"="Estimulante tipo anfetaminas",
                                              "Metanfetaminas y otros derivados"="Estimulante tipo anfetaminas",
                                              "Otros Estimulantes"="Estimulante tipo anfetaminas",
                                              "LSD"="Alucinógenos",
                                              "Otros Alucin?os"="Alucinógenos",
                                              "Crack"="Pasta Base",
                                              "Hero?"="Opioides",
                                              "Coca?"="Cocaína",
                                              "Metadona"="Opioides",
                                              "Otros Opioides Analg?cos: morfina, code?, meperidina,  demerol, tramadol, tramal."="Opioides",
                                              "Inhalables: neopren, GHB, ?o nitroso (gas hilarante), \"poppers\", solventes, gasolina, diluyente"="Inhalables",
                                              "Esteroides Anabólicos"="Otros",
                                              "Hongos"="Alucinógenos")) %>% 
dplyr::mutate(sus_ini=as.factor(sus_ini)) %>%    
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Estado.Conyugal))
#marital status (single, married/with partner, separated/divorced, widow)
dplyr::mutate(estado_conyugal=ifelse(as.character(Estado.Conyugal)=="Casado"|as.character(Estado.Conyugal)=="Conviviente"|as.character(Estado.Conyugal)=="conviviente civil", "Casado/Conviviente",stringr::str_trim(as.character(Estado.Conyugal)))) %>%
dplyr::mutate(estado_conyugal=ifelse(estado_conyugal=="Separado"|estado_conyugal=="Divorciado"|estado_conyugal=="Anulado", "Separado/Divorciado",estado_conyugal)) %>% 
dplyr::mutate(OBS=case_when(estado_conyugal=="Nocontesta"~paste0(OBS,";","1.7.12. Marital State, Invalid due to No Response"),
                            TRUE~OBS))%>%    
dplyr::mutate(estado_conyugal=ifelse(estado_conyugal=="Nocontesta",NA,estado_conyugal)) %>%
dplyr::mutate(estado_conyugal=as.factor(estado_conyugal)) %>%
#occupational status (inactive, unemployed, employed)  
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Condicion.Ocupacional))
#
#Esta variable busca establecer si la persona desarrolló alguna actividad laboral o productiva, es decir, si participó en la producción de un bien o servicio para la venta o para el autoconsumo, por un mínimo de una hora semanal en la semana anterior (lunes a domingo) a la entrevista. Los quehaceres del hogar no son considerados una actividad productiva o ‘razón de ocupación’.
#Si la respuesta es afirmativa se debe seleccionar la opción “Trabajando actualmente” Si la persona No Trabajó, interesa saber si está Desocupada (“busca trabajo por primera vez” o “cesante”) o Inactiva (que corresponde al resto de la opciones, quehaceres del hogar, estudiando, jubilado, etc.) 
#
#Inactivo, desempleado, empleado
#     Buscando trabajo por primera vez |        245        0.21        0.21
#                              Cesante |     43,299       36.67       36.87
#              Estudiando sin trabajar |      1,353        1.15       38.02
#Incapacitado permanente para trabajar |        294        0.25       38.27
#                                   NA |          1        0.00       38.27
#                     No busca Trabajo |      1,250        1.06       39.33
#                           Otra razón |      1,348        1.14       40.47
#   Pensionado o jubilado sin trabajar |      1,872        1.59       42.05
#                 Quehaceres del hogar |      7,683        6.51       48.56
#                             Rentista |         78        0.07       48.63
#                        Sin actividad |      7,449        6.31       54.93
#               Trabajando actualmente |     53,120       44.98       99.92
#              Trabajando y estudiando |         97        0.08      100.00
dplyr::mutate(estatus_ocupacional=ifelse(Condicion.Ocupacional=="Trabajando actualmente","Empleado",
                                         ifelse(Condicion.Ocupacional=="Buscando trabajo por primera vez"|Condicion.Ocupacional=="Cesante",
                                                "Desempleado","Inactivo"))) %>%
dplyr::mutate(estatus_ocupacional=as.factor(estatus_ocupacional)) %>%
#Comprende la relación entre una persona económicamente activa y su trabajo o empleo. Sólo se aplica aquellas personas que se encuentran trabajando al momento de ingresar a tratamiento (las que respondieron 1 en la pregunta anterior). Para las personas que no están trabajando (estudiantes, cesante, etc.) esta opción estará bloqueada.
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Categoría.Ocupacional))
dplyr::mutate(cat_ocupacional=ifelse(Condicion.Ocupacional!="Trabajando actualmente",NA,as.character(`Categoría.Ocupacional`))) %>%
dplyr::mutate(cat_ocupacional=as.factor(cat_ocupacional)) %>%
#18-24, 25- 29, 30-35, 36-45, and 45+.
dplyr::mutate(Edad_grupos=ifelse(Edad>45,">45",
      ifelse(Edad>=36,"36-45",
      ifelse(Edad>=30,"30-35",
      ifelse(Edad>=25,"25-29",
      ifelse(Edad>=18,"18-24",
      NA)))))) %>%
dplyr::mutate(Edad_grupos=as.factor(Edad_grupos)) %>%
# motive of admission to treatment (spontaneous consultation, referral from a health center, indicated in the judicial system, other)
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Origen.de.Ingreso))
dplyr::mutate(origen_ingreso=ifelse(as.character(Origen.de.Ingreso)=="Consulta Espontánea", "Consulta Espontánea",as.character(Origen.de.Ingreso))) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Establecimiento Educacional"|origen_ingreso=="Otros"|origen_ingreso=="Trabajo (empresa o empleador)"|origen_ingreso=="Servicios Sociales u otros (iglesia, Mideplan, ser. comunitarios, etc.)", "Otros",origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Juzgado con Competencia en Crimen"|origen_ingreso=="Juzgado de Garantía"|origen_ingreso=="Libertad Vigilada"|origen_ingreso=="Juzgado de Familia"|origen_ingreso=="Juzgado de Policía"|origen_ingreso=="Otros (fiscalía)","Sector Justicia",origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Otros de la Red de Salud General Privado"|origen_ingreso=="Estab. de APS"|origen_ingreso=="Estab. de APS "|origen_ingreso=="Otros de la Red de Salud General Público", "Sector Salud", origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=ifelse(origen_ingreso=="Otro Centro Tratamiento Drogas"|origen_ingreso=="FONODROGAS"|origen_ingreso=="Previene","Otro Centro Tratamiento Drogas/FONODROGAS/Previene",origen_ingreso)) %>%
dplyr::mutate(origen_ingreso=as.factor(origen_ingreso)) %>%
# education attainment (completed primary school or less, completed or incomplete high school, more that high school)
# data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Escolaridad..último.año.cursado.))
dplyr::mutate(escolaridad=ifelse(as.character(`Escolaridad..último.año.cursado.`)=="BASICA COMPLETA"|as.character(`Escolaridad..último.año.cursado.`)=="BASICA INCOMPLETA"|as.character(`Escolaridad..último.año.cursado.`)=="SIN ESTUDIOS","Ed Primaria Completa o Menor",as.character(`Escolaridad..último.año.cursado.`))) %>%
dplyr::mutate(OBS=case_when(escolaridad=="NO SABE O NO SE APLICA"~paste0(OBS,";","1.7.13. Educational Attainment, Invalid due to No Response"),
                            TRUE ~ OBS))%>%    
dplyr::mutate(escolaridad=ifelse(escolaridad=="MEDIA COMPLETA"|escolaridad=="MEDIA INCOMPLETA","Ed Secundaria Completa o Menor",
      ifelse(escolaridad=="NO SABE O NO SE APLICA",NA,
      ifelse(escolaridad %in% c("TECNICA COMPLETA", "TECNICA INCOMPLETA", "UNIVERSITARIA COMPLETA O MAS", "UNIVERSITARIA INCOMPLETA"), "Mayor a Ed Secundaria",escolaridad)))) %>%
dplyr::mutate(escolaridad=as.factor(escolaridad)) %>%
# pattern of drug used (daily, 4 to 6 days a week, 2 to 3 days a week, 1 day a week or less),
    #data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Vía.Administración..Sustancia.Principal.))
dplyr::mutate(via_adm_sus_prin=as.character(`Vía.Administración..Sustancia.Principal.`))%>%
dplyr::mutate(OBS=case_when(via_adm_sus_prin== "No sabe"~paste0(OBS,";","1.7.14. Route of Adm Primary Substance, Invalid due to Unknown"),
                            TRUE ~ OBS))%>%    
dplyr::mutate(via_adm_sus_prin=ifelse(via_adm_sus_prin== "No sabe",NA,as.character(via_adm_sus_prin))) %>%
dplyr::mutate(via_adm_sus_prin=as.factor(via_adm_sus_prin)) %>%
#data.table(table(CONS_C1_df_dup_ENE_2020_prev3$Frecuencia.de.Consumo..Sustancia.Principal.))
dplyr::mutate(freq_cons_sus_prin=as.character(Frecuencia.de.Consumo..Sustancia.Principal.))%>%
dplyr::mutate(OBS=case_when(freq_cons_sus_prin== "Desconocida"~paste0(OBS,";","1.7.15. Frequency of Consumption Primary Substance, Invalid due to Unknown"),
                            TRUE ~ OBS))%>%    
dplyr::mutate(freq_cons_sus_prin=ifelse(freq_cons_sus_prin== "Desconocida",NA,as.character(freq_cons_sus_prin))) %>%
dplyr::mutate(freq_cons_sus_prin=as.factor(freq_cons_sus_prin)) %>%
as.data.frame(.) %>%  
assign("CONS_C1_df_dup_ENE_2020",., envir = .GlobalEnv)
  
codebook::val_labels(CONS_C1_df_dup_ENE_2020$`Diagnóstico.Trs..Psiquiátrico.CIE.10`) <- c('En estudio(NA)' = 1,
'Esquizofrenia, trastorno esquizotípico y trastornos de ideas delirantes(F20-29)' = 2,
'Retraso Mental(F70-79)' = 3,
'Sin trastorno(NA)' = 4,
'Trastornos de la conducta alimentaria(F50)' = 5,
'Trastornos de la personalidad y del comportamiento del adulto(F60-69)' = 6,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 7,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos(F50-59)' = 8,
'Trastornos del Desarrollo Psicológico(F80-89)' = 9,
'Trastornos del humor (afectivos).(F30-39)' = 10,
'Trastornos mentales orgánicos, incluidos los sintomáticos(F00-09)' = 11,
'Trastornos neuróticos, secundarios a situaciones estresantes y somatomorfos(F40-49)' = 12,
'Trs. del comportamiento y de las emociones de comienzo habitual en la infancia y adolescencia(F90-98)' = 13)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$`X2.Diagnóstico.Trs..Psiquiátrico.CIE.10`) <- c('En estudio(NA)' = 1,
'Esquizofrenia, trastorno esquizotípico y trastornos de ideas delirantes(F20-29)' = 2,
'Retraso Mental(F70-79)' = 3,
'Sin trastorno(NA)' = 4,
'Trastornos de la conducta alimentaria(F50)' = 5,
'Trastornos de la personalidad y del comportamiento del adulto(F60-69)' = 6,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 7,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos(F50-59)' = 8,
'Trastornos del Desarrollo Psicológico(F80-89)' = 9,
'Trastornos del humor (afectivos).(F30-39)' = 10,
'Trastornos mentales orgánicos, incluidos los sintomáticos(F00-09)' = 11,
'Trastornos neuróticos, secundarios a situaciones estresantes y somatomorfos(F40-49)' = 12,
'Trs. del comportamiento y de las emociones de comienzo habitual en la infancia y adolescencia(F90-98)' = 13)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$`X3.Diagnóstico.Trs..Psiquiátrico.CIE.10`) <- c('En estudio(NA)' = 1,
'Esquizofrenia, trastorno esquizotípico y trastornos de ideas delirantes(F20-29)' = 2,
'Retraso Mental(F70-79)' = 3,
'Sin trastorno(NA)' = 4,
'Trastornos de la conducta alimentaria(F50)' = 5,
'Trastornos de la personalidad y del comportamiento del adulto(F60-69)' = 6,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 7,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos(F50-59)' = 8,
'Trastornos del Desarrollo Psicológico(F80-89)' = 9,
'Trastornos del humor (afectivos).(F30-39)' = 10,
'Trastornos mentales orgánicos, incluidos los sintomáticos(F00-09)' = 11,
'Trastornos neuróticos, secundarios a situaciones estresantes y somatomorfos(F40-49)' = 12,
'Trs. del comportamiento y de las emociones de comienzo habitual en la infancia y adolescencia(F90-98)' = 13)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$`Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10`) <- c('Abuso de sustancias que no producen dependencia(F55X)' = 1,
'Delirium no inducido por alcohol u otras sustancias psicotropas(F059)' = 2,
'Demencia en enfermedades clasificadas en otro lugar(F02)' = 3,
'Demencia sin especificación(F03)' = 4,
'Demencia vascular(F01)' = 5,
'Episodios depresivos(F32)' = 6,
'Factores psicológicos y del comportamiento en trastornos o enfermedades clasificados en otro lugar(F54)' = 7,
'Otros trastornos de ansiedad(F41)' = 8,
'Otros trastornos de la personalidad y del comportamiento del adulto(F68)' = 9,
'Otros trastornos de las emociones y del comportamiento de comienzo habitual en la infancia y adolescencia(F98)' = 10,
'Otros trastornos del desarrollo psicológico(F88)' = 11,
'Otros trastornos del humor (afectivos)(F38)' = 12,
'Otros trastornos mentales debidos a lesión o disfunción cerebral o a enfermedad somática(F06)' = 13,
'Otros trastornos neuróticos(F48)' = 14,
'Otros trastornos psicóticos no orgánicos(F28)' = 15,
'Psicosis no orgánica sin especificación(F29)' = 16,
'Reacciones a estrés grave y trastornos de adaptación(F43)' = 17,
'Síndrome amnésico orgánico no inducido por alcohol u otras sustancias psicotropas(F04)' = 18,
'Transformación persistente de la personalidad no atribuible a lesión o enfermedad cerebral(F62)' = 19,
'Trastorno bipolar(F31)' = 20,
'Trastorno de ideas delirantes inducidas(F24)' = 21,
'Trastorno de la personalidad y del comportamiento del adulto sin especificación(F69)' = 22,
'Trastorno del desarrollo psicológico sin especificación(F89)' = 23,
'Trastorno depresivo recurrente(F33)' = 24,
'Trastorno específico del desarrollo mixto(F83)' = 25,
'Trastorno esquizotípico.(F21)' = 26,
'Trastorno generalizado del desarrollo sin especificación(F849)' = 27,
'Trastorno mental orgánico o sintomático sin especificación(F09)' = 28,
'Trastorno mental sin especificación(F99)' = 29,
'Trastorno obsesivo-compulsivo(F42)' = 30,
'Trastornos de ideas delirantes persistentes.(F22)' = 31,
'Trastornos de la identidad sexual(F64)' = 32,
'Trastornos de la inclinación sexual(F65)' = 33,
'Trastornos de la personalidad y del comportamiento debidos a enfermedad, lesión o disfunción cerebral(F07)' = 34,
'Trastornos de las emociones de comienzo habitual en la infancia(F93)' = 35,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 36,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos sin especificación(F59)' = 37,
'Trastornos del comportamiento social de comienzo habitual en la infancia y adolescencia(F94)' = 38,
'Trastornos del humor (afectivos) persistentes(F34)' = 39,
'Trastornos disociales(F91)' = 40,
'Trastornos disociales y de las emociones mixtos(F92)' = 41,
'Trastornos disociativos (de conversión)(F44)' = 42,
'Trastornos específicos de la personalidad(F60)' = 43,
'Trastornos específicos del desarrollo del aprendizaje escolar(F81)' = 44,
'Trastornos esquizoafectivos(F25)' = 45,
'Trastornos generalizados del desarrollo(F84)' = 46,
'Trastornos Hipercineticos(F90)' = 47,
'Trastornos mentales y del comportamiento en el puerperio no clasificados en otro lugar(F53)' = 48,
'Trastornos mixtos y otros trastornos de la personalidad(F61)' = 49,
'Trastornos no orgánicos del sueño(F51)' = 50,
'Trastornos psicológicos y del comportamiento del desarrollo y orientación sexuales(F66)' = 51,
'Trastornos psicóticos agudos y transitorios(F23)' = 52,
'Trastornos somatomorfos(F45)' = 53)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$`X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10`) <- c('Abuso de sustancias que no producen dependencia(F55X)' = 1,
'Delirium no inducido por alcohol u otras sustancias psicotropas(F059)' = 2,
'Demencia en enfermedades clasificadas en otro lugar(F02)' = 3,
'Demencia en la enfermedad de Alzheimer(F00)' = 4,
'Disfunción sexual no orgánica(F52)' = 5,
'Episodios depresivos(F32)' = 6,
'Factores psicológicos y del comportamiento en trastornos o enfermedades clasificados en otro lugar(F54)' = 7,
'Otros trastornos de ansiedad(F41)' = 8,
'Otros trastornos de la personalidad y del comportamiento del adulto(F68)' = 9,
'Otros trastornos de las emociones y del comportamiento de comienzo habitual en la infancia y adolescencia(F98)' = 10,
'Otros trastornos del desarrollo psicológico(F88)' = 11,
'Otros trastornos del humor (afectivos)(F38)' = 12,
'Otros trastornos mentales debidos a lesión o disfunción cerebral o a enfermedad somática(F06)' = 13,
'Otros trastornos neuróticos(F48)' = 14,
'Otros trastornos psicóticos no orgánicos(F28)' = 15,
'Psicosis no orgánica sin especificación(F29)' = 16,
'Reacciones a estrés grave y trastornos de adaptación(F43)' = 17,
'Síndrome amnésico orgánico no inducido por alcohol u otras sustancias psicotropas(F04)' = 18,
'Transformación persistente de la personalidad no atribuible a lesión o enfermedad cerebral(F62)' = 19,
'Trastorno bipolar(F31)' = 20,
'Trastorno de ideas delirantes inducidas(F24)' = 21,
'Trastorno de la personalidad y del comportamiento del adulto sin especificación(F69)' = 22,
'Trastorno del desarrollo psicológico sin especificación(F89)' = 23,
'Trastorno depresivo recurrente(F33)' = 24,
'Trastorno esquizotípico.(F21)' = 25,
'Trastorno generalizado del desarrollo sin especificación(F849)' = 26,
'Trastorno mental orgánico o sintomático sin especificación(F09)' = 27,
'Trastorno mental sin especificación(F99)' = 28,
'Trastorno obsesivo-compulsivo(F42)' = 29,
'Trastornos de ideas delirantes persistentes.(F22)' = 30,
'Trastornos de la conducta alimentaria(F50)' = 31,
'Trastornos de la identidad sexual(F64)' = 32,
'Trastornos de la inclinación sexual(F65)' = 33,
'Trastornos de la personalidad y del comportamiento debidos a enfermedad, lesión o disfunción cerebral(F07)' = 34,
'Trastornos de las emociones de comienzo habitual en la infancia(F93)' = 35,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 36,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos sin especificación(F59)' = 37,
'Trastornos del comportamiento social de comienzo habitual en la infancia y adolescencia(F94)' = 38,
'Trastornos del humor (afectivos) persistentes(F34)' = 39,
'Trastornos disociales(F91)' = 40,
'Trastornos disociales y de las emociones mixtos(F92)' = 41,
'Trastornos disociativos (de conversión)(F44)' = 42,
'Trastornos específicos de la personalidad(F60)' = 43,
'Trastornos específicos del desarrollo del aprendizaje escolar(F81)' = 44,
'Trastornos esquizoafectivos(F25)' = 45,
'Trastornos generalizados del desarrollo(F84)' = 46,
'Trastornos Hipercineticos(F90)' = 47,
'Trastornos mixtos y otros trastornos de la personalidad(F61)' = 48,
'Trastornos no orgánicos del sueño(F51)' = 49,
'Trastornos psicóticos agudos y transitorios(F23)' = 50,
'Trastornos somatomorfos(F45)' = 51)
codebook::val_labels(CONS_C1_df_dup_ENE_2020$`X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10`) <- c('Delirium no inducido por alcohol u otras sustancias psicotropas(F059)' = 1,
'Demencia vascular(F01)' = 2,
'Episodios depresivos(F32)' = 3,
'Factores psicológicos y del comportamiento en trastornos o enfermedades clasificados en otro lugar(F54)' = 4,
'Otros trastornos de ansiedad(F41)' = 5,
'Otros trastornos de la personalidad y del comportamiento del adulto(F68)' = 6,
'Otros trastornos de las emociones y del comportamiento de comienzo habitual en la infancia y adolescencia(F98)' = 7,
'Otros trastornos del desarrollo psicológico(F88)' = 8,
'Otros trastornos del humor (afectivos)(F38)' = 9,
'Otros trastornos mentales debidos a lesión o disfunción cerebral o a enfermedad somática(F06)' = 10,
'Otros trastornos neuróticos(F48)' = 11,
'Otros trastornos psicóticos no orgánicos(F28)' = 12,
'Psicosis no orgánica sin especificación(F29)' = 13,
'Reacciones a estrés grave y trastornos de adaptación(F43)' = 14,
'Síndrome amnésico orgánico no inducido por alcohol u otras sustancias psicotropas(F04)' = 15,
'Transformación persistente de la personalidad no atribuible a lesión o enfermedad cerebral(F62)' = 16,
'Trastorno bipolar(F31)' = 17,
'Trastorno de ideas delirantes inducidas(F24)' = 18,
'Trastorno de la personalidad y del comportamiento del adulto sin especificación(F69)' = 19,
'Trastorno del desarrollo psicológico sin especificación(F89)' = 20,
'Trastorno depresivo recurrente(F33)' = 21,
'Trastorno específico del desarrollo mixto(F83)' = 22,
'Trastorno específico del desarrollo psicomotor(F82)' = 23,
'Trastorno esquizotípico.(F21)' = 24,
'Trastorno mental orgánico o sintomático sin especificación(F09)' = 25,
'Trastorno mental sin especificación(F99)' = 26,
'Trastorno obsesivo-compulsivo(F42)' = 27,
'Trastornos de ideas delirantes persistentes.(F22)' = 28,
'Trastornos de la conducta alimentaria(F50)' = 29,
'Trastornos de la identidad sexual(F64)' = 30,
'Trastornos de la inclinación sexual(F65)' = 31,
'Trastornos de la personalidad y del comportamiento debidos a enfermedad, lesión o disfunción cerebral(F07)' = 32,
'Trastornos de las emociones de comienzo habitual en la infancia(F93)' = 33,
'Trastornos de los hábitos y del control de los impulsos(F63)' = 34,
'Trastornos del comportamiento asociados a disfunciones fisiológicas y a factores somáticos sin especificación(F59)' = 35,
'Trastornos del comportamiento social de comienzo habitual en la infancia y adolescencia(F94)' = 36,
'Trastornos del humor (afectivos) persistentes(F34)' = 37,
'Trastornos disociales y de las emociones mixtos(F92)' = 38,
'Trastornos disociativos (de conversión)(F44)' = 39,
'Trastornos específicos de la personalidad(F60)' = 40,
'Trastornos específicos del desarrollo del aprendizaje escolar(F81)' = 41,
'Trastornos esquizoafectivos(F25)' = 42,
'Trastornos Hipercineticos(F90)' = 43,
'Trastornos mixtos y otros trastornos de la personalidad(F61)' = 44,
'Trastornos no orgánicos del sueño(F51)' = 45,
'Trastornos psicológicos y del comportamiento del desarrollo y orientación sexuales(F66)' = 46,
'Trastornos psicóticos agudos y transitorios(F23)' = 47,
'Trastornos somatomorfos(F45)' = 48)

#http://www.edras.cl/wg/data.edras.cl/resources-files-repository/Clasificacion_de_trastornos_mentales_CIE10.pdf
```

```{r generate data in csv, echo=T, paged.print=TRUE}
write.csv2(CONS_C1_df_dup_ENE_2020, file ="CONS_C1_df_dup_ENE_2020.csv")
```

&nbsp;
<br>

## 6. Exploratory Probabilistic Deduplication

<div class = "blue">

One of the main objectives of this stage of the project is to **identify and separate each treatments for each user in a given time as a unique entity**. This is shown in  [diagram of data preparation]( https://raw.githubusercontent.com/FONDECYTACC/SUD_health_Chile.github.io/master/Figures/RUT_Administraci%C3%B3n.svg). The standardization of the age let us reduce a great amount of comparisons between every pair of records, making matching more feasible in terms of computational resources. For example, if we decided to compare each pairs under consideration, we would have the number of cases (n= `r  formatC(as.numeric(nrow(CONS_C1_df_dup_ENE_2020)), format="f", big.mark=",", digits=0)`) multiplied by itself, leading to a total of  `r formatC(as.numeric(nrow(CONS_C1_df_dup_ENE_2020))*as.numeric(nrow(CONS_C1_df_dup_ENE_2020)), format="f", big.mark=",", digits=0)` comparisons. To reach our objective, it was necessary to **explore the principal causes that explain why or how a case matched with another**. From [duplicated cases](Duplicates#3_focus_on_duplicated_cases_and_dates_of_admission), we knew how many records shared the same HASH and date of admission. But we needed to explore whether there would be other possible rules that would help to identify distinct treatments.
</div>

### 6.1 Perfect Duplicates of HASH and Date of Admission


```{r tab13_duplicated_rows, echo=T, paged.print=TRUE}
#create the duplicated dataset, following the recommendation to separate columns
duplicated_rows_concat <- data.frame(duplicated_HASH_date = duplicated(CONS_C1_df_dup_ENE_2020[,c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")]), 
                                     row_dup_HASH_date = 1:nrow(CONS_C1_df_dup_ENE_2020[,c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")])) #%>%
  #arroja 117,620 casos únicos, aunque son muchos menos
as.data.table(CONS_C1_df_dup_ENE_2020)[, dup_hash_date := .N, by = c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")] %>% ##dim() #arroja 117,190 casos únicos. PERO CUIDADO: EN LOS QUE TIENEN 2, 3, 4, 5 Y MÁS, HAY CASOS QUE SON ÚNICOS TAMBIÉN (POR ESO UN DISTINCT NO LOS CAPTURA)
  dplyr::group_by(dup_hash_date) %>%
  dplyr::summarise(n=n()) %>%
  dplyr::mutate(perc = round(n / sum(n),2)*100) %>%
  dplyr::mutate(perc = paste0(perc,"%")) %>%
  dplyr::mutate(Tot.Cases = n/dup_hash_date) %>%
# Duplicated rows
#  data.frame(table(duplicated_rows_concat$duplicated_HASH_date,exclude=NULL),
#            `%`=paste0(round(prop.table(table(duplicated_rows_concat$duplicated_HASH_date,exclude=NULL)),3)*100,"%")) %>%
# as.data.frame(.) %>%  
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 13. Times that the combination of HASH-Key & Date of Admission may appear in the dataset", 
               col.names= c("Times", " Frequencies", "Percentage", "Unique Cases"),  align =rep('c', 4))  %>%
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 12)
```

<br>

In Table 13 we can see that most of the cases had at least one case with the same combination of HASH-Key and date of admission.

<br>

```{r fig4_dup_rows, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F, fig.cap= "Figure 4. Duplicated entries by year and quarter"}
require(zoo)
#CONS_C1_df_dup_ENE_2020 %>%
as.data.table(CONS_C1_df_dup_ENE_2020)[, dup_hash_date := .N, by = c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")] %>% 
  dplyr::mutate(fech_ing_qrt=zoo::as.yearqtr(fech_ing)) %>%
  dplyr::select(fech_ing_qrt,dup_hash_date) %>%  dplyr::group_by(fech_ing_qrt) %>% 
  dplyr::summarise(duplicated = sum(dup_hash_date>1),n = sum(dup_hash_date), perc_dup=duplicated/n) %>%
  dplyr::filter(fech_ing_qrt>=2007) %>%
  ggplot2::ggplot(aes(x = fech_ing_qrt, y = perc_dup, label = paste0("n=",n))) +
  geom_line(color = "#0076A8", size=1) +
  #geom_text(aes(x = fech_ing_qrt, y = perc_dup-0.05, label = paste0(n)), vjust = -1,hjust = 0, angle=45, size=3) +
  sjPlot::theme_sjplot2() +
  labs(y="% of Duplicated Data",x="Years & Quarters, Date of Admission",caption="Note. Two cases with date of admission before 2007 were ignored; Percentages indicate the number of entries that have the \n same HASH & date of admission one or more times divided by the number of cases that are admitted in each quarter and \nyear.") + 
  scale_y_continuous(limits=c(0, .075),labels = scales::percent) +
  scale_x_yearqtr(format="%YQ%q", n=20) +
  theme(axis.text.x = element_text(vjust = 0.5,hjust = 0.5,angle = 60), plot.caption=element_text(hjust=0)) 
#PARA RESULTADOS
dup_cases_quarter_n<-data.table::as.data.table(CONS_C1_df_dup_ENE_2020)[, dup_hash_date := .N, by = c("HASH_KEY","fech_ing_ano","fech_ing_mes","fech_ing_dia")] %>% dplyr::filter(dup_hash_date>1) %>% nrow()
```

<br>

From Figure 4, we can see that people that admitted to treatments from 2007 to 2008 presented most of the duplicated cases, while treatments that started from the second semester of 2015 had almost no duplicated cases. (n= `r dup_cases_quarter_n`).

<br>

Cases shown in Table 13 represent exact matches. **But at this stage of the research, we needed to detect more complex patterns, in terms of cases with similar HASH-Key and date of admission. This approach is merely exploratory and aims to find cases with imperfect agreements on one or more of the variables. Once some variables are standardized, we would be able to use this approach to detect and replace values and erase duplicated cases**, we ran data into a package in the software Stata called `dtalink`, with the following criteria:

1.	Hash Key: if matched, sum 25 points; if not, subtract 25 points
2.	SENDA’s ID: if matched, sum 25 points; if not, subtract 25 point
3.	Sex: if matched, sum 10 points
4.	Center ID: if matched, sum 10 points
5.	Date of Admission: if matched, sum 30 points; if not, subtract 30 points. Also, we added a caliper of 5 days to still consider as a match a difference of 5 days or less.
6.	We added a **Blocking variable of Age**, to reduce the time of computation and match of each case within people with the same Age.
7.	We consider a significant match if it accumulates at least 70 points.

<br>

The code used in stata is shown here:

<br>

```{stata, collectcode=TRUE}
import delimited "G:\Mi unidad\Alvacast\SISTRAT 2019 (github)\SUD_CL\CONS_C1_df_dup_ENE_2020.csv", delimiter(";") clear 

cap gen date_in = mdy(real_fech_ing_mes, real_fech_ing_dia, real_fech_ing_ano)
cap gen date_in = mdy(fech_ing_mes, fech_ing_dia, fech_ing_ano)

generate id_match = _n
cap drop _id
dtalink hash_key 25 -25 id 25 -25 sexo 10 0 idcentro 10 0 date_in 30 -30 5, block(edad) cutoff(70)
drop if missing(_score)
qui save "G:\Mi unidad\Alvacast\SISTRAT 2019 (github)\Stata Duplicates Match\_CONS_C1_df_match70_2020_02_11.dta", replace
```

```{r  tab14_dta_import, include=T, echo=T, eval=T, cache=T}
matches_from_stata_c1 <- haven::read_dta("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/Stata Duplicates Match/_CONS_C1_df_match70_2020_02_11.dta")
matches_from_stata_c1 <-matches_from_stata_c1 %>% dplyr::rename(score = 3, matchID = 1, row_id=2) 
matches_from_stata_c1  %>%
  dplyr::arrange(score,matchID,hash_key) %>%
  dplyr::select(score, matchID, hash_key, ano_bd, idcentro, date_in, fech_ing, fech_egres, edad, dias_trat) %>%
  as.data.frame() %>%
    knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 14. Preliminary View of Matches from Stata", align =rep('c', 100),
                 col.names= c("Score", " Pair ID", "HASH Key", "Yearly Dataset", "Center ID", "Date of\n Admission (num)", "Date of\nAdmission", "Date of\nDischarge", "Age", "Days of\n Treatment")) %>%
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
    kableExtra::scroll_box(width = "100%", height = "350px")
```
<br>

An a analysis of probabilistic matches between events by the requirements listed above, showed us 1 case with a missing value in the date of admission, (correspondent to the HASH KEY "6c409c18bf7cc518819dc63c4e8e98ef"), `r matches_from_stata_c1 %>% dplyr::filter(score<100) %>% nrow()/2` matches with a value of 90 points, and `r matches_from_stata_c1 %>% dplyr::filter(score==100) %>% nrow()/2` matches with 100 points (`r matches_from_stata_c1 %>% group_by(score) %>% count() %>% ungroup() %>% mutate(perc=paste0(round(n/sum(n),2)*100,"%")) %>% filter(score==100) %>% dplyr::select(-score,-n) %>% as.data.table(.)%>%as.character()`). 

<br>

```{r  Case with no date of admission, include=F, eval=F}
CONS_C1 %>%
  dplyr::filter(HASH_KEY=="6c409c18bf7cc518819dc63c4e8e98ef") %>%
  #dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres, dias_trat,tipo_de_plan, tipo_de_programa, ID.centro, Edad) %>%
  head()
CONS_C1_df_dup_ENE_2020 %>%
  dplyr::filter(HASH_KEY=="6c409c18bf7cc518819dc63c4e8e98ef") %>%
  dplyr::select(row, ano_bd, HASH_KEY, id_mod, ano_nac, ano_bd,fech_ing, fech_egres, dias_trat,tipo_de_plan, tipo_de_programa, ID.centro, Edad) %>%
  head()
```

```{r Fig_4, fig.height=4, fig.width=8, warning=FALSE, fig.align = "center", message=F, fig.cap=paste0("Figure 5. Histogram of HASH Keys in matches (n=",matches_from_stata_c1 %>% group_by(hash_key) %>% summarise(n=n()) %>% nrow(), ")")}
#quantile(matches_hash_freq$n, .80)
#summary(matches_hash_freq)
#
#quantile(Duplicates_Matching_ene_2020$n, prob)
matches_from_stata_c1 %>% group_by(hash_key) %>% summarise(n=n()) %>% as.data.frame() %>%dplyr::select(n) %>% 
ggplot(aes(n)) +
  geom_histogram(alpha=.5)+
  labs(y = "Freq.")+
  scale_x_continuous(name="Repetitions", breaks=seq(2,12,1)) +
  theme_classic()
```

<br>

As seen in Figure 5, around 93% of HASHs involved in matching appeared around `r matches_from_stata_c1 %>% group_by(hash_key) %>% summarise(n=n()) %>% as.data.frame() %>%dplyr::select(n) %>% summarise(q=quantile(n,.93))` times (mainly due to the coincidence of HASH Keys). The remaining 7%, repeated `r matches_from_stata_c1 %>% group_by(hash_key) %>% summarise(n=n()) %>% as.data.frame() %>%dplyr::select(n) %>% summarise(q=quantile(n,.935)) %>% round(0)` times or more.

<br>

### 6.2 Examples of Matches and Main Causes that Produce Them

```{r tab15_saving dates_w_o_discharge_date, echo=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020 %>%
dplyr::filter(row %in% c(149670,142875,8809,6864,151245,145140,160070,160066,135212,135017,85501,44753,41263,32299,12180,8809,14057,12517,14057
,8752, 8013, 13040,6202,8799,6334,5571,2319,5530,3865,71542,54760,66467,46349,66785,54953,90796,83766,67549,58436,54973,47284,73114,72579,51619,45002,61572,61353,52659,54383)) %>% 
  dplyr::arrange(factor(row, levels = c(149670,142875,8809,6864,12180,151245,145140,160070,160066,135212,135017,85501,44753,41263,32299,14057,12517,8752,8013,13040,6202,8799,6334,5571,2319,5530,3865,71542,54760,66467,46349,66785,54953,90796,83766,67549,58436,54973,47284,73114,72579,51619,45002,61572,61353,52659,54383))) %>%
  dplyr::select(row,HASH_KEY, ano_bd, id_mod,Edad,Sexo,Nombre.Centro,ID.centro,fech_ing,fech_egres,dias_trat,motivodeegreso,tipo_de_programa,tipo_de_plan,SENDA) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               col.names= c("Row", "HASH_KEY", "Year of\nDataset", "ID","Year", "Sex", "Name of\nthe Center", "Center ID", "Date of\nAdmission", "Date of\n Discharge", "Treatment Days", "Cause of\nDischarge", "Type of\nProgram", "Type of\nplan", "SENDA\nProgram"),
                   caption="Table 15. Example of probabilistic matches", align =rep('c', 101)) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8)  %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
```

<br>


In Table 15, there is a selection of probabilistic matches that have elements that are worthy of discussion. Most of them have much information in common, describing referrals to another center or parallel treatments, and others do not overlap but were match due to the span of +/-5 days as caliper in the date of admission. However, some characteristics change and are different between them. This process requires caution to prevent automatically delete one row and drop information that might be useful.

<br>

- The SENDAs ID JOCA1**071981 shares the same date of admission and center id. One of the cases is not part of the SENDA Program. The type of plan differs between them.
- JOMA1**031956 has three entries with dates of admission and in the same center on approximately the same dates (one of the registries have a difference of two days of 2 days in the admission). First, this user had an administrative discharge, and then a referral. Finally, the last entry came from the dataset of 2011 and indicated a referral to another center in 2012. The type of plan differs between them.
- LEMO2**101983 shares the same dates of admission and center, but different types of plan. One comes from the dataset of 2018, while the other comes from the dataset of 2019. Both do not have a date of discharge nor a cause of discharge. Possibly, these treatments are the same, and still in progression.
- ALOL1**101981 was one day in a treatment on 2019-07-27 that ended because of a drop-out one day later and was not a program of SENDA. Then he registered another treatment in the same center and possibly did not leave it until the day the dataset was retrieved .
- Different is the case of DAAS2**091996: both treatments share the same date of admission and center, but first was admitted in treatment for 5 days in the same center, and then ended due to a referral, leading to the next treatment. Although the first treatment did not figure as a SENDA program.
- VAPR2**041981 has two programs with the same date of admission in the same center: one comes from a dataset of 2016, the other from a dataset of 2013. Both programs figure as SENDAs programs, but the first was a general-population plan, and the second was a women-specific.
- GAPE1**121980 registries were obtained from the same yearly dataset, and share the same date of admission and center, but not the date of discharge. One ended in April of 2013 due to an administrative discharge, while the second ended in 2014 due to a referral. SENDA finances both.
- JOSE1**121964 has 2 registries from the dataset of 2011 that share the same date of admission and center. However, one ended in January due to a referral, while the other ended in June due to an administrative discharge. Both had different plans, and SENDA financed both.
- ALNU1**051977 has two registries that share the same date of admission but not the same date of discharge. The first came from a dataset of 2010, ended in November of 2011 due to a drop-out, and SENDA financed it. The second came from a dataset of 2011 and ended due to an administrative discharge in April of 2011, but SENDA did not finance it. Also, they do not share the same treatment plan.
- ALNE1**101974 registries were obtained from the same yearly dataset, and share the date of admission and center, but not the plan and the date of discharge. The first was a basic plan that ended in May of 2010 due to a referral. The second was an intensive-treatment plan that ended in September of 2010 due to an administrative discharge. The third was a basic plan that ended in August of 2011 due to a drop-out. SENDA financed them all.
- PAGA2**121972 registries were obtained from the dataset of 2010, share the same date of admission, but not the same date of discharge or type of plan  . The first was a basic plan that ended in February 2010 due to a referral. The second was an intensive-treatment plan that ended April of 2010 due to a referral. Finally, the third was an intensive-treatment plan that ended in 2011 due to an administrative discharge. SENDA financed them all.
- BACA1**011979 share the same date of admission, but different center and date of discharge. The first treatment came from the dataset of 2014 and ended in January of 2015 due to an administrative discharge. The second came from the dataset of 2015 and ended in April of 2015 due to an administrative discharge. SENDA financed them all.
- CLCA2**051976 has a difference of three days in the date of admission of two treatments in different centers. The first came from the dataset of 2013 and ended in January of 2014 due to a referral. The second came from a dataset of 2015 and ended in January of 2015 due to a referral. SENDA financed both treatments.
- The SENDAs ID CLTO2**101979 shares the same date of admission. The first came from the dataset of 2014 and ended in February of 2014 due to a referral to another center. The second came from the dataset of 2015 and ended due to a therapeutic discharge in March 2015. SENDA financed both treatments.
- LUCA1**051994 has two days of difference in the date of admission and followed a clear transition between treatments. Also, they have different plans, center, yearly dataset, and date of discharge. The first treatment appeared in the dataset of 2015, followed an intensive-treatment plan, started in 2015-11-17, and ended two days later due to a referral. The second treatment was a residential plan, came from the dataset of 2015, started from 2015-11-19, and ended in March of 2016 due to a referral. SENDA financed both treatments.
- MEGU2**121979 shows a difference of two days in the date of admission of their treatments, but different dates of discharge and treatment plans. The first treatment was a women-specific residential plan that came from 2014 and ended in June of 2014 due to a drop-out. The second general population program with intensive-treatment came from a yearly dataset of 2015 and ended in February of 2015 due to a therapeutic discharge. SENDA financed both treatments.
- MIOY1**031990 has a difference of only two days in the date of admission in their treatments, but centers are different as well as the date of discharge. The first came from a dataset of 2013 and ended in January of 2014 due to a referral. The second treatment came from the yearly dataset of 2014 and ended in January of 2015 due to a drop-out. SENDA financed both treatments.
- MOVA1**041983 registries were obtained from the same yearly dataset, but have a difference of five days between the different dates of admission, resulting in an overlapping of three days. Also, they have different treatment plans and center. The first treatment was an intensive-treatment plan and ended in 2014-02-19 due to a referral, while the second was residential plan treatment that started in 2015-02-16 and ended in March 2015 due to a referral. SENDA financed both treatments.
- PAHE1**111981 has three days of difference in the date of admission. Also, they have different plans and center. The first treatment appeared in the dataset of 2013, started in 2013-10-14, and ended on the same date due to an administrative discharge. The second treatment came from the dataset of 2014, started from 2013-10-11, and ended in January of 2014 due to a drop-out. SENDA financed both treatments.
- ROMA1**011979 registries came from the same yearly dataset, but their dates of admission are different by one day, and centers and dates of discharge are different. The first treatment came from a general population program with an intensive-treatment plan and ended in September 2014 due to a drop-out. The second treatment corresponded to another program, a residential plan, and ended in November of 2014 due to a referral. SENDA did not finance this treatment.
- YAPO2**121989 registries were obtained from the same yearly dataset and share the same date of admission and date of discharge, but not the same center. Additionally, the center “CT Puerta Abierta (Estacion Central)” is not financed by SENDA.

### 6.3 Overlappings

An analysis of duplicated events showed that **many ranges between the dates of admission and discharge were overlapping due to referral to other centers**, principally by changes in the center of treatment, being the following the most repeated among cases: Centro Tratamiento Adicciones Unidos, Hospital Santa Cruz; and Centro de Tratamiento Adicciones Esperanza, Hospital Santa Cruz. Differently put, many users may move from centers 221 to 591, 147 to 358, 164 to 325, or 200 to 203. However,**to identify overlappings in treatments, it is necessary to obtain the missing dates and clean the dates that may be wrongly registered**.

<br>

<div class="superbigimage">
```{r  Fig5, fig.height=8, fig.width=10, warning=FALSE, fig.align = "center", message=F, cache=T, fig.cap="Figure 6.1 Trajectories of HASHs from dates of admission to discharge"}
CONS_C1_df_dup_intervals<- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::rename("HASH_KEY_2"="HASH_KEY", "row2"="row") %>%
  dplyr::select(row2,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso, SENDA) %>% 
  dplyr::filter(motivodeegreso!="Derivación") %>%
  data.table::as.data.table()
require(sqldf)
require(gridExtra)
  overlap_dates_C1 <- janitor::clean_names(sqldf("SELECT *
                 FROM CONS_C1_df_dup_intervals AS x  
                 INNER JOIN CONS_C1_df_dup_intervals AS y 
                 ON x.HASH_KEY_2 == y.HASH_KEY_2 AND 
                 x.fech_ing_num2 < y.fech_egres_num2 AND x.fech_egres_num2 > y.fech_ing_num2 AND x.row2 != y.row2"))  
  #busca mismo hash, distinto row,pero fecha de ingreso menor o igual a la fecha de egreso del otro, y fecha de egreso mayor o igual a la fecha de ingreso del otro. ESTO ES PARA VER SI SE SUPERPONEN.
as.data.table(overlap_dates_C1) %>%
    dplyr::arrange(hash_key_2, fech_ing_num2, row2) %>% ggplot(.) + 
  geom_segment(aes(x = fech_ing, xend = fech_egres,
                   y = hash_key_2, yend = hash_key_2)) + 
      scale_x_datetime(breaks=scales::date_breaks("1 year"), 
                  limits = as.POSIXct(c('2000-01-01 09:00:00','2020-01-01 09:00:00')),
                  labels = scales::date_format("%m/%y")) +
  theme(axis.line=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_text(""),legend.position="none",
          panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),plot.background=element_blank()) +
  theme(plot.caption = element_text(hjust = 0, face= "italic")) +
    labs(x = "Dates of admission and discharge", y = "", caption="Note. Only users that share characteristics and overlap between them")
```

</div>

<br>

Figure 6.1 shows `r nrow(overlap_dates_C1)` record pairs that share the same HASH Key, but the date of admission is lesser than the date of discharge of another entry in the dataset, and the date of discharge is greater than the date of admission of that other case. It does not include derivation as a cause of the discharge. These conditions let us see how many cases overlap with another entry in the dataset. This graphic may seem a bit noisy because it covers all the overlapped cases, but we should see less the black colored regions, and more the white areas between lines to get an idea of the years that accumulates more overlappings.

<br>

```{r  Fig 5_v3, fig.height=14, fig.width=8, warning=FALSE, fig.align = "center", message=F, cache=T}
c26 <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "gray16", "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown", "gray40")

  set.seed(667)
  random<-round(runif(1, 1, 26),0)
sample_plot <- overlap_dates_C1 %>% 
    dplyr::arrange(hash_key_2, fech_ing_num2, row2) %>% 
  dplyr::slice(random:(random+26)) %>%
  mutate(Date = format(as.Date(fech_ing, format = "%Y-%m-%d"))) %>% 
  ggplot(aes()) + 
  geom_segment(aes(x = fech_ing, xend = fech_egres,
                   y = hash_key_2, yend = hash_key_2,colour=as.factor(row2),size=1/100)) + 
    scale_x_datetime(breaks=scales::date_breaks("1 year"), 
                  limits = as.POSIXct(c('2014-01-01 09:00:00','2020-01-01 09:00:00')),
                  labels = scales::date_format("%m/%y")) +
  theme(axis.line=element_blank(),axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_text(""),legend.position="none",axis.title.y=element_text("HASHs"),
          panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),plot.background=element_blank()) +
  #scale_x_date(breaks = scales::date_breaks("1 year"), date_labels = "%b %d") +
    theme(plot.caption = element_text(hjust = 0, face= "italic")) +
  scale_color_manual(values=c26) +
    labs(x = "Dates of admission and discharge", y = "", caption="Note. Only users that share characteristics overlap between them",
         subtitle="Random sample of 25 cases. Colored lines represent different rows in the dataset, but same HASH")+
    ggtitle("Figure 6.2 Trajectories of every HASH from dates of admission to discharge")
    #+
  #geom_text(vjust = -0.5, hjust=0, size = 1,
  #          aes(x = start_date, y = membershipID, 
  #              label = paste(round(mo_dur, 2), "months")))

clean_plot <- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(HASH_KEY_2=HASH_KEY) %>%
  dplyr::select(row,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso, SENDA)%>%     as.data.table() %>%
  dplyr::filter(HASH_KEY_2 %in% c("07b0d5b1e32b62374685e48039ae6a67",	"0b810dfb7988e5e795b03a9cadc771fe", "0c3aa4566acbeb996e4bf645c7210f83", "01a95b45fa9acf445fe1a7106f2f6664")) %>%
  dplyr::arrange(HASH_KEY_2, fech_ing_num2, row) %>% 
  #mutate(Date = format(as.Date(fech_ing, format = "%Y-%m-%d"))) %>% 
  ggplot(aes()) + 
  geom_segment(aes(x = as.POSIXct(as.Date(fech_ing_num2)), xend = as.POSIXct(as.Date(fech_egres_num2)),
                   y = HASH_KEY_2, yend = HASH_KEY_2,colour=as.factor(row),size=1/100)) + 
    scale_x_datetime(breaks=scales::date_breaks("1 year"), 
                  limits = as.POSIXct(c('2014-01-01 09:00:00','2020-01-01 09:00:00')),
                  labels = scales::date_format("%m/%y")) +
  theme(axis.line=element_blank(),
          axis.ticks=element_blank(),axis.title.y=element_text("HASHs"),axis.text.y=element_blank(),
          axis.title.x=element_text(""),legend.position="none",
          panel.background=element_blank(),panel.border=element_blank(),panel.grid.major=element_blank(),
          panel.grid.minor=element_blank(),plot.background=element_blank(), plot.title = element_text(hjust = 0))+
  #scale_x_date(breaks = scales::date_breaks("1 year"), date_labels = "%b %d") +
    theme(plot.caption = element_text(face= "italic",hjust = 0)) +
    labs(x = "Dates of admission and discharge", y="HASHs", 
         subtitle="Example of 4 clean trajectories. Colored lines represent different rows in the dataset, but same HASH")+
      ggtitle("Figure 6.3 Trajectories of every HASH from dates of admission to discharge")

grid.arrange(sample_plot, clean_plot)
```

<br>

In Figure 6.2, we selected 25 randomly assigned cases with overlapped treatments. We may appreciate that horizontal lines (users) had overlapped colors (treatments) over time. In contrast, Figure 6.3 shows four examples of clear trajectories that do not have overlaps over time and are separated by a white gap.

<br>

### 6.4 Missing Dates of Discharge

<br>

As can be seen in the examples of matches (Table 15), **some discharge dates were NULL values, misleading the count of treatment days**. Treatment days seem to be calculated as the difference between the date of retrieval of datasets, and the date of admission to treatment. This is one of the reasons why this variable may confound the analysis of duplicated data. However, we needed to identify the intervals in which cases were overlapping by getting the days of treatment and determine whether a specific HASH may already have finished a treatment or not. 

<br>

```{r tab16_diff_between_dates,echo=T, paged.print=TRUE}
CONS_C1_df_dup_ENE_2020 %>%
  dplyr::filter(is.na(fech_egres)) %>%
  dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), dias_trat_trans= as.numeric(as.Date("2019-11-13"))-fech_ing_num, 
                diff_treat_days=dias_trat-dias_trat_trans) %>% #fecha del día de hoy 
  dplyr::select(HASH_KEY, id_mod, ano_bd, sexo, fech_ing, fech_ing_num, dias_trat_trans,dias_trat,diff_treat_days) %>%
  dplyr::group_by(diff_treat_days, ano_bd) %>%
  dplyr::summarize(n=n()) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
                   caption="Table 16. Missing Date of Discharge, Difference between Treatment Dates", col.names= c("Treat Days", "Year of Dataset", "N"),  align =rep('c', 3))  %>%
     kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 8) %>%
  kableExtra::add_footnote(c("Note= Treat Days= Difference between the treatment days reported by SENDA, and a calculated one, product of the difference between the date of retrieval, 2019-11-13, and the date of admission to treatment"), notation = "none")
#ABRIL 2020, subió un poco, de 272 a 324-
n_casos<-CONS_C1_df_dup_ENE_2020 %>%
  dplyr::filter(is.na(fech_egres)) %>%
  dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), dias_trat_trans= as.numeric(as.Date("2019-11-13"))-fech_ing_num, 
                diff_treat_days=dias_trat-dias_trat_trans) %>% #fecha del día de hoy 
  dplyr::select(HASH_KEY, id_mod, ano_bd, sexo, fech_ing, fech_ing_num, dias_trat_trans,dias_trat,diff_treat_days) %>%
  dplyr::group_by(diff_treat_days, ano_bd) %>%
  dplyr::summarize(n=n()) %>% dplyr::filter(!ano_bd %in% c(2018,2019)) %>% ungroup()%>% summarise(sum=sum(n))

#number of hash and date of admission.
#   HASHs_w_o_date_discharge %>%
#            dplyr::mutate(HASH_fecha_ingreso=paste0(HASH_KEY,"_",fech_ing_num)) %>% 
#            dplyr::left_join(combinacion_reemplazada,by="HASH_fecha_ingreso") %>%
#            dplyr::mutate(ano_bd.x=as.numeric(ano_bd.x)) %>%
#            dplyr::filter(is.na(HASH_KEY.y),ano_bd.x<=2017) %>%
#            dplyr::mutate(fech_ingres=as.Date(fech_ing_num)) %>% 
#            dplyr::select(c(1,2,14)) %>%
#            dplyr::rename("HASH"=HASH_KEY.x,"Ano_Base_Datos" =ano_bd.x, "Fecha_Ingreso"=fech_ingres) #%>% nrow()
```
<br>

Table 16 shows the entries with missing dates of discharge, the difference between the date of retrieval (Second week of November of 2019), and the days of treatment, by each yearly dataset obtained. NULL values represent cases in which the number of treatment days was not available. **These were produced by negative treatment days**. Datasets from 2010 to 2018 would have been retrieved 8 days earlier than the dataset of 2019 (n= `r CONS_C1_df_dup_ENE_2020 %>% dplyr::filter(is.na(dias_trat))%>% nrow()`). SENDAs professionals believed that treatments should not last more than 1095 days. That is why we think that **cases in datasets of 2018 and 2019 may still be in treatment until the date of retrieval (leaving an approximate of `r print(n_casos[[1]])` HASHs and date of admissions left to analyze). We asked SENDAs professionals about the cases that are still being treated and came from older datasets**. Meanwhile, we looked over those cases with the same dates of admission and HASH that had a recent date of discharge that could replace the missing value.

<br>

```{r tab17_saving dates w o discharge date,echo=T, paged.print=TRUE,message=F}
HASHs_w_o_date_discharge<- CONS_C1_df_dup_ENE_2020 %>%
          dplyr::filter(is.na(fech_egres)) %>%
          dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), dias_trat_trans= as.numeric(as.Date("2019-11-13"))-fech_ing_num, 
                        diff_treat_days=dias_trat-dias_trat_trans,fech_egres_num=as.numeric(as.Date(fech_egres))) %>% #fecha del día de hoy 
          dplyr::select(row, HASH_KEY, id_mod, ano_bd, sexo, fech_ing, fech_ing_num, fech_egres_num, dias_trat_trans,dias_trat,diff_treat_days) %>%
          dplyr::select(HASH_KEY, ano_bd, fech_ing_num) %>%        
          dplyr::distinct(HASH_KEY,fech_ing_num)# %>% dim() 8142

CONS_C1_df_egres2<- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(HASH_KEY_2=HASH_KEY) %>%
  dplyr::filter(!is.na(fech_egres)) %>%
  dplyr::select(row,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso) %>% 
  data.table::as.data.table()

require(data.table) #v>=1.9.8
 
#54 cases of C1 that do not have dates of discharge,  that can be replaced with cases in C1 that have available dates of discharge but with a date of admission equal  or greater than  the not   available.
CONS_C1_df_egres2[HASHs_w_o_date_discharge, on = .(HASH_KEY_2=HASH_KEY,fech_ing_num2 >= fech_ing_num), nomatch = 0,
      .(row,HASH_KEY,id_mod, ano_bd,fech_ing, fech_egres,Edad,Nombre.Centro,motivodeegreso)] %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
              caption="Table 17. Cases with the same HASH and date of admission, that had a more recent date of discharge", align =rep('c', 101),
               col.names= c("Row No.","Hash Key", "SENDAs ID (Mod)", "Year of\n Dataset", "Date of\nAdmission","Date of\nDischarge","Age","Center Name", "Cause of Discharge")) %>% 
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 9) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")
#Update of 31-12-2019, nomatch= 0 may be wrong. Finally, it was right for this analysis. Similar to left join:
#CONS_C1_df_egres[HASHs_w_o_date_discharge, on = .(HASH_KEY_2=HASH_KEY,fech_ing_num >= fech_ing_num), #nomatch = 0, its an inner join
#      .(row,HASH_KEY,id_mod, ano_bd,fech_ing, fech_egres,Edad,Nombre.Centro,motivodeegreso)]  %>%      dplyr::filter(!is.na(HASH_KEY))
#fuzzyjoin::fuzzy_left_join(as_tibble(HASHs_w_o_date_discharge),as_tibble(CONS_C1_df_egres2),
#                           by = c("HASH_KEY" = "HASH_KEY", "fech_ing_num" <= "fech_ing_num2"), 
#                           match_fun = list(`==`, `>`))
# OR
#sqldf("
#SELECT *
#FROM HASHs_w_o_date_discharge  
#INNER JOIN CONS_C1_df_egres2 
#ON HASHs_w_o_date_discharge.HASH_KEY == CONS_C1_df_egres2.HASH_KEY AND 
#  HASHs_w_o_date_discharge.fech_ing_num <= CONS_C1_df_egres2.fech_ing_num2") 
```

<br>

As seen in Table 17, we found `r CONS_C1_df_egres2[HASHs_w_o_date_discharge, on = .(HASH_KEY_2=HASH_KEY,fech_ing_num2 >= fech_ing_num), nomatch = 0, .(row,HASH_KEY,id_mod, ano_bd,fech_ing, fech_egres,Edad,Nombre.Centro,motivodeegreso)] %>% nrow()` cases that should not be included in Table 16, because they can be replaced with a proper date of discharge or inferred by more recent records, according to the information available . **But what happens with those cases that had a recent case, despite having the same dates of admission? These are the cases that would end overlapping with the treatments that follow them**.

<br>


```{r tab18_analyzing replace of dates w o discharge date,echo=T, paged.print=TRUE, message=F, cache=T}
HASHs_w_o_date_discharge<- CONS_C1_df_dup_ENE_2020 %>%
          dplyr::filter(is.na(fech_egres)) %>%
          dplyr::mutate(fech_ing_num=as.numeric(as.Date(fech_ing)), dias_trat_trans= as.numeric(as.Date("2019-11-13"))-fech_ing_num, 
                        diff_treat_days=dias_trat-dias_trat_trans,fech_egres_num=as.numeric(as.Date(fech_egres))) %>% #fecha del día de hoy 
          dplyr::select(row, HASH_KEY, id_mod, ano_bd, sexo, fech_ing, fech_ing_num, fech_egres_num, dias_trat_trans,dias_trat,diff_treat_days) %>%
          dplyr::select(HASH_KEY, ano_bd, fech_ing_num) %>%        
          dplyr::distinct(HASH_KEY,fech_ing_num)# %>% dim() 8142

CONS_C1_df_egres2<- CONS_C1_df_dup_ENE_2020 %>%
  dplyr::mutate(fech_ing_num2=as.numeric(as.Date(fech_ing))) %>%
  dplyr::mutate(fech_egres_num2=as.numeric(as.Date(fech_egres))) %>%
  dplyr::mutate(HASH_KEY_2=HASH_KEY) %>%
  dplyr::filter(!is.na(fech_egres)) %>%
  dplyr::select(row,HASH_KEY_2, id_mod, ano_bd,fech_ing, fech_ing_num2,fech_egres,fech_egres_num2,Edad, Nombre.Centro, motivodeegreso) %>% 
  as.data.table()
#153394 rows

require(data.table) #v>=1.9.8
#54 cases of C1 that do not have dates of discharge,  that can be replaced with cases in C1 that have available dates of discharge but with a date of admission equal  or greater than  the not   available.
CONS_C1_df_dup_w_date_discharge <- CONS_C1_df_egres2[HASHs_w_o_date_discharge, on = .(HASH_KEY_2=HASH_KEY,fech_ing_num2 >= fech_ing_num), nomatch = 0,
                  .(row,HASH_KEY,id_mod, ano_bd,fech_ing, fech_egres, fech_egres_num2, Edad,Nombre.Centro,motivodeegreso)]
#select hashs for analysis
CONS_C1_df_dup_w_date_discharge_HKEY <-CONS_C1_df_dup_w_date_discharge %>% distinct(HASH_KEY)

dplyr::left_join(CONS_C1_df_dup_ENE_2020,CONS_C1_df_dup_w_date_discharge, by = "HASH_KEY", suffix = c("", ".disch")) %>% # dim()
dplyr::mutate(fech_egres_corr=ifelse(is.na(fech_egres),as.character(fech_ing.disch),as.character(fech_egres))) %>% 
  dplyr::filter(HASH_KEY %in% as.character(as.vector(unlist(as.data.table(unlist(CONS_C1_df_dup_w_date_discharge_HKEY)))))) %>%
  dplyr::select(row,ano_bd, HASH_KEY, fech_ing, fech_egres, motivodeegreso,fech_egres_corr) %>%
  #dplyr::filter(HASH_KEY=="0b9e123cca2191c6a2b4a0fcfcca2d46")
  dplyr::distinct(row,.keep_all=T)%>%
  dplyr::arrange(HASH_KEY, fech_ing) %>%
  knitr::kable(.,format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
              caption="Table 18. HASHs with a more recent treatment, for analysis", align =rep('c', 101),
              col.names = c("Row Number", "Year of\nDataset","Hash Key", "Date of\nAdmission", "Date of\nDischarge", "Cause of\nDischarge", "Date of\nDischarge (Corrected)")) %>% 
   kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 9) %>%
  kableExtra::scroll_box(width = "100%", height = "350px")

#NO SE PUEDEN RESCATAR DE TOPs
#CONS_C1_df_dup_ENE_2020_w_date_disch <- CONS_C1_df_dup_ENE_2020 %>% dplyr::filter(is.na(fech_egres)) #no puedo rescatar de TOP
#CONS_TOP %>%
#  dplyr::mutate(fech_ing= lubridate::parse_date_time(Fecha.de.Ingreso.a.Tratamiento, c("%d/%m/%Y"),exact=T)) %>% #no fallan casos en ser transformados
#  dplyr::filter(TOP=="Egreso", Etapa.del.Tratamiento=="Egreso") %>%
#  dplyr::mutate(fech_ap_top= lubridate::parse_date_time(Fecha.Aplicación.TOP, c("%Y-%m-%d"),exact=T)) %>% #ni un caso falla en ser transformado
#  dplyr::mutate(concat=paste0(HASH_KEY,"_",fech_ing)) %>%
#  dplyr::right_join(CONS_C1_df_dup_ENE_2020_w_date_disch,by="concat") %>% 
#  dplyr::filter(!is.na(fech_ap_top)) %>%
#  dplyr::select(HASH_KEY.x, fech_ing.x,concat,fech_egres,fech_ap_top) %>%View()
```

<br>

In Table 18, we offered a table of each HASH and dates of discharge. This Table may let us decide whether to replace the dates of discharge by the following date of admission (leading to a time-to-readmission of 0) or to erase the complete case. **As stated in the meeting of Jan. 13 of 2020, an alternative would be to impute days of treatment and generate a new date of discharge by adding the days of treatment to the date of admission.**

<br>

```{r change labels,echo=T, paged.print=TRUE}
#TODAVÍA NO ES POSIBLE HACER EL TRASPASO DE ESAS FECHAS TAN IMPORTANTES AL HASH.
#NO SE PUEDEN RESCATAR DE TOPs
#CONS_C1_df_dup_ENE_2020_w_date_disch <- CONS_C1_df_dup_ENE_2020 %>% dplyr::filter(is.na(fech_egres)) #no puedo rescatar de TOP
#CONS_TOP %>%
#  dplyr::mutate(fech_ing= lubridate::parse_date_time(Fecha.de.Ingreso.a.Tratamiento, c("%d/%m/%Y"),exact=T)) %>% #no fallan casos en ser transformados
#  dplyr::filter(TOP=="Egreso", Etapa.del.Tratamiento=="Egreso") %>%
#  dplyr::mutate(fech_ap_top= lubridate::parse_date_time(Fecha.Aplicación.TOP, c("%Y-%m-%d"),exact=T)) %>% #ni un caso falla en ser transformado
#  dplyr::mutate(concat=paste0(HASH_KEY,"_",fech_ing)) %>%
#  dplyr::right_join(CONS_C1_df_dup_ENE_2020_w_date_disch,by="concat") %>% 
#  dplyr::filter(!is.na(fech_ap_top)) %>%
#  dplyr::select(HASH_KEY.x, fech_ing.x,concat,fech_egres,fech_ap_top) %>%View()

  metadata(CONS_C1_df_dup_ENE_2020)$name <- "Agreement 1 SENDA"
  metadata(CONS_C1_df_dup_ENE_2020)$description <- "Information About Agreement 1 of SENDA and MINSAL"
  
codebook::var_label(CONS_C1_df_dup_ENE_2020) <- list(row = 'Numerador de los eventos presentes en la Base de Datos/Events in the Dataset',
TABLE = 'Origen de los Datos (de los archivos por año)/Source of Data (of files per year)',
HASH_KEY = 'Codificación del RUT/Masked Identifier (RUT)',
ano_bd = 'Año de la Base de Datos/Year of the Dataset (Source)',
id = 'Codigo Identificación de SENDA/SENDAs ID',
Nombre.Centro = 'Nombre del Centro de Tratamiento/Treatment Center',
tipo_centro = 'Tipo de Centro/Type of Center',
Región.del.Centro = 'Región del Centro/Chilean Region of the Center',
Servicio.de.Salud = 'Servicio de Salud/Health Service',
Tipo.de.Programa = '(original, Recodificado en tipo_de_programa)/',
Tipo.de.Plan = '(original, Recodificado en tipo_de_plan)/',
SENDA = 'SENDA/SENDA',
dias_trat = 'Días de Tratamiento/Days of Treatment',
nmesesentratamiento = 'Número de Meses en Tratamiento/Number of Months in Treatment',
Dias.en.SENDA = 'Días en SENDA/Days in SENDA',
N.Meses.en.SENDA = 'Número de Meses en SENDA/Number of Months in SENDA',
Sexo = '(original, Recodificado en sexo)/',
Edad = 'Edad (número entero)/Year (Discrete Number)',
Nombre.Usuario = 'Nombre del Usuario (OCULTO y no accesible)/Name of the User (Not Accessible)',
Comuna.Residencia = 'Comuna de Residencia/Municipality of Residence',
Origen.de.Ingreso = '(original, Recodificado en origen_ingreso)/',
País.Nacimiento = 'País de Nacimiento/Country of Birth',
Nacionalidad = 'Nacionalidad/Nationallity',
Etnia = 'Etnia/Ethnicity',
Estado.Conyugal = '(original, Recodificado en estado_conyugal)/',
Número.de.Hijos = 'Número de Hijos/Number of Children',
Número.de.Hijos.Ingreso.Tratamiento.Residencial = 'Número de Hijos para Ingreso a Tratamiento Residencial/Number of Children to Residential Treatment',
Parentesco.con.el.Jefe.de.Hogar = '(Sólo presenta valores perdidos)/',
Numero.de.Tratamientos.Anteriores = 'Número de Tratamientos Anteriores/Number of Previous Treatments',
Fecha.Ultimo.Tratamiento = 'Fecha del Último Tratamiento (aún no formateada como fecha)/Date of the Last Treatment',
Sustancia.de.Inicio = '(original, Recodificado en sus_ini)/',
Edad.Inicio.Consumo = '(original, Recodificado en edad_ini_cons)/', 
X.Se.trata.de.una.mujer.embarazada. = 'Mujer Embarazada al Ingreso/Pregnant at Admission',
Escolaridad..último.año.cursado. = '(original, Recodificado en escolaridad)/', 
Condicion.Ocupacional = '(original, Recodificado en estatus_ocupacional)/', 
Categoría.Ocupacional = '(original, Recodificado en cat_ocupacional)/',
Rubro.Trabaja = 'Rubro de Trabajo/Area of Work',
Con.Quién.Vive = 'Persona con la que vive el Usuario/People that Share Household with the User',
Tipo.de.vivienda = 'Tipo de Vivienda/Type of Housing',
Tenencia.de.la.vivienda = 'Tenencia de la Vivienda/Tenure status of Households',
Sustancia.Principal = '(original, Recodificado en sus_principal)/',
Otras.Sustancias.nº1 = '(original, Recodificado en otras_sus1)/',
Otras.Sustancias.nº2 = '(original, Recodificado en otras_sus2)/',
Otras.Sustancias.nº3 = '(original, Recodificado en otras_sus3)/',
Frecuencia.de.Consumo..Sustancia.Principal. = '(original, Recodificado en freq_cons_sus_prin)/',
Edad.Inicio..Sustancia.Principal. = '(original, Recodificado en edad_ini_sus_prin)/',
Vía.Administración..Sustancia.Principal. = '(original, Recodificado en via_adm_sus_prin)/',
Diagnóstico.Trs..Consumo.Sustancia = 'Diagnósico de Trastorno por Consumo de Sustancias/Diagnosed of Substance Use Disorder',
Diagnóstico.Trs..Psiquiátrico.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV/Diagnosis of Psychiatric Disorders, DSM-IV criteria',
Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification)',
X2.Diagnóstico.Trs..Psiquiátrico.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (2)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (2)',
X2.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion) (2)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (2)',
X3.Diagnóstico.Trs..Psiquiátrico.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (3)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (3)',
X3.Diagnóstico.Trs..Psiquiátrico.SUB.DSM.IV = 'Diagnóstico de Trastorno Psiquiátrico, Criterios DSM IV (Subclasificacion) (3)/Diagnosis of Psychiatric Disorders, DSM-IV criteria (sub-classification) (3)',
Diagnóstico.Trs..Psiquiátrico.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10/Diagnosis of Psychiatric Disorders, CIE-10 criteria',
Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification)',
X2.Diagnóstico.Trs..Psiquiátrico.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (2)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (2)',
X2.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion) (2)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (2)',
X3.Diagnóstico.Trs..Psiquiátrico.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (3)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (3)',
X3.Diagnóstico.Trs..Psiquiátrico.SUB.CIE.10 = 'Diagnóstico de Trastorno Psiquiátrico, Criterios CIE-10 (Subclasificacion) (3)/Diagnosis of Psychiatric Disorders, CIE-10 criteria (subclassification) (3)',
Diagnóstico.Trs..Físico = 'Diagnóstico de Trastorno Físico/Diagnosis of Physical Disorder',
Otros.Problemas.de.Atención.de.Salud.Mental = 'Otros Problemas de Atención Vinculados a Salud Mental/Other problems linked to Mental Health',
Compromiso.Biopsicosocial = 'Compromiso Biopsicosocial/Biopsychosocial Involvement',
DIAGNOSTICO.GLOBAL.DE.NECESIDADES.DE.INTEGRACION.SOCIAL = 'Diagnóstico Global de Necesidades de Integración Social al Ingreso/Global Diagnosis of Social Integration at Admission',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.HUMANO = 'Diagnóstico de Necesidades de Integración Social en Capital Humano al Ingreso/Global Diagnosis of Social Integration in Human Capital at Admission',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.FISICO = 'Diagnóstico de Necesidades de Integración Social en Capital Físico al Ingreso/Global Diagnosis of Social Integration in Physical Capital at Admission',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.SOCIAL = 'Diagnóstico de Necesidades de Integración Social en Capital Social al Ingreso/Global Diagnosis of Social Integration in Social Capital at Admission',
fech_ing = 'Fecha de Ingreso a Tratamiento/Date of Admission to Treatment',
Fecha.Ingreso.a.Convenio.SENDA = 'Fecha de Ingreso a Convenio SENDA (aún no formateada como fecha)/Date of Admission to SENDA Agreement',
Usuario.de.Tribunales..Tratamiento.Drogas = 'Usuario de modalidad Tribunales de Tratamiento de Drogas/User of Drug Treatment Courts Modality',
Consentimiento.Informado = 'Consentimiento Informado/Informed Consent',
fech_egres = 'Fecha de Egreso de Tratamiento/Date of Discharge from Treatment',
motivodeegreso = 'Motivo de Egreso/Cause of Discharge',
Tipo.Centro.Derivación = 'Tipo de Centro al que el Usuario es Derivado/Type of Center of Derivation',
evaluacindelprocesoteraputico = 'Evaluación del Proceso Terapéutico/Evaluation of the Therapeutic Process',
eva_consumo = 'Evaluación al Egreso Respecto al Patrón de consumo/Evaluation at Discharge regarding to Consumption Pattern',
eva_fam = 'Evaluación al Egreso Respecto a Situación Familiar/Evaluation at Discharge regarding to Family Situation',
eva_relinterp = 'Evaluación al Egreso Respecto a Relaciones Interpersonales/Evaluation at Discharge regarding to Interpersonal Relations',
eva_ocupacion = 'Evaluación al Egreso Respecto a Situación Ocupacional/Evaluation at Discharge regarding to Occupational Status',
eva_sm = 'Evaluación al Egreso Respecto a Salud Mental/Evaluation at Discharge regarding to Mental Health',
eva_fisica = 'Evaluación al Egreso Respecto a Salud Física/Evaluation at Discharge regarding to Physical Health',
eva_transgnorma = 'Evaluación al Egreso Respecto a Trasgresión a la Norma Social/Evaluation at Discharge regarding to Transgression to the Norm',
Diagnóstico.Trastorno.Psiquiátrico.CIE.10.al.Egreso = '(Sólo presenta valores perdidos)/',
DIAGNOSTICO.GLOBAL.DE.NECESIDADES.DE.INTEGRACION.SOCIAL.1 = 'Diagnóstico Global de Necesidades de Integración Social (al Egreso)/Global Diagnosis of Social Integration (at Discharge)',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.HUMANO.1 = 'Diagnóstico de Necesidades de Integración Social en Capital Humano (al Egreso)/Global Diagnosis of Social Integration in Human Capital (at Discharge)',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.FISICO.1 = 'Diagnóstico de Necesidades de Integración Social en Capital Físico (al Egreso)/Global Diagnosis of Social Integration in Physical Capital (at Discharge)',
DIAGNOSTICO.DE.NECESIDADES.DE.INTEGRACIóN.SOCIAL.EN.CAPITAL.SOCIAL.1 = 'Diagnóstico de Necesidades de Integración Social en Capital Social (al Egreso)/Global Diagnosis of Social Integration in Social Capital (at Discharge)',
TIENE.MENORES.DE.EDAD.A.CARGO = 'Menores de Edad A Cargo/Minor Dependants',
Motivo.de.egreso.Alta.Administrativa = 'Motivo de Egreso Alta Administrativa/Cause of Discharge ',
Consorcio = 'Sociedades de Tratamiento, Servicios de Salud, Fundaciones, entre otras entidades encargadas de los centros/Consortium',
ID.centro = 'ID de Centro/Center ID',
Ha.estado.embarazada.egreso. = '¿Ha estado embarazada? (al Egreso)/Have you been Pregnant (at Discharge)',
identidad.de.genero = 'Identidad de Género/Gender Identity',
discapacidad = 'Presenta Discapacidad/Disability',
hash_rut_completo = 'HASH alternativo, en el escenario en que se asuma que el individuo al que se le codificó el RUT presente mayor edad/Alternative HASH-Key',
Opción.discapacidad = 'Origen de Discapacidad/Cause of Disability',
sexo = 'Sexo Usuario/Sex of User',
embarazo = 'Embarazo/Pregnant',
tipo_de_plan = 'Tipo de Plan/Type of Plan',
tipo_de_programa = 'Tipo de Programa de Tratamiento/Type of Program',
fech_egres_sin_fmt = 'Fecha de Egreso de Tratamiento (Sin Formato de Fecha)/Date of Discharge',
id_mod = 'ID de SENDA para Presentación en Página Web (enmascara caracteres 5 y 6)/SENDAs ID (mask characters 5 & 6)',
ano_nac = 'Año de Nacimiento (numérico)/Year of Birth (numeric)',
fech_ing_ano = 'Año de Ingreso (numérico)/Year of Admission (numeric)',
fech_ing_mes = 'Mes de Ingreso (numérico)/Month of Admission (numeric)',
fech_ing_dia = 'Día de Ingreso (numérico)/Day of Admission (numeric)',
concat = 'ID de SENDA y HASH Concatenado (permite discriminar más de un HASH en un mismo ID)/Combination of SENDAs ID & HASH',
dias_trat_inv = 'Días de Tratamiento Invertidos (fecha más reciente, menor valor numérico)/Treatment Days (Reversed)',
fech_nac = 'Fecha de Nacimiento/Date of Birth',
Edad_al_ing = 'Edad a la Fecha de Ingreso a Tratamiento (numérico continuo)/Age at Admission to Treatment',
edad_ini_cons= 'Edad de Inicio de Consumo/ Age of Onset of Drug Use',
edad_ini_sus_prin =  'Edad de Inicio de Consumo Sustancia Principal/ Age of Onset of Drug Use Principal Substance',
dias_trat_alta_temprana = 'Días de tratamiento (<90)/ Less than 90 days in treatment',
motivodeegreso_mod = 'Motivo de Egreso (con abandono temprano y tardío)/Cause of Discharge (with late and early withdrawal)',
sus_principal = 'Sustancia Principal de Consumo/Main Substance of Consumption',
otras_sus1= 'Otras Sustancias (1)/Other Substances (1)',
otras_sus2= 'Otras Sustancias (2)/Other Substances (2)',
otras_sus3= 'Otras Sustancias (3)/Other Substances (3)',
sus_ini= 'Sustancia de Inicio/Starting Substance',
estado_conyugal='Estado Conyugal/Marital Status',
estatus_ocupacional= 'Condición Ocupacional/Occupational Status',
cat_ocupacional= 'Categoría Ocupacional/Occupational Category',
Edad_grupos	= 'Edad agrupada/Age in groups',
origen_ingreso= 'Origen de Ingreso/Motive of Admission to Treatment',
escolaridad= 'Escolaridad: Nivel Eduacional/Educational Attainment',
freq_cons_sus_prin = 'Frecuencia de Consumo de la Sustancia Principal/Frequency of Consumption of the Main Substance',
via_adm_sus_prin = 'Vía de Administración de la Sustancia Principal/Route of Administration of the Main Substance')

CONS_C1_df_dup_ENE_2020 <- janitor::clean_names(CONS_C1_df_dup_ENE_2020)

#PARA EXPORTAR LABELS A EXCEL
#data.table::data.table(table(CONS_C1_df_dup_ENE_2020$identidad.de.genero, exclude=NULL)) %>% mutate(export=paste0(row_number(),".",V1)) %>% select(-V1) %>% select(export,N)%>% copiar_nombres()

#save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/3.Rdata")
```

```{r saving dataset in 3 Rdata, echo=T, paged.print=TRUE}
save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/3.Rdata")
#save.image("H:/sud_cl/3.Rdata")
```

<br>

## 7. Preliminary Summary in January 2020

Many selections for the purposes of the study are still being necessary until today, in order to  keep the greater amount of information about each event. 

```{r image-ref-for-in-text, echo=T, fig.align='center', message=FALSE, fig.caption="Figure 7. Summary of Process of Data Cleaning and Standardization"}
#knitr::include_graphics("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/Figures/Figure_Duplicates.svg")
library(DiagrammeR)
DiagrammeR::grViz("
digraph graph2 {

graph [layout = dot]

# node definitions with substituted label text
node [shape = rectangle, width = 4, color = 'steelblue',fillcolor = lightblue]
a [label = '@@1']
b [label = '@@2']
c [label = '@@3']
d [label = '@@4']
e [label = '@@5']
f [label = '@@6']

a -> b -> c -> {d e f}

}

[1]:  paste0('Once removed same values in >100 variables (n = ', formatC(nrow(CONS_C1_df_dup), format='f', big.mark=',', digits=0), ')')
[2]: paste0('Once removed same values in variables related to treatments and substance use (n = ', formatC(nrow(CONS_C1_df_dup_ENE_2020_prev2), format='f', big.mark=',', digits=0), ')')
[3]: paste0('Preliminary Dataset (n = ', formatC(nrow(CONS_C1_df_dup_ENE_2020), format='f', big.mark=',', digits=0), ')')
[4]: paste0('Same HASH & Date of Admission (n = ', formatC(dup_cases_quarter_n, format='f', big.mark=',', digits=0), ')')
[5]: paste0('Overlapped Ranges of Treatments (n = ', formatC(nrow(overlap_dates_C1), format='f', big.mark=',', digits=0), ')')
[6]: paste0('Pairs of Probabilistic Matches (n = ', formatC(nrow(matches_from_stata_c1)/2, format='f', big.mark=',', digits=0), ')')
")
```

<!--- SÍ O SÍ, HACER LA LIMPIEZA DE LOS SENDA NO, PRINCIPALMENTE DE LOS QUE SE SUPERPONGAN, TAMBIÉN PREGUNTAR A ACC SI LOS CON 0 DÍAS DE TRATAMIENTO SE BORRARÁN O NO; DE AHI EMPEZAR A NORMALIZAR LOS PROGRAMAS Y PLANES DE ACUERDO CON CRITERIOS MAUREEN, PARA NO GENERAR DIFERENCIAS AHI Y PODER DEDUPLICAR TRANQUILO --->

<!--- tipo_centro, convertir en factor 1. Privado, 2. Público; DataExplorer::create_report(CONS_1_4)  --->

---

```{r session_info, echo=T, paged.print=TRUE}
sessionInfo()
```