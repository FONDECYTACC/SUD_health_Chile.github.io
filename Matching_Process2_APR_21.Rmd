---
title: "Ambulatory or residential? a multi-state analysis of treatments for substance use disorders (Step 2)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide  
    toc: true # table of content true
    toc_depth: 5  # upto three depths of headings (specified by #, ## and ###)
    toc_float: true
---

```{css zoom-lib-src, echo = FALSE}
script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"
```

```{js zoom-jquery, echo = FALSE}
 $(document).ready(function() {
    $('body').prepend('<div class=\"zoomDiv\"><img src=\"\" class=\"zoomImg\"></div>');
    // onClick function for all plots (img's)
    $('img:not(.zoomImg)').click(function() {
      $('.zoomImg').attr('src', $(this).attr('src')).css({width: '100%'});
      $('.zoomDiv').css({opacity: '1', width: 'auto', border: '1px solid white', borderRadius: '5px', position: 'fixed', top: '50%', left: '50%', marginRight: '-50%', transform: 'translate(-50%, -50%)', boxShadow: '0px 0px 50px #888888', zIndex: '50', overflow: 'auto', maxHeight: '100%'});
    });
    // onClick function for zoomImg
    $('img.zoomImg').click(function() {
      $('.zoomDiv').css({opacity: '0', width: '0%'}); 
    });
  });
```

```{=html}
<style type="text/css">
.tablelines table, .tablelines td, .tablelines th {
        border: 1px solid black;
        }
.centrado {
    text-align: center;
}
.table.center {
    margin-left:auto; 
    margin-right:auto;
  }
.table_wrapper{
    display: block;
    overflow-x: auto;
    white-space: nowrap;
}
code.r{
  font-size: 8px;
}
body{ /* Normal  */
      text-align: justify;
  }
.superbigimage{
    overflow-y:scroll;
    white-space: nowrap;
}
.superbigimage img{
    overflow-y: scroll;
    overflow-x: hidden;
}
</style>
```
```{=html}
<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px; text-align: justify;}
</style>
```
```{r prev_setup, include = FALSE, cache=T}
rm(list=ls());gc()
path<-rstudioapi::getSourceEditorContext()$path
#load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_carla.RData")
if (grepl("CISS Fondecyt",path)==T){
    setwd("C:/Users/CISS Fondecyt/OneDrive/Escritorio/SUD_CL/");load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_15.RData")
  } else if (grepl("andre",path)==T){
    setwd('C:/Users/andre/Desktop/SUD_CL/');load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_15.RData")
  } else if (grepl("E:",path)==T){
    setwd("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/");load("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_15.RData")
  } else {
    setwd("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/SUD_CL/");load("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_15.RData")
  }

#getwd()
#knitr::opts_knit$get()
#devtools::install_github("hputter/mstate")

```

```{r setup, include = FALSE, cache=T}
#Libraries used in the routine. Dont change the order
local({r <- getOption("repos")
       r["CRAN"] <- "http://cran.r-project.org" 
       options(repos=r)
})
copiar_nombres <- function(x,row.names=FALSE,col.names=TRUE,dec=",",...) {
  if(class(ungroup(x))[1]=="tbl_df"){
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(data.frame(x)),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)    
        }
  } else {
        if(options()$OutDec=="."){
            options(OutDec = dec)
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ".")
          return(x)
        } else {
            options(OutDec = ",")
            write.table(format(x),"clipboard",sep="\t",row.names=FALSE,col.names=col.names,...)
            options(OutDec = ",")
          return(x)       
  }
 }
}  
#packageVersion("codebook")
#https://github.com/RevolutionAnalytics/checkpoint
#if(!require(checkpoint)){install.packages("checkpoint")}
#if(!require(here)){install.packages("here")}
#checkpoint::checkpoint("2020-02-19",project=here::here(),checkpointLocation=paste0(here::here(),"/dedup"), use.lock=F, use.knitr=T, auto.install.knitr = T,scan.rnw.with.knitr=T, forceInstall=T,scanForPackages = TRUE)
#checkpointArchives(tempdir(), full.names = TRUE)

#if(!require(tidyr)){install.packages("tidyr")}
#if(!require(DataExplorer)){install.packages("DataExplorer")}
#if(!require(stringi)){install.packages("stringi")}
#if(!require(stringr)){install.packages("stringr")}
#if(!require(ggplot2)){install.packages("ggplot2")}
#if(!require(Hmisc)){install.packages("Hmisc")}
#if(!require(kableExtra)){install.packages("kableExtra")}
#if(!require(plotly)){install.packages("plotly")}
#if(!require(rbokeh)){install.packages("rbokeh")}
#if(!require(altair)){install.packages("altair")}
#if(!require(zoo)){install.packages("zoo")}
#if(!require(codebook)){install.packages("codebook")}
#if(!require(broom)){install.packages("broom")}
#if(!require(sqldf)){install.packages("sqldf")} 
#if(!require(devtools)){install.packages("devtools")}
#if(!require(Statamarkdown)){install_github("hemken/Statamarkdown")}
#if(!require(data.table)){install.packages("data.table")}
#if(!require(dplyr)){install.packages("dplyr")}

#if(!require(boot)){install.packages("boot")}
#if(!require(plyr)){install.packages("plyr")}
#if(!require(matrixStats)){install.packages("matrixStats")}
#if(!require(radiant)){install.packages("radiant", repos = "https://radiant-rstats.github.io/minicran/")}

try(library(boot))
library(matrixStats)
library(knitr)
library(tidyr)
library(stringi)
library(stringr)
library(ggplot2)
library(Hmisc)
library(kableExtra)
library(plotly)
library(janitor)
library(rbokeh)
library(zoo)
library(broom)
library(sqldf)
library(devtools)
library(codebook)
library(data.table)
library(panelr)
library(RColorBrewer)
library(lsmeans)
library(finalfit)
suppressPackageStartupMessages(library(ggiraph))
suppressPackageStartupMessages(library(sf))
library(treemapify)
library(dplyr)
library(tidyverse)
library(epiR)
library(survminer)
library(ggfortify)
library(survMisc)

library(foreign)
library(Hmisc)
library(gridExtra)
library(reshape2)
library(stargazer)
library(tableone)
library(MatchIt)
library(cobalt)
library(eha)
library(igraph)
library(Amelia)
library(DiagrammeR) 
library(mstate)
library(flexsurv)
library(muhaz)
library(Metrics)
library(Rfast)
#library(mstateutils)
#remotes::install_github("chjackson/flexsurv-dev", upgrade = "never")
#devtools::install_github("stulacy/multistateutils", build_vignettes=TRUE, upgrade = "never")
#devtools::install_github("hputter/mstate", upgrade = "never")
#unlink("C:/Users/CISS Fondecyt/OneDrive/Documentos/R/win-library/4.0/mstate", recursive=T, force=T)

if(!require(radiant.update)){install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")}
#install.packages( repos = "https://radiant-rstats.github.io/minicran/")
#install.packages("radiant.update", repos = "https://radiant-rstats.github.io/minicran/")

#tryCatch(source("https://raw.githubusercontent.com/radiant-rstats/minicran/gh-pages/update.R"), error = function(e) print("updated package, radiant"))

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

try_with_time_limit <- function(expr, cpu = Inf, elapsed = Inf)
{
  y <- try({setTimeLimit(cpu, elapsed); expr}, silent = TRUE) 
  if(inherits(y, "try-error")) NULL else y 
}
eval_fork <- function(..., timeout=60){

  #this limit must always be higher than the timeout on the fork!
  setTimeLimit(timeout+5);      

  #dispatch based on method
  ##NOTE!!!!! Due to a bug in mcparallel, we cannot use silent=TRUE for now.
  myfork <- parallel::mcparallel({
    eval(...)
  }, silent=FALSE);

  #wait max n seconds for a result.
  myresult <- parallel::mccollect(myfork, wait=FALSE, timeout=timeout);

  #try to avoid bug/race condition where mccollect returns null without waiting full timeout.
  #see https://github.com/jeroenooms/opencpu/issues/131
  #waits for max another 2 seconds if proc looks dead 
  while(is.null(myresult) && totaltime < timeout && totaltime < 2) {
     Sys.sleep(.1)
     enddtime <- Sys.time();
     totaltime <- as.numeric(enddtime - starttime, units="secs")
     myresult <- parallel::mccollect(myfork, wait = FALSE, timeout = timeout);
  }

  #kill fork after collect has returned
  tools::pskill(myfork$pid, tools::SIGKILL);    
  tools::pskill(-1 * myfork$pid, tools::SIGKILL);  

  #clean up:
  parallel::mccollect(myfork, wait=FALSE);

  #timeout?
  if(is.null(myresult)){
    stop("R call did not return within ", timeout, " seconds. Terminating process.", call.=FALSE);      
  }

  #move this to distinguish between timeout and NULL returns
  myresult <- myresult[[1]];

  #reset timer
  setTimeLimit();     

  #forks don't throw errors themselves
  if(inherits(myresult,"try-error")){
    #stop(myresult, call.=FALSE);
    stop(attr(myresult, "condition"));
  }

  #send the buffered response
  return(myresult);  
}
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:

#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:#:
#GET LOCAL
#dir.create(paste0(getwd(),"/renv_local"))
#Sys.setenv(RENV_PATHS_LOCAL = paste0(getwd(),"/renv_local"))
#install.packages(paste0(getwd(),"/renv_local/gurobi_9.1-0.zip"), repos = NULL, type="source")
#install.packages(paste0("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/renv_local/gurobi_9.1-0.zip"), repos = NULL, type="source")
library(gurobi)
#"G:/Mi unidad/Alvacast/SISTRAT 2019 (github)"
#Sys.getenv("R_LIBS_USER")


LMAJ2 <- function (msdata, tmat, id, s, h, j, weighted){
  if (is.null(tmat)) 
    stop("msdata object should have a \"trans\" attribute")
  K <- nrow(tmat)
  if (any(is.na(match(h, 1:K)))) 
    stop("h should be subset of 1:K with K number of states")
  attr(msdata, "trans") <- tmat
  xss <- xsect(msdata, s)
  infrom <- xss[xss$state %in% h,id]
  msdatas <- cutLMms(msdata, LM = s)
  msdatasfrom <- msdatas[msdatas[,id] %in% infrom, ]
  c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
              data = msdatasfrom)
  A0 <- msfit(c0, trans = tmat, variance=FALSE)
  if(weighted==TRUE){
    c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
                weights=(1/clust.size), data = msdatasfrom)
    A.wt <- basehaz(c0, centered=FALSE)
    A.wt$strata <- as.numeric(A.wt$strata)
    for(trn in sort(unique(A.wt$strata))){
      fun <- stepfun(A.wt[A.wt$strata==trn,"time"], 
                     c(0,A.wt[A.wt$strata==trn,"hazard"]))
      A0$Haz[A0$Haz$trans==trn,"Haz"] <- fun(A0$Haz[A0$Haz$trans==trn,"time"])
    }
  }
  pt0 <- probtrans(A0, predt = s, variance=FALSE)[[h]][,c("time",
                                                          paste("pstate", j, sep=""))]
  return(pt0)
}
```

<br>

# Non-parametric

## Cumulative Transition Hazards of Joint Models

Cumulative baseline hazard can be estimated non-parametrically through a Breslow estimator. Must take note that we are assuming a semimarkov process in these transitions.

<br>

```{r msfit,eval=T, echo=T, paged.print=TRUE, fig.height=14, fig.width=12, fig.cap="Figure 1a. Estimate of Cumulative Hazards (Semimarkov), Stratified by Setting", fig.align="center"}
if(no_mostrar==1){
  for(i in c(1:3)){
    print(survdiff(Surv(time,status==1)~tipo_de_programa_2,data=subset(ms_CONS_C1_SEP_2020_women_imputed, trans == i)))
    }
  for(i in c(1:5)){
    print(survdiff(Surv(time,status==1)~tipo_de_programa_2,data=subset(ms2_CONS_C1_SEP_2020_women_imputed, trans == i)))
  } 
}

#We consider first the model without any proportionality assumption on the baseline hazards; this is achieved by adding strata(trans) to the formula, which estimates separate baseline hazards for different values of trans (the transitions). 

pr0 <- subset(ms_d_match_surv, tipo_de_plan_res_1==0)
pr1 <- subset(ms_d_match_surv, tipo_de_plan_res_1==1)
attr(pr0, "trans") <- trans_matrix
attr(pr1, "trans") <- trans_matrix

#Since there are tied event times, we need to specify ties="breslow" in order to obtain the Aalen-Johansen estimator of
#the transition probability
#If we only want the cumulative hazard for the relapse → death transition, we can
#select the rows that refer to transition 3.
#The stacked format allows to calculate all cumulative hazards via the basic coxph function.
c0 <- survival::coxph(Surv(time, status) ~ strata(trans), #Surv(time, status) ~ strata(trans) 
            data = pr0, method = "breslow")
c1 <- survival::coxph(Surv(time, status) ~ strata(trans), 
            data = pr1, method = "breslow")

cx0 <- coxph(Surv(Tstart,Tstop,status)~strata(trans),
        data=pr0,method="breslow")
cx1 <- coxph(Surv(Tstart,Tstop,status)~strata(trans),
        data=pr1,method="breslow")

#The value of time is equal to Tstop−Tstart; it is of use in ’clock reset’-models, where the time t refers to the time spent in the current state

#The alternative is to first apply the msfit function, which we also need when computing the transition
#probabilities
# piece-wise constant estimates - because is cox
msf0 <- mstate::msfit(object = c0, trans = trans_matrix, vartype ="aalen")
msf1 <- mstate::msfit(object = c1,  trans = trans_matrix, vartype ="aalen")

msfx0 <- mstate::msfit(object = cx0, trans = trans_matrix, vartype ="aalen")
msfx1 <- mstate::msfit(object = cx1,  trans = trans_matrix, vartype ="aalen")

#Haz contains the estimated cumulative hazard for each of the transitions for the particular patient
#specified in newd, while varHaz contains the estimated variances of these cumulative hazards,
#as well as the covariances for each combination of two transitions. All are evaluated at the
#time points for which any event in any transition occurs, possibly augmented with the largest
#(non-event) time point in the data. The summary method for msfit objects is most conveniently
#used for a summary. If we also would like to have a look at the covariances, we could set the
#argument variance equal to TRUE.

#This is a list with elements Haz (with the estimated cumulative hazard values at all event
#times), varHaz (with the covariances of each pair of estimated cumulative hazards at each
#event time point, i.e., cov( c Abgh(t), Abkl(t))), and trans, in which the transition matrix is stored
#for further use. The (co)variances of the estimated cumulative hazards may be computed in
#two different ways: by means of the Aalen estimator or by means of the Greenwood estimator.
#An advantage of the Greenwood estimator is the fact that it yields exact multinomial standard
#errors for the transition probabilities when there is no censoring. The two estimators give
#almost equal results in all practical applications.

msf0_plot<-
plot(msf0, 
     #cols=c()
     type="single",
     use.ggplot = TRUE)+
  ggtitle("")+
  ylim(0,1.5)+
  sjPlot::theme_sjplot2()+
  scale_x_continuous("",breaks=seq(0,max(newtime0,na.rm=T),by=365.25), labels=(1:length(seq(0,max(newtime0,na.rm=T),by=365.25))-1)) +
  theme(legend.position = "bottom")+
  scale_y_continuous(breaks=seq(0,1.5,by=1.5/10),limits=c(0,1.5))

msf1_plot<-
plot(msf1, 
     #cols=c()
     type="single",
     use.ggplot = TRUE)+
  ggtitle("")+
  ylim(0,1.5)+
  sjPlot::theme_sjplot2()+
  scale_x_continuous("",breaks=seq(0,max(newtime0,na.rm=T),by=365.25), labels=(1:length(seq(0,max(newtime0,na.rm=T),by=365.25))-1)) +
  theme(legend.position = "bottom")+
  scale_y_continuous(breaks=seq(0,1.5,by=1.5/10),limits=c(0,1.5))


ggarrange(msf0_plot,msf1_plot,
          labels = c("Outpatient", "Residential"),
          common.legend = TRUE, 
          #label.y="Cumulative Baseline Hazards",
         # label.x="Years",
          legend = "bottom")


 if(no_mostrar==1){
jpeg("Cum_haz_semimarkov_setting.jpg", height=14, width= 12, res= 320, units = "in")

ggarrange(msf0_plot,msf1_plot,
          labels = c("Outpatient", "Residential"),
          common.legend = TRUE, 
          #label.y="Cumulative Baseline Hazards",
         # label.x="Years",
          legend = "bottom")

dev.off()
}
```



```{r msfit1b,eval=T, echo=T, paged.print=TRUE, fig.height=14, fig.width=12, fig.cap="Figure 1b. Estimate of Cumulative Hazards (Markov), Stratified by Setting", fig.align="center"}

msfx0_plot<-
plot(msfx0, 
     #cols=c()
     type="single",
     use.ggplot = TRUE)+
  ggtitle("")+
  #ylim(0,1.5)+
  sjPlot::theme_sjplot2()+
  scale_x_continuous("",breaks=seq(0,max(newtime0,na.rm=T),by=365.25), labels=(1:length(seq(0,max(newtime0,na.rm=T),by=365.25))-1)) +
  theme(legend.position = "bottom")
 # scale_y_continuous(breaks=seq(0,7.5,by=1.5/10),limits=c(0,2.5))

msfx1_plot<-
plot(msfx1, 
     #cols=c()
     type="single",
     use.ggplot = TRUE)+
  ggtitle("")+
  #ylim(0,1.5)+
  sjPlot::theme_sjplot2()+
  scale_x_continuous("",breaks=seq(0,max(newtime0,na.rm=T),by=365.25), labels=(1:length(seq(0,max(newtime0,na.rm=T),by=365.25))-1)) +
  theme(legend.position = "bottom")
  #scale_y_continuous(breaks=seq(0,2.5,by=1.5/10),limits=c(0,2.5))


ggarrange(msfx0_plot,msfx1_plot,
          labels = c("Outpatient", "Residential"),
          common.legend = TRUE, 
          #label.y="Cumulative Baseline Hazards",
         # label.x="Years",
          legend = "bottom")


 if(no_mostrar==1){
jpeg(paste0(gsub("SUD_CL/Matching_Process_APR_21.Rmd","",path),"_mult_state_ags/Cum_haz_markov_setting.jpg"), height=14, width= 12, res= 320, units = "in")

ggarrange(msfx0_plot,msfx1_plot,
          labels = c("Outpatient", "Residential"),
          common.legend = TRUE, 
          #label.y="Cumulative Baseline Hazards",
         # label.x="Years",
          legend = "bottom")

dev.off()
}
```

<br>

```{r msfit2.5_4s, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 2. Estimate of Cumulative Hazards (Semi-Markov), Ten-states", fig.align="center", error=T, dpi=320}

#Son distintos, por mas que parezcan iguales.
#plot(cumhaz_data_a$time[which(cumhaz_data_a$trans=="Adm -> Ther.Disch")],round(cumhaz_data_a$Haz[which(cumhaz_data_a$trans=="Adm -> Ther.Disch")]-cumhaz_data_b$Haz[which(cumhaz_data_b$trans=="Adm -> Ther.Disch")],3))

library(ggplot2)

plot_comp_mssurvfit2<-
rbind(cbind.data.frame(msf0$Haz,setting="Outpatient"), 
      cbind.data.frame(msf1$Haz,setting="Residential")) %>%
ggplot2::ggplot(aes(x = time, y = Haz, col = factor(setting), linetype = factor(setting))) +
  geom_line(size=1, alpha=.65) + 
  facet_wrap(trans~., ncol=1, scales="free_y", labeller = as_labeller(transition_label)) + 
  scale_color_manual(name = "Type of program", values=c("#061F70","#A68D00"), labels= c("Outpatient","Residential")) + # "#A65100" #"Cox",
  scale_linetype_manual(name= "Type of program",values=c(1,4), labels=c("Outpatient","Residential")) +
  xlab("Years") + ylab("Cumulative hazard") + 
  theme_minimal()+
  scale_x_continuous("",breaks=seq(0,max(newtime0,na.rm=T),by=365.25), labels=(1:length(seq(0,max(newtime0,na.rm=T),by=365.25))-1)) +
  theme(legend.position=c(.9,.485),
        legend.background = element_rect(fill="white",
                                  size=0.5, linetype="solid", 
                                  colour ="black"))

#cumhaz_data_d %>% 
#     group_by(trans,model) %>% summarise(mean_haz=mean(Haz))
# No sé por qué no resulta que aparaezca, si los estoy viendo.
plot_comp_mssurvfit2
#plot_comp_mssurvfit2+ ggtitle("Figura 4 estados con Gompertz, Gen F y Gen-gamma")

if(no_mostrar==1){
jpeg("Cum_haz_ten_st.jpg", height=20, width= 10, res= 320, units = "in")
plot_comp_mssurvfit2
dev.off()
}
```



```{r msboot,eval=F, echo=T, paged.print=TRUE, error=T}
#https://rdrr.io/cran/mstate/man/msboot.html

# define a function (this one returns vector of regression coef's)
regcoefvec <- function(data) {
  cx <- survival::coxph(Surv(time, status) ~ factor(tipo_de_plan_res_1)+ strata(trans), 
            data = ms_d_match_surv, method = "breslow")
  return(coef(cx))
}

regcoefvec(ms_d_match_surv)
set.seed(2125)

msboot_output<-
msboot(theta=regcoefvec,data=ms_d_match_surv,id="id", B=500)

paste0("Overall Effect of the type of plan in multistate model (COX): Mdn=",round(quantile(msboot_output,.5),3)," [IC 95% ", round(quantile(msboot_output,.025),3),"-",round(quantile(msboot_output,.975),3),"]")
```

<br>

## Transition Probabilites

We also want to know the probability to be in each of the three states over time, not only the instantaneous transition rate reflected by the cumulative hazard. We need to create a data frame that represents an individual with Low risk score for reference. We need to compute the probability of readmission after being admitted to a treatment, with or without a therapeutic discharge, for the different periods.

For mstate package, it is possible to use simulation to calculate transition probabilities through `mssample`.

In semi-Markov models, solving the Kolmogorov forward equation numerically is not feasible because the transition is no longer a deterministic function of t, depending on the transition history to estimate differences. Considering the abovementioned, we calculated the transition probabilities not through a deterministic approach, but following a probabilistic one through resamples.

The cumulative hazards obtained are used to simulate the times at which patients transition between health states,  that is,  state occupancy probabilities with a “clock-reset” model at the times specified by 500 points.

We used a number of `r format(n_iter/2, big.mark=",")` resamples of trajectories.

<br>

```{r probtrans_semimark_ci951_mssample,eval=T, echo=T, paged.print=TRUE, error=T}
#, fig.height=13, fig.width=10, fig.cap="Figure 12a. Aalen-Johansen estimator with confidence intervals", fig.align="center"
#n_iter=1000

time_before_probtrans_ci95<-Sys.time()
#load("C:/Users/andre/Desktop/SUD_CL/mult_state_carla_2.RData")
#For semi-Markov models, mstate provides the function mssample to produce both simulated
#trajectories and transition probability matrices from semi-Markov models, given the estimated
#piecewise-constant cumulative hazards (Fiocco, Putter, and van Houwelingen 2008), produced
#by msfit or msfit.flexsurvreg, though this is generally less efficient than pmatrix.simfs.
#PARA SEMI-MARKOV, PODEMOS SIMULAR TRAYECTORIAS Y MATRICES DE PROBABILIDADES DE TRANSICIÓN, 
#DADOS LOS HAZARDS PIECEWISE-CONSTANT DADOS POR MSFIT, AUNQUE ES MENOS EFICIENTE QUE PMATRIX.SIMFS


invisible(c("mssample"))
#The mstate::mssample() function works by sampling survival times from each possible transition from the cumulative hazards. More precisely, the cumulative hazards are used to simulate the (discrete) times at which patients transition between health states using the base R function sample(), which is, in turn, used to count the number of patients in each health state at the times specified by the argument tvec.
#Multi-state models can be simulated using mstate::mssample(), which simulates state occupancy probabilities from predicted cumulative hazards.
#The mstate::mssample() function works by sampling survival times from each possible transition from the cumulative hazards. More precisely, the cumulative hazards are used to simulate the (discrete) times at which patients transition between health states using the base R function sample(), which is, in turn, used to count the number of patients in each health state at the times specified by the argument tvec.
#The function below uses mstate::mssample() to simulate state occupancy probabilities with a “clock-reset” model at the times specified in yr_grid.

#https://www.researchgate.net/publication/303029139_flexsurv_A_Platform_for_Parametric_Survival_Modeling_in_R/fulltext/5735e2f608aea45ee83ca2c0/flexsurv-A-Platform-for-Parametric-Survival-Modeling-in-R.pdf
#Jackson C. H. (2016). flexsurv: A Platform for Parametric Survival Modeling in R. Journal of statistical software, 70, i08. https://doi.org/10.18637/jss.v070.i08
#For semi-Markov models, mstate provides the function mssample to produce both simulated
#trajectories and transition probability matrices from semi-Markov models, given the estimated
#piecewise-constant cumulative hazards

# piece-wise constant estimates
set.seed(1234)
pmatrix_cox_a_0<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500)
set.seed(1234)
pmatrix_cox_b_0<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500)

	
#A list with elements state, specifying the starting state(s), time, the starting time(s), and tstate, a numeric vector of length the number of states, specifying at what times states have been visited, if appropriate. The default of tstate is NULL; more information can be found under Details.
#The elements state and time may either be scalars or vectors, in which case different sampled paths may start from different states or at different times. By default, all sampled paths start from state 1 at time 0.
set.seed(1234)
pmatrix_cox_a_0_s2<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 2, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s2<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 2, time = 0, tstate = NULL))
#cens=An independent censoring distribution, given as a data frame with time and Haz
set.seed(1234)
pmatrix_cox_a_0_s3<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 3, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s3<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 3, time = 0, tstate = NULL))
#cens=An independent censoring distribution, given as a data frame with time and Haz
set.seed(1234)
pmatrix_cox_a_0_s4<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 4, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s4<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 4, time = 0, tstate = NULL))
#cens=An independent censoring distribution, given as a data frame with time and Haz
set.seed(1234)
pmatrix_cox_a_0_s5<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 5, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s5<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 5, time = 0, tstate = NULL))
#cens=An independent censoring distribution, given as a data frame with time and Haz
set.seed(1234)
pmatrix_cox_a_0_s6<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 6, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s6<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 6, time = 0, tstate = NULL))
#cens=An independent censoring distribution, given as a data frame with time and Haz
set.seed(1234)
pmatrix_cox_a_0_s7<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 7, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s7<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 7, time = 0, tstate = NULL))
#cens=An independent censoring distribution, given as a data frame with time and Haz
set.seed(1234)
pmatrix_cox_a_0_s8<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 8, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s8<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 8, time = 0, tstate = NULL))
#cens=An independent censoring distribution, given as a data frame with time and Haz
set.seed(1234)
pmatrix_cox_a_0_s9<-
mstate::mssample(msf0$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 9, time = 0, tstate = NULL))
set.seed(1234)
pmatrix_cox_b_0_s9<-
mstate::mssample(msf1$Haz, trans = trans_matrix, clock = "reset", M = n_iter/2, tvec = seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/500),do.trace=500,
                 history=list(state = 9, time = 0, tstate = NULL))
invisible("See cens")
#cens = data.frame(time=c(0,3000),surv=c(1,0)))    #Adm censoring at t=3000

#cens=An independent censoring distribution, given as a data frame with time and Haz
#10 states
```


<br>

```{r mssample_plot, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 3. Estimate of State Occupancies at Baseline, Ten-states model", fig.align="center", error=T}
#pmatrix_t_a_df_final pmatrix_t_b_df_final pmatrix_4s_t_a_df_final pmatrix_4s_t_b_df_final

states_trans_lab<-paste0(1:10,") ",states_trans)
attr(states_trans_lab,"names")<-1:10

ab_pmatrix<-
  pmatrix_cox_a_0 %>% 
  dplyr::left_join(pmatrix_cox_b_0, by="time", suffix=c("",".w_covs.res.s1")) %>%
  dplyr::left_join(pmatrix_cox_a_0_s2, by="time", suffix=c("",".w_covs.out.s2")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s2, by="time", suffix=c("",".w_covs.res.s2")) %>% 
  dplyr::left_join(pmatrix_cox_a_0_s3, by="time", suffix=c("",".w_covs.out.s3")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s3, by="time", suffix=c("",".w_covs.res.s3")) %>% 
  dplyr::left_join(pmatrix_cox_a_0_s4, by="time", suffix=c("",".w_covs.out.s4")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s4, by="time", suffix=c("",".w_covs.res.s4")) %>% 
  dplyr::left_join(pmatrix_cox_a_0_s5, by="time", suffix=c("",".w_covs.out.s5")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s5, by="time", suffix=c("",".w_covs.res.s5")) %>% 
  dplyr::left_join(pmatrix_cox_a_0_s6, by="time", suffix=c("",".w_covs.out.s6")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s6, by="time", suffix=c("",".w_covs.res.s6")) %>% 
  dplyr::left_join(pmatrix_cox_a_0_s7, by="time", suffix=c("",".w_covs.out.s7")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s7, by="time", suffix=c("",".w_covs.res.s7")) %>% 
  dplyr::left_join(pmatrix_cox_a_0_s8, by="time", suffix=c("",".w_covs.out.s8")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s8, by="time", suffix=c("",".w_covs.res.s8")) %>% 
  dplyr::left_join(pmatrix_cox_a_0_s9, by="time", suffix=c("",".w_covs.out.s9")) %>% 
  dplyr::left_join(pmatrix_cox_b_0_s9, by="time", suffix=c("",".w_covs.res.s9")) %>% 
  dplyr::rename("pstate1.w_covs.out.s1"="pstate1",
                "pstate2.w_covs.out.s1"="pstate2",
                "pstate3.w_covs.out.s1"="pstate3",
                "pstate4.w_covs.out.s1"="pstate4",
                "pstate5.w_covs.out.s1"="pstate5",
                "pstate6.w_covs.out.s1"="pstate6",
                "pstate7.w_covs.out.s1"="pstate7",
                "pstate8.w_covs.out.s1"="pstate8",
                "pstate9.w_covs.out.s1"="pstate9",
                "pstate10.w_covs.out.s1"="pstate10") %>% 
  #pstate1–pstate3 are close to the first rows of the matrices returned by pmatrix.fs
  reshape2::melt(id.vars="time") %>% #janitor::tabyl(variable)
  dplyr::mutate(start=stri_sub(variable,-1,-1)) %>% 
  dplyr::mutate(state=stringi::stri_match_first_regex(variable, "(.*?)\\.")[,2]) %>%
  dplyr::mutate(state=gsub("pstate", "", state), state=as.numeric(state)) %>% 
  dplyr::mutate(setting= dplyr::case_when(grepl(".out",variable)~"Outpatient",
                                               grepl(".res",variable)~"Residential",
                                               T~NA_character_))

fig_ab_pmatrix<-
  #janitor::tabyl(start)
ggplot(ab_pmatrix, aes(time, value, color= start, linetype =setting))+
  geom_step(size=1, alpha=.65) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 2))+
  facet_wrap(state~., ncol=1, scales="free_y", labeller = as_labeller(states_trans_lab)) + 
  #facet_wrap(state~., ncol=1, scales="free_y") + #type_of_program
  scale_color_manual(name = "Starting from\nState", values=c("#54478C","#2C699A","#048BA8","#0DB39E",
                                                      "#16DB93","#83E377","#EFEA5A","#F1C453","#F29E4C"), labels= as.character(c(1:9))) + # "#A65100" #"Cox",
  scale_linetype_manual(name= "Type of\nprogram",values=c(1,4), labels=c("Outpatient","Residential")) +
  scale_x_continuous(breaks=seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11),
                     label=round(seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11)/365.25,2))+
  xlab("Years") + 
  ylab("") + 
  theme_minimal()

fig_ab_pmatrix

if(no_mostrar==1){
jpeg(paste0(gsub("SUD_CL/Matching_Process_APR_21.Rmd","",path),"_mult_state_ags/pmatrix_probtrans_semimark.jpg"), height=20, width= 10, res= 320, units = "in")
fig_ab_pmatrix
dev.off()
}
```

<br>

### Landmark Aalen-Johansen

The observation in a given state at a given time and estimate the state occupation. The idea is to select individuals that are under
probabilities within this subset. Landmark approach uses less data than AJ.

<div style="border: 1px solid #ddd; padding: 5px; overflow-y: scroll; height:350px; overflow-x: scroll; width:100%">
```{r LMAJ, eval=T, echo=T, paged.print=TRUE, error=T}
#devtools::install_github("hputter/mstate")
invisible(c("For semi-Markov models, mstate provides the function mssample to produce both simulated trajectories and transition probability matrices from semi-Markov models, given the estimated piecewise-constant cumulative hazards (Fiocco et al. 2008), produced by msfit or msfit.flexsurvreg, though this is generally less efficient than pmatrix.simfs. In this example, 1000 samples from mssample give estimates of transition probabilities that are accurate to within around 0.02. However with pmatrix.simfs, greater precision is achieved by simulating 100 times as many trajectories in a shorter time"))

time_before_LMAJ<-Sys.time()

trans_df<-cbind.data.frame(transition_label,trans=1:max(trans_matrix,na.rm=T))

lmaj_df<-data.frame()
for (transo in 1:9){
  if(tryCatch({LMAJ(pr0,from=transo,s=1,method="aalen")}, error=function(e) {data.frame()}) %>% data.frame() %>% nrow()>0){
  lmaj_df<- rbind.data.frame(lmaj_df,
     cbind(pr="out",
                  LMAJ(pr0, #An "msdata" object, as for instance prepared by link{msprep}
                  from=transo, ##Either a single state or a set of states in the state space 1,...,S
                  s=1,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  ),transo=transo))
  } else if (tryCatch({LMAJ(pr1,from=transo,s=1,method="aalen")}, error=function(e) {data.frame()}) %>% data.frame() %>% nrow()>0){
    lmaj_df<- rbind.data.frame(lmaj_df,
     cbind(pr="out",
                  LMAJ(pr1, #An "msdata" object, as for instance prepared by link{msprep}
                  from=transo, ##Either a single state or a set of states in the state space 1,...,S
                  s=1,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  ),transo=transo))
    } else {rep(0,21)
  }
}

pr0_sel<-pr0[,c("id", "from", "to", "trans", "Tstart", "Tstop", "time", "status", "tipo_de_plan_res_1")]
attr(pr0_sel,"trans")<-trans_matrix

pr1_sel<-pr1[,c("id", "from", "to", "trans", "Tstart", "Tstop", "time", "status", "tipo_de_plan_res_1")]
attr(pr1_sel,"trans")<-trans_matrix

lmaj_out_1<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_2<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_3<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_4<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_5<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_6<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_7<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_8<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_9<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj_res_1<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_2<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_3<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_4<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_5<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_6<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_7<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_8<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_9<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

lmaj_out_1_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_2_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_3_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_4_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_5_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_6_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_7_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_8_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_9_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj_res_1_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_2_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_3_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_4_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_5_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_6_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_7_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_8_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_9_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

lmaj_out_1_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_2_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_3_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_4_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_5_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_6_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_7_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_8_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_9_365<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj_res_1_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_2_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_3_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_4_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_5_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_6_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_7_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_8_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_9_365<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

lmaj_out_1_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_2_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_3_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_4_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_5_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_6_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_7_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_8_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_out_9_1095<-
LMAJ(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj_res_1_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_2_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_3_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_4_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_5_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_6_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_7_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_8_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj_res_9_1095<-
LMAJ(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )

#if (nrow(mf) ==0) stop("No (non-missing) observations")

LMAJ <- function(msdata, s, from, method=c("aalen", "greenwood"))
{
msdata<-pr1_sel
s<-90
from<-2
method<-"aalen"
  
  tmat <- attr(msdata, "trans")
  if (is.null(tmat)) stop("msdata object should have a \"trans\" attribute")
  K <- nrow(tmat)
  if (any(is.na(match(from, 1:K)))) stop("from should be subset of 1:K with K number of states")
  #Given a dataset in long format, for instance generated by msprep, this function takes a cross-section at a given time point, to list the subjects under observation (at risk) at that time point and the states currently occupied.
  xss <- xsect(msdata, s)
  #Por ejemplo, en el estado 2, table(xss$state) resulta en 3 estados: 1 (11,329), 2(72) & 3(57)
  #Se selecciona a los pacientes que tenian una transición desde el estado elegido(from) en el momento elegido
  infrom <- xss$id[xss$state %in% from]
  #https://rdrr.io/cran/mstate/man/cutLMms.html
  msdatas <- cutLMms(msdata, LM=s)
  msdatasfrom <- msdatas[msdatas$id %in% infrom, ]
  c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), data=msdatasfrom)
  msf0 <- msfit(c0, trans=tmat)
  pt0 <- probtrans(msf0, predt=s, method=method)[from]
  if (length(from) == 1)
    return(pt0[[1]])
  else {
    xsss <- xss[xss$state %in% from, ]
    xsss$state <- factor(xsss$state, levels=from)
    tbl <- table(xsss$state)
    p <- tbl / sum(tbl)
    varp <- (diag(p) - p %*% t(p)) / sum(tbl)
    # Relying on fact that all items from list have exactly the same size and structure
    # and that the sum of p equals 1; sorry for the double for-loop
    res <- tmp1 <- tmp2 <- 0
    for (j in 1:length(from)) {
      ptj <- pt0[[j]]
      res <- res + p[j] * ptj[, 1 + (1:K)]
      tmp2 <- tmp2 + p[j] * (1 - p[j]) * (ptj[, K+1 + (1:K)])^2
      for (k in 1:length(from)) {
        ptk <- pt0[[k]]
        tmp1 <- tmp1 + varp[j,k] * ptj[, 1 + (1:K)] * ptk[, 1 + (1:K)]
      }
    }
    ses <- sqrt(tmp1 + tmp2)
    # take ptj as template and insert estimates and SE's
    pt <- ptj
    pt[, 1 + (1:K)] <- res
    pt[, K+1 + (1:K)] <- ses
    return(pt)
  }
}

time_after_LMAJ<-Sys.time()

#LMAJ(pr1,from=1,s=90,method="aalen")

paste0("Time in process: ");time_after_LMAJ-time_before_LMAJ
```
</div>



<div style="border: 1px solid #ddd; padding: 5px; overflow-y: scroll; height:350px; overflow-x: scroll; width:100%">
```{r LMAJ2, eval=T, echo=T, paged.print=TRUE, error=T}
LMAJ2<-function (msdata, s, from, method = c("aalen", "greenwood")) 
{
  tmat <- attr(msdata, "trans")
  if (is.null(tmat)) 
    stop("msdata object should have a \"trans\" attribute")
  K <- nrow(tmat)
  if (any(is.na(match(from, 1:K)))) 
    stop("from should be subset of 1:K with K number of states")
  xss <- xsect(msdata, s)
  infrom <- xss$id[xss$state %in% from]
  msdatas <- cutLMms(msdata, LM = s)
  msdatasfrom <- msdatas[msdatas$id %in% infrom, ]
  
  c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
              data = msdatasfrom)
  msf0 <- msfit2(c0, trans = tmat)
  pt0 <- probtrans(msf0, predt = s, method = method)[from]
  if (length(from) == 1) 
    return(pt0[[1]])
  else {
    xsss <- xss[xss$state %in% from, ]
    xsss$state <- factor(xsss$state, levels = from)
    tbl <- table(xsss$state)
    p <- tbl/sum(tbl)
    varp <- (diag(p) - p %*% t(p))/sum(tbl)
    res <- tmp1 <- tmp2 <- 0
    for (j in 1:length(from)) {
      ptj <- pt0[[j]]
      res <- res + p[j] * ptj[, 1 + (1:K)]
      tmp2 <- tmp2 + p[j] * (1 - p[j]) * (ptj[, K + 1 + 
                                                (1:K)])^2
      for (k in 1:length(from)) {
        ptk <- pt0[[k]]
        tmp1 <- tmp1 + varp[j, k] * ptj[, 1 + (1:K)] * 
          ptk[, 1 + (1:K)]
      }
    }
    ses <- sqrt(tmp1 + tmp2)
    pt <- ptj
    pt[, 1 + (1:K)] <- res
    pt[, K + 1 + (1:K)] <- ses
    return(pt)
  }
}

msfit2<-function (object, newdata, variance = TRUE, vartype = c("aalen", 
                                                                "greenwood"), trans)  
{
  if (!is.null((object$call)$weights) || !is.null(object$weights)) 
    stop("msfit cannot (yet) compute the result for a weighted model")
  Terms <- terms(object)
  strat <- attr(Terms, "specials")$strata
  cluster <- attr(Terms, "specials")$cluster
  if (length(cluster)) 
    stop("cluster terms are not supported")
  if (!is.null(attr(object$terms, "specials")$tt)) 
    stop("msfit cannot yet process coxph models with a tt term")
  resp <- attr(Terms, "variables")[attr(Terms, "response")]
  nvar <- length(object$coefficients)
  score <- exp(object$linear.predictors)
  vartype <- match.arg(vartype)
  if (is.na(vartype)) 
    stop("Invalid variance type specified")
  has.strata <- !is.null(attr(object$terms, "specials")$strata)
  if (is.null(object$y) || is.null(object[["x"]]) || 
      !is.null(object$call$weights) || (has.strata && is.null(object$strata)) || 
      !is.null(attr(object$terms, "offset"))) {
    mf <- model.frame(object)
  }
  else mf <- NULL
  if (is.null(mf)) 
    y <- object[["y"]]
  else {
    y <- model.response(mf)
    y2 <- object[["y"]]
    if (!is.null(y2) && any(dim(y2) != dim(y))) 
      stop("Could not reconstruct the y vector")
  }
  if (is.null(object[["x"]])) 
    x <- model.matrix(object, data = mf)
  else x <- object[["x"]]
  n <- nrow(y)
  if (n != object$n[1] || nrow(x) != n) 
    stop("Failed to reconstruct the original data set")
  type <- attr(y, "type")
  if (type == "counting") 
    lasty <- max(y[, 2])
  else if (type == "right") 
    lasty <- max(y[, 1])
  else stop("Cannot handle \"", type, "\" type survival data")
  if (is.null(mf)) 
    offset <- 0
  else {
    offset <- model.offset(mf)
    if (is.null(offset)) 
      offset <- 0
  }
  Terms <- object$terms
  if (!has.strata) 
    strata <- rep(0L, n)
  else {
    stangle <- untangle.specials(Terms, "strata")
    strata <- object$strata
    if (is.null(strata)) {
      if (length(stangle$vars) == 1) 
        strata <- mf[[stangle$vars]]
      else strata <- strata(mf[, stangle$vars], shortlabel = TRUE)
    }
  }
  if (has.strata) {
    temp <- attr(Terms, "specials")$strata
    factors <- attr(Terms, "factors")[temp, ]
    strata.interaction <- any(t(factors) * attr(Terms, "order") > 
                                1)
    if (strata.interaction) 
      stop("Interaction terms with strata not supported")
  }
  if (vartype == "greenwood") {
    if (missing(trans)) 
      stop("argument trans missing; needed for vartype=\"greenwood\"")
    labels <- attr(Terms, "term.labels")
    if (length(labels) != 1) 
      stop("Invalid formula for greenwood, ~strata(trans) needed, no covariates allowed")
    if (attr(Terms, "term.labels") != "strata(trans)") 
      stop("Invalid formula for greenwood, ~strata(trans) needed, no covariates allowed")
    sf0 <- summary(survfit(object))
    norisk <- sf0$n.risk
    noevent <- sf0$n.event
    
    
    if(is.null(sf0$strata)){
      
      sf0$strata<-rep(max(trans, na.rm = T),length(noevent))  
      
    }
    
    length(norisk)
    length(noevent)
    as.numeric(sf0$strata) 
    
    length(as.numeric(sf0$strata))
    
    
    
    sf0 <- data.frame(time = sf0$time, Haz = -log(sf0$surv), 
                      norisk = norisk, noevent = noevent, trans = as.numeric(sf0$strata))
    
    
    
    allt <- sort(unique(c(sf0$time, lasty)))
    nt <- length(allt)
    K <- nrow(to.trans2(trans))
    Haz <- data.frame(time = rep(allt, K), Haz = NA, trans = rep(1:K, 
                                                                 rep(nt, K)))
    if (variance) {
      tr12 <- data.frame(trans1 = rep(1:K, rep(K, K)), 
                         trans2 = rep(1:K, K))
      tr12 <- tr12[tr12$trans1 <= tr12$trans2, ]
      varHaz <- data.frame(time = rep(allt, K * (K + 1)/2), 
                           varHaz = 0, trans1 = rep(tr12$trans1, rep(nt, 
                                                                     K * (K + 1)/2)), trans2 = rep(tr12$trans2, 
                                                                                                   rep(nt, K * (K + 1)/2)))
    }
    S <- nrow(trans)
    for (s in 1:S) {
      trs <- trans[s, ]
      trs <- trs[!is.na(trs)]
      ntrs <- length(trs)
      if (ntrs > 0) {
        for (i in 1:ntrs) {
          trans1 <- trs[i]
          sf1 <- sf0[sf0$trans == trans1, ]
          Haz$Haz[(trans1 - 1) * nt + match(sf1$time, 
                                            allt)] <- sf1$Haz
          Haz$Haz[(trans1 - 1) * nt + 1:nt] <- NAfix2(Haz$Haz[(trans1 - 
                                                                1) * nt + 1:nt], subst = 0)
          if (variance) {
            varHaz1 <- cumsum((sf1$norisk - sf1$noevent) * 
                                sf1$noevent/sf1$norisk^3)
            varHaz11 <- varHaz[varHaz$trans1 == trans1 & 
                                 varHaz$trans2 == trans1, ]
            varHaz11$varHaz <- NA
            varHaz11$varHaz[match(sf1$time, allt)] <- varHaz1
            varHaz11$varHaz <- NAfix2(varHaz11$varHaz, 
                                     subst = 0)
            varHaz[varHaz$trans1 == trans1 & varHaz$trans2 == 
                     trans1, ] <- varHaz11
            if (i < ntrs) {
              for (j in ((i + 1):ntrs)) {
                trans2 <- trs[j]
                sf2 <- sf0[sf0$trans == trans2, ]
                jointt <- intersect(sf1$time, sf2$time)
                if (length(jointt) > 0) {
                  varHazij <- rep(NA, length(jointt))
                  ik <- match(jointt, sf1$time)
                  jk <- match(jointt, sf2$time)
                  varHazij <- cumsum(-sf1$noevent[ik] * 
                                       sf2$noevent[jk]/sf1$norisk[ik]^3)
                  varHaz12 <- varHaz[varHaz$trans1 == 
                                       trans1 & varHaz$trans2 == trans2, 
                                     ]
                  varHaz12$varHaz <- NA
                  varHaz12$varHaz[match(jointt, allt)] <- varHazij
                  varHaz12$varHaz <- NAfix2(varHaz12$varHaz, 
                                           subst = 0)
                  varHaz[varHaz$trans1 == trans1 & varHaz$trans2 == 
                           trans2, ] <- varHaz12
                }
              }
            }
          }
        }
      }
    }
  }
  else {
    labels <- attr(Terms, "term.labels")
    if (length(labels) == 1) {
      if (labels == "strata(trans)") {
        sf0 <- summary(survfit(object))
        norisk <- sf0$n.risk
        noevent <- sf0$n.event
        
        if(is.null(sf0$strata)){
          
          sf0$strata<-rep(max(trans, na.rm = T),length(noevent))  
          
        }
        
        sf0 <- data.frame(time = sf0$time, Haz = -log(sf0$surv), 
                          norisk = norisk, noevent = noevent, var = sf0$std.err^2/(sf0$surv)^2, 
                          trans = as.numeric(sf0$strata))
        allt <- sort(unique(c(sf0$time, lasty)))
        nt <- length(allt)
        K <- max(sf0$trans)
        Haz <- data.frame(time = rep(allt, K), Haz = NA, 
                          trans = rep(1:K, rep(nt, K)))
        if (variance) {
          tr12 <- data.frame(trans1 = rep(1:K, rep(K, 
                                                   K)), trans2 = rep(1:K, K))
          tr12 <- tr12[tr12$trans1 <= tr12$trans2, ]
          varHaz <- data.frame(time = rep(allt, K * (K + 
                                                       1)/2), varHaz = 0, trans1 = rep(tr12$trans1, 
                                                                                       rep(nt, K * (K + 1)/2)), trans2 = rep(tr12$trans2, 
                                                                                                                             rep(nt, K * (K + 1)/2)))
        }
        for (k in 1:K) {
          sfk <- sf0[sf0$trans == k, ]
          wht <- match(sfk$time, allt)
          Hazk <- Haz[Haz$trans == k, ]
          Hazk$Haz[wht] <- sfk$Haz
          Hazk$Haz <- NAfix2(Hazk$Haz, subst = 0)
          Haz[Haz$trans == k, ] <- Hazk
          if (variance) {
            varHazkk <- varHaz[varHaz$trans1 == k & varHaz$trans2 == 
                                 k, ]
            varHazkk$varHaz <- NA
            varHazkk$varHaz[wht] <- sfk$var
            varHazkk$varHaz <- NAfix2(varHazkk$varHaz, 
                                     subst = 0)
            varHaz[varHaz$trans1 == k & varHaz$trans2 == 
                     k, ] <- varHazkk
          }
        }
      }
    }
    else {
      method <- object$method
      if (method == "breslow") 
        method <- 1
      else if (method == "efron") 
        method <- 2
      else stop("Only \"efron\" and \"breslow\" methods for ties supported")
      type <- attr(y, "type")
      if (type == "counting") {
        if (has.strata) 
          ord <- order(mf[, strat], y[, 2], -y[, 3])
        else ord <- order(y[, 2], -y[, 3])
      }
      else if (type == "right") {
        if (has.strata) 
          ord <- order(mf[, strat], y[, 1], -y[, 2])
        else ord <- order(y[, 1], -y[, 2])
        miny <- min(y[, 1])
        if (miny < 0) 
          y <- cbind(2 * miny - 1, y)
        else y <- cbind(-1, y)
      }
      else stop("Cannot handle \"", type, "\" type survival data")
      if (variance) 
        x <- x[ord, ]
      else x <- 0
      if (has.strata) 
        newstrat <- (as.numeric(mf[, strat]))[ord]
      else newstrat <- rep(1, n)
      newstrat <- cumsum(table(newstrat))
      H <- length(newstrat)
      subterms <- function(tt, i) {
        dataClasses <- attr(tt, "dataClasses")
        predvars <- attr(tt, "predvars")
        oldnames <- dimnames(attr(tt, "factors"))[[1]]
        tt <- tt[i]
        index <- match(dimnames(attr(tt, "factors"))[[1]], 
                       oldnames)
        if (length(index) > 0) {
          if (!is.null(predvars)) 
            attr(tt, "predvars") <- predvars[c(1, 
                                               index + 1)]
          if (!is.null(dataClasses)) 
            attr(tt, "dataClasses") <- dataClasses[index]
        }
        tt
      }
      if (has.strata) {
        temp <- untangle.specials(Terms, "strata")
        if (length(temp$vars)) 
          Terms <- subterms(Terms, -temp$terms)
      }
      Terms2 <- delete.response(Terms)
      if (has.strata) {
        if (length(attr(Terms2, "specials")$strata)) 
          Terms2 <- subterms(Terms2, -attr(Terms2, "specials")$strata)
        if (!is.null(object$xlevels)) {
          myxlev <- object$xlevels[match(attr(Terms2, 
                                              "term.labels"), names(object$xlevels), 
                                         nomatch = 0)]
          if (length(myxlev) == 0) 
            myxlev <- NULL
        }
        else myxlev <- NULL
        mf2 <- model.frame(Terms2, data = newdata, xlev = myxlev)
      }
      else mf2 <- model.frame(Terms2, data = newdata, xlev = object$xlevels)
      offset2 <- 0
      if (!missing(newdata)) {
        offset2 <- model.offset(mf2)
        if (length(offset2) > 0) 
          offset2 <- offset2 - mean(offset)
        else offset2 <- 0
        x2 <- model.matrix(Terms2, mf2)[, -1, drop = FALSE]
      }
      else stop("newdata missing")
      if (has.strata & is.null(newdata$strata)) 
        stop("no \"strata\" column present in newdata")
      n2 <- nrow(x2)
      coef <- ifelse(is.na(object$coefficients), 0, object$coefficients)
      newrisk <- exp(c(x2 %*% coef) + offset2 - sum(coef * 
                                                      object$means))
      dimnames(y) <- NULL
      storage.mode(y) <- "double"
      ndead <- sum(y[, 3])
      untimes <- sort(unique(y[, 2][y[, 3] == 1]))
      nt <- length(untimes)
      surv <- .C("agmssurv", sn = as.integer(n), 
                 sp = as.integer(nvar), svar = as.integer(variance), 
                 smethod = as.integer(method), sH = as.integer(H), 
                 sK = as.integer(n2), snt = as.integer(nt), y = y[ord, 
                                                                  ], score = as.double(score[ord]), xmat = as.double(x), 
                 varcov = as.double(object$var), strata = as.integer(c(0, 
                                                                       newstrat)), kstrata = as.integer(newdata$strata), 
                 unt = as.double(untimes), newx = as.double(x2), 
                 newrisk = as.double(newrisk), Haz = double(nt * 
                                                              n2), varHaz = double(nt * n2 * (n2 + 1)/2), 
                 d = double(3 * nvar), work = double(nt * n2 * 
                                                       (nvar + 1)))
      Haz <- data.frame(time = rep(untimes, n2), Haz = surv$Haz, 
                        trans = rep(1:n2, rep(nt, n2)))
      varHaz <- as.vector(t(matrix(surv$varHaz, ncol = nt)))
      hlp <- matrix(c(rep(1:n2, rep(n2, n2)), rep(1:n2, 
                                                  n2)), n2^2, 2)
      hlp <- hlp[hlp[, 1] <= hlp[, 2], ]
      varHaz <- data.frame(time = rep(untimes, n2 * (n2 + 
                                                       1)/2), varHaz = varHaz, trans1 = rep(hlp[, 1], 
                                                                                            rep(nt, n2 * (n2 + 1)/2)), trans2 = rep(hlp[, 
                                                                                                                                        2], rep(nt, n2 * (n2 + 1)/2)))
      if (lasty > max(untimes)) {
        Hmat <- matrix(Haz$Haz, nrow = nt)
        Hmat <- rbind(Hmat, Hmat[nt, ])
        vHmat <- matrix(varHaz$varHaz, nrow = nt)
        vHmat <- rbind(vHmat, vHmat[nt, ])
        untimes <- c(untimes, lasty)
        nt <- nt + 1
        Haz <- data.frame(time = rep(untimes, n2), Haz = as.vector(Hmat), 
                          trans = rep(1:n2, rep(nt, n2)))
        varHaz <- data.frame(time = rep(untimes, n2 * 
                                          (n2 + 1)/2), varHaz = as.vector(vHmat), trans1 = rep(hlp[, 
                                                                                                   1], rep(nt, n2 * (n2 + 1)/2)), trans2 = rep(hlp[, 
                                                                                                                                                   2], rep(nt, n2 * (n2 + 1)/2)))
      }
    }
  }
  if (variance) 
    res <- list(Haz = Haz, varHaz = varHaz, trans = trans)
  else res <- list(Haz = Haz, trans = trans)
  class(res) <- "msfit"
  return(res)
}

NAfix2 <- function(x, subst=-Inf) {
  ### Written by Christian Hoffmann; propagate last known non-NA value
  ### Input:
  ###     x: numeric vector
  ###     subst: scalar inidicating which value should replace NA
  ###         if x starts with a series of NA's
  ### Output:
  ###     (numeric) vector, with NA's replaced by last known non-NA value,
  ###         or 'subst'
  spec <- max(x[!is.na(x)])+1
  x <- c(spec,x)
  while (any(is.na(x))) x[is.na(x)] <- x[(1:length(x))[is.na(x)]-1]
  x[x==spec] <- subst
  x <- x[-1]
  x
}
#devtools::install_github("hputter/mstate")
invisible(c("For semi-Markov models, mstate provides the function mssample to produce both simulated trajectories and transition probability matrices from semi-Markov models, given the estimated piecewise-constant cumulative hazards (Fiocco et al. 2008), produced by msfit or msfit.flexsurvreg, though this is generally less efficient than pmatrix.simfs. In this example, 1000 samples from mssample give estimates of transition probabilities that are accurate to within around 0.02. However with pmatrix.simfs, greater precision is achieved by simulating 100 times as many trajectories in a shorter time"))

time_before_LMAJ2<-Sys.time()

trans2_df<-cbind.data.frame(transition_label,trans=1:max(trans_matrix,na.rm=T))

lmaj_df2<-data.frame()
for (transo in 1:9){
  if(tryCatch({LMAJ2(pr0,from=transo,s=1,method="aalen")}, error=function(e) {data.frame()}) %>% data.frame() %>% nrow()>0){
  lmaj_df2<- rbind.data.frame(lmaj_df2,
     cbind(pr="out",
                  LMAJ2(pr0, #An "msdata" object, as for instance prepared by link{msprep}
                  from=transo, ##Either a single state or a set of states in the state space 1,...,S
                  s=1,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  ),transo=transo))
  } else if (tryCatch({LMAJ2(pr1,from=transo,s=1,method="aalen")}, error=function(e) {data.frame()}) %>% data.frame() %>% nrow()>0){
    lmaj_df2<- rbind.data.frame(lmaj_df2,
     cbind(pr="out",
                  LMAJ2(pr1, #An "msdata" object, as for instance prepared by link{msprep}
                  from=transo, ##Either a single state or a set of states in the state space 1,...,S
                  s=1,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  ),transo=transo))
    } else {rep(0,21)
  }
}

pr0_sel<-pr0[,c("id", "from", "to", "trans", "Tstart", "Tstop", "time", "status", "tipo_de_plan_res_1")]
attr(pr0_sel,"trans")<-trans_matrix

pr1_sel<-pr1[,c("id", "from", "to", "trans", "Tstart", "Tstop", "time", "status", "tipo_de_plan_res_1")]
attr(pr1_sel,"trans")<-trans_matrix

lmaj2_out_1<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_2<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_3<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_4<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_5<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_6<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_7<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_8<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_9<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj2_res_1<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_2<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_3<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_4<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_5<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_6<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_7<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_8<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_9<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=90,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )

#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

lmaj2_out_1_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_2_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_3_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_4_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_5_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_6_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_7_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_8_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_9_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj2_res_1_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_2_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_3_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_4_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_5_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_6_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_7_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_8_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_9_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

lmaj2_out_1_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_2_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_3_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_4_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_5_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_6_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_7_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_8_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_9_365<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj2_res_1_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_2_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_3_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_4_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_5_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_6_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_7_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_8_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_9_365<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_
#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_#_

lmaj2_out_1_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_2_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_3_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_4_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_5_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_6_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_7_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_8_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_out_9_1095<-
LMAJ2(pr0_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )


lmaj2_res_1_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=1, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_2_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=2, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_3_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=3, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_4_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=4, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_5_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=5, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_6_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=6, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_7_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=7, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_8_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=8, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )
lmaj2_res_9_1095<-
LMAJ2(pr1_sel, #An "msdata" object, as for instance prepared by link{msprep}
                  from=9, ##Either a single state or a set of states in the state space 1,...,S
                  s=365*3,  #The prediction time point s from which transition probabilities are to be obtained
                  method ="aalen" #The method for calculating variances, as in probtrans
                  )

#if (nrow(mf) ==0) stop("No (non-missing) observations")
time_after_LMAJ2<-Sys.time()

#LMAJ(pr1,from=1,s=90,method="aalen")

paste0("Time in process: ");time_after_LMAJ-time_before_LMAJ
```
</div>


```{r lmaj_plot, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 4a. State Occupancies, landmark Aalen-Johansen estimator", fig.align="center", error=T}
#A data frame containing estimates and associated standard errors of the transition probabilities P(X(t)=k | X(s) in from) with s and from the arguments of the function.

#View(lmaj_df %>% dplyr::mutate_at(3:22,~round(.,2)) %>% dplyr::filter(time==90))
#View(lmaj_df %>% dplyr::mutate_at(3:22,~round(.,2)))

lmaj_plot<-
rbind(cbind(pr="res",lmaj_res_1,transo=1),
      cbind(pr="out",lmaj_out_1,transo=1)) %>% 
  melt(id.vars=c("pr","transo","time")) %>% 
  dplyr::rename("state_from"="transo") %>% 
  dplyr::mutate(state_to=stri_sub(variable,-1,-1)) %>%
    dplyr::mutate(setting= dplyr::case_when(grepl("out",pr)~"Outpatient",
                                            grepl("res",pr)~"Residential",
                                            T~NA_character_)) %>%
      dplyr::mutate(measure= dplyr::case_when(grepl("se",variable)~"se",
                                            grepl("pstate",variable)~"Estimate",
                                            T~NA_character_)) %>%
  dplyr::select(-pr,-variable) %>% 
  tidyr::pivot_wider(names_from=measure,values_from = value) %>% 
  dplyr::filter(state_from>0, state_to>0) %>% 
  purrr::when(dplyr::group_by(.,time, state_from, state_to, setting) %>% summarise(n=n()) %>% dplyr::filter(n>1)%>% nrow()>0 ~ stop("There are cases with differences different than 0 days of a variable that should be equal"), 
            ~.) %>%
  dplyr::mutate(state_from=factor(state_from),state_to=factor(state_to), setting=factor(setting)) %>%  
  ggplot(aes(time, Estimate, linetype =setting))+
  geom_step(size=1, alpha=.65) + 
  facet_wrap(state_to~., ncol=1, scales="free_y", labeller = as_labeller(states_trans_lab)) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 2))+
  #facet_wrap(state~., ncol=1, scales="free_y") + #type_of_program
  scale_color_manual(name = "Starting from\nState", values=c("#54478C","#2C699A","#048BA8","#0DB39E",
                                                      "#16DB93","#83E377","#EFEA5A","#F1C453","#F29E4C"), labels= as.character(c(1:9))) + # "#A65100" #"Cox",
  scale_linetype_manual(name= "Type of\nprogram",values=c(1,4), labels=c("Outpatient","Residential")) +
  scale_x_continuous(breaks=seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11),
                     label=round(seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11)/365.25,2))+
  xlab("Years") + 
  ylab("") + 
  theme_minimal()

lmaj_plot

if(no_mostrar==1){
jpeg(paste0(gsub("SUD_CL/Matching_Process_APR_21.Rmd","",path),"_mult_state_ags/lmaj_st_occ.jpg"), height=20, width= 10, res= 320, units = "in")
lmaj_plot
dev.off()
}
```


```{r lmaj_plot, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 4b. State Occupancies, landmark Aalen-Johansen estimator", fig.align="center", error=T}
#A data frame containing estimates and associated standard errors of the transition probabilities P(X(t)=k | X(s) in from) with s and from the arguments of the function.

#View(lmaj_df %>% dplyr::mutate_at(3:22,~round(.,2)) %>% dplyr::filter(time==90))
#View(lmaj_df %>% dplyr::mutate_at(3:22,~round(.,2)))

lmaj_plot2<-
rbind(cbind(pr="res",lmaj2_res_1,transo=1),
      cbind(pr="out",lmaj2_out_1,transo=1)) %>% 
  melt(id.vars=c("pr","transo","time")) %>% 
  dplyr::rename("state_from"="transo") %>% 
  dplyr::mutate(state_to=stri_sub(variable,-1,-1)) %>%
    dplyr::mutate(setting= dplyr::case_when(grepl("out",pr)~"Outpatient",
                                            grepl("res",pr)~"Residential",
                                            T~NA_character_)) %>%
      dplyr::mutate(measure= dplyr::case_when(grepl("se",variable)~"se",
                                            grepl("pstate",variable)~"Estimate",
                                            T~NA_character_)) %>%
  dplyr::select(-pr,-variable) %>% 
  tidyr::pivot_wider(names_from=measure,values_from = value) %>% 
  dplyr::filter(state_from>0, state_to>0) %>% 
  purrr::when(dplyr::group_by(.,time, state_from, state_to, setting) %>% summarise(n=n()) %>% dplyr::filter(n>1)%>% nrow()>0 ~ stop("There are cases with differences different than 0 days of a variable that should be equal"), 
            ~.) %>%
  dplyr::mutate(state_from=factor(state_from),state_to=factor(state_to), setting=factor(setting)) %>%  
  ggplot(aes(time, Estimate, linetype =setting))+
  geom_step(size=1, alpha=.65) + 
  facet_wrap(state_to~., ncol=1, scales="free_y", labeller = as_labeller(states_trans_lab)) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 2))+
  #facet_wrap(state~., ncol=1, scales="free_y") + #type_of_program
  scale_color_manual(name = "Starting from\nState", values=c("#54478C","#2C699A","#048BA8","#0DB39E",
                                                      "#16DB93","#83E377","#EFEA5A","#F1C453","#F29E4C"), labels= as.character(c(1:9))) + # "#A65100" #"Cox",
  scale_linetype_manual(name= "Type of\nprogram",values=c(1,4), labels=c("Outpatient","Residential")) +
  scale_x_continuous(breaks=seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11),
                     label=round(seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11)/365.25,2))+
  xlab("Years") + 
  ylab("") + 
  theme_minimal()

lmaj_plot2

if(no_mostrar==1){
jpeg(paste0(gsub("SUD_CL/Matching_Process_APR_21.Rmd","",path),"_mult_state_ags/lmaj_st_occ.jpg"), height=20, width= 10, res= 320, units = "in")
lmaj_plot2
dev.off()
}
```

```{r dfs_mstate,eval=T, echo=T, paged.print=TRUE, error=T}
# Prob.occ5 <- data.frame(P=tmp.prob,
# lci=tmp.prob-qnorm(0.975)*c(tmp$se1,tmp$se2,tmp$se3),
# uci=tmp.prob+qnorm(0.975)*c(tmp$se1,tmp$se2,tmp$se3))

lmaj_ci_df<-
rbind(cbind(pr="res",lmaj_res_1,transo=1),
      cbind(pr="out",lmaj_out_1,transo=1)) %>% 
  dplyr::mutate(lo_pstate1=pstate1-1.96*se1) %>% 
  dplyr::mutate(lo_pstate2=pstate2-1.96*se2) %>% 
  dplyr::mutate(lo_pstate3=pstate3-1.96*se3) %>% 
  dplyr::mutate(lo_pstate4=pstate4-1.96*se4) %>% 
  dplyr::mutate(lo_pstate5=pstate5-1.96*se5) %>% 
  dplyr::mutate(lo_pstate6=pstate6-1.96*se6) %>% 
  dplyr::mutate(lo_pstate7=pstate7-1.96*se7) %>% 
  dplyr::mutate(lo_pstate8=pstate8-1.96*se8) %>% 
  dplyr::mutate(lo_pstate9=pstate9-1.96*se9) %>% 
  dplyr::mutate(lo_pstate10=pstate10-1.96*se10) %>% 
  dplyr::mutate(up_pstate1=pstate1+1.96*se1) %>% 
  dplyr::mutate(up_pstate2=pstate2+1.96*se2) %>% 
  dplyr::mutate(up_pstate3=pstate3+1.96*se3) %>% 
  dplyr::mutate(up_pstate4=pstate4+1.96*se4) %>% 
  dplyr::mutate(up_pstate5=pstate5+1.96*se5) %>% 
  dplyr::mutate(up_pstate6=pstate6+1.96*se6) %>% 
  dplyr::mutate(up_pstate7=pstate7+1.96*se7) %>% 
  dplyr::mutate(up_pstate8=pstate8+1.96*se8) %>% 
  dplyr::mutate(up_pstate9=pstate9+1.96*se9) %>% 
  dplyr::mutate(up_pstate10=pstate10+1.96*se10) %>% 
  melt(id.vars=c("pr","transo","time")) %>% 
  dplyr::rename("state_from"="transo") %>% 
  dplyr::mutate(state_to=stri_sub(variable,-1,-1)) %>%
  dplyr::mutate(setting= dplyr::case_when(grepl("out",pr)~"Outpatient",
                                            grepl("res",pr)~"Residential",
                                            T~NA_character_)) %>%
  dplyr::mutate(measure= dplyr::case_when(grepl("se",variable)~"se",
                                          grepl("lo",variable)~"l95ci",
                                          grepl("up",variable)~"u95ci",
                                          grepl("pstate",variable)~"Estimate",
                                          T~NA_character_)) %>%
  dplyr::select(-pr,-variable) %>% 
  purrr::when(dplyr::group_by(.,state_from, time, state_to, setting, measure)%>% summarise(n=n())%>% dplyr::filter(n>1)%>% nrow()>0 ~ stop("There are cases with differences different than 0 days of a variable that should be equal"), 
            ~.) %>% 
  tidyr::pivot_wider(names_from=measure,values_from = value) %>% 
  dplyr::mutate(state_from=ifelse(state_from==0,10,state_from)) %>% 
  dplyr::mutate(state_to=ifelse(state_to==0,10,state_to)) %>% 
  #dplyr::filter(state_from>0, state_to>0) %>% 
  purrr::when(dplyr::group_by(.,time, state_from, state_to, setting) %>% summarise(n=n()) %>% dplyr::filter(n>1)%>% nrow()>0 ~ stop("There are cases with differences different than 0 days of a variable that should be equal"), 
            ~.) %>%
  dplyr::mutate(setting=factor(setting))  
  
  
lmaj_ci_df %>% 
    dplyr::select(time, state_from, state_to, setting, Estimate, l95ci, u95ci) %>% 
    dplyr::arrange(state_from,state_to,setting,time) %>% 
    dplyr::mutate(state_to=as.numeric(state_to)) %>% 
    dplyr::filter(time %in% c(90, 365, 1095)) %>%
    dplyr::mutate(time=factor(time, levels=c(90, 365, 1095),
                  labels=c("~90days/3 months", "~1 year", "~3 years"),ordered=T)) %>% 
    dplyr::mutate(comb=paste0(state_from,"_",state_to)) %>% 
    dplyr::filter(comb %in% c("1_2","1_3","1_4","4_5","4_6","4_7","7_8","7_9","7_10")) %>% 
  dplyr::left_join(cbind.data.frame(states_trans_lab,st=1:10), by=c("state_from"="st")) %>% 
  dplyr::left_join(cbind.data.frame(states_trans_lab,st=1:10), by=c("state_to"="st")) %>% 
  dplyr::select(-comb) %>% 
  dplyr::rename("state_from_lab"="states_trans_lab.x","state_to_lab"="states_trans_lab.y") %>% 
  dplyr::mutate(est_ci=paste0(sprintf("%1.3f",Estimate)," [",sprintf("%1.3f",abs(l95ci)),"-",sprintf("%1.3f",abs(u95ci)),"]")) %>%
  dplyr::arrange(time, state_from,state_to) %>% 
  dplyr::select(time, setting, state_from_lab, state_to_lab, est_ci) %>% 
  tidyr::pivot_wider(names_from=setting,values_from = est_ci) %>% 
  dplyr::select(-time) %>% 
      #2021-04-27: drop from/actual state, readmission
  knitr::kable(format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption = paste0("Table 1a. Estimated transition probabilities, Ten-states model"),
               col.names = c("State from","State to","Outpatient","Residential"),
               align =rep('l', 2),rep('c', 2)) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 13) %>%
  kableExtra::add_footnote("Note. We removed Readmission because it was an absorbing state", notation="none") %>% 
  #kableExtra::add_header_above(c(" ", "Women-specific: Transition to" = 4,"General Population: Transition to" = 4)) %>% 
  kableExtra::pack_rows("At 90 days", 1, 3) %>% 
  kableExtra::pack_rows("At ~1 year", 4, 6) %>% 
  kableExtra::pack_rows("At ~3 years", 7, 9) %>%
  #kableExtra::pack_rows("At 90 days", 1, 9) %>% 
  #kableExtra::pack_rows("At ~1 year", 10, 18) %>% 
  #kableExtra::pack_rows("At ~3 years", 19, 27) %>%
  kableExtra::scroll_box(width = "100%", height = "375px") 
```


```{r dfs_mstate,eval=T, echo=T, paged.print=TRUE, error=T}
# Prob.occ5 <- data.frame(P=tmp.prob,
# lci=tmp.prob-qnorm(0.975)*c(tmp$se1,tmp$se2,tmp$se3),
# uci=tmp.prob+qnorm(0.975)*c(tmp$se1,tmp$se2,tmp$se3))

lmaj_ci_df2<-
rbind(cbind(pr="res",lmaj2_res_1,transo=1),
      cbind(pr="out",lmaj2_out_1,transo=1)) %>% 
  dplyr::mutate(lo_pstate1=pstate1-1.96*se1) %>% 
  dplyr::mutate(lo_pstate2=pstate2-1.96*se2) %>% 
  dplyr::mutate(lo_pstate3=pstate3-1.96*se3) %>% 
  dplyr::mutate(lo_pstate4=pstate4-1.96*se4) %>% 
  dplyr::mutate(lo_pstate5=pstate5-1.96*se5) %>% 
  dplyr::mutate(lo_pstate6=pstate6-1.96*se6) %>% 
  dplyr::mutate(lo_pstate7=pstate7-1.96*se7) %>% 
  dplyr::mutate(lo_pstate8=pstate8-1.96*se8) %>% 
  dplyr::mutate(lo_pstate9=pstate9-1.96*se9) %>% 
  dplyr::mutate(lo_pstate10=pstate10-1.96*se10) %>% 
  dplyr::mutate(up_pstate1=pstate1+1.96*se1) %>% 
  dplyr::mutate(up_pstate2=pstate2+1.96*se2) %>% 
  dplyr::mutate(up_pstate3=pstate3+1.96*se3) %>% 
  dplyr::mutate(up_pstate4=pstate4+1.96*se4) %>% 
  dplyr::mutate(up_pstate5=pstate5+1.96*se5) %>% 
  dplyr::mutate(up_pstate6=pstate6+1.96*se6) %>% 
  dplyr::mutate(up_pstate7=pstate7+1.96*se7) %>% 
  dplyr::mutate(up_pstate8=pstate8+1.96*se8) %>% 
  dplyr::mutate(up_pstate9=pstate9+1.96*se9) %>% 
  dplyr::mutate(up_pstate10=pstate10+1.96*se10) %>% 
  melt(id.vars=c("pr","transo","time")) %>% 
  dplyr::rename("state_from"="transo") %>% 
  dplyr::mutate(state_to=stri_sub(variable,-1,-1)) %>%
  dplyr::mutate(setting= dplyr::case_when(grepl("out",pr)~"Outpatient",
                                            grepl("res",pr)~"Residential",
                                            T~NA_character_)) %>%
  dplyr::mutate(measure= dplyr::case_when(grepl("se",variable)~"se",
                                          grepl("lo",variable)~"l95ci",
                                          grepl("up",variable)~"u95ci",
                                          grepl("pstate",variable)~"Estimate",
                                          T~NA_character_)) %>%
  dplyr::select(-pr,-variable) %>% 
  purrr::when(dplyr::group_by(.,state_from, time, state_to, setting, measure)%>% summarise(n=n())%>% dplyr::filter(n>1)%>% nrow()>0 ~ stop("There are cases with differences different than 0 days of a variable that should be equal"), 
            ~.) %>% 
  tidyr::pivot_wider(names_from=measure,values_from = value) %>% 
  dplyr::mutate(state_from=ifelse(state_from==0,10,state_from)) %>% 
  dplyr::mutate(state_to=ifelse(state_to==0,10,state_to)) %>% 
  #dplyr::filter(state_from>0, state_to>0) %>% 
  purrr::when(dplyr::group_by(.,time, state_from, state_to, setting) %>% summarise(n=n()) %>% dplyr::filter(n>1)%>% nrow()>0 ~ stop("There are cases with differences different than 0 days of a variable that should be equal"), 
            ~.) %>%
  dplyr::mutate(setting=factor(setting))  
  
  
lmaj_ci_df2 %>% 
    dplyr::select(time, state_from, state_to, setting, Estimate, l95ci, u95ci) %>% 
    dplyr::arrange(state_from,state_to,setting,time) %>% 
    dplyr::mutate(state_to=as.numeric(state_to)) %>% 
    dplyr::filter(time %in% c(90, 365, 1095)) %>%
    dplyr::mutate(time=factor(time, levels=c(90, 365, 1095),
                  labels=c("~90days/3 months", "~1 year", "~3 years"),ordered=T)) %>% 
    dplyr::mutate(comb=paste0(state_from,"_",state_to)) %>% 
    dplyr::filter(comb %in% c("1_2","1_3","1_4","4_5","4_6","4_7","7_8","7_9","7_10")) %>% 
  dplyr::left_join(cbind.data.frame(states_trans_lab,st=1:10), by=c("state_from"="st")) %>% 
  dplyr::left_join(cbind.data.frame(states_trans_lab,st=1:10), by=c("state_to"="st")) %>% 
  dplyr::select(-comb) %>% 
  dplyr::rename("state_from_lab"="states_trans_lab.x","state_to_lab"="states_trans_lab.y") %>% 
  dplyr::mutate(est_ci=paste0(sprintf("%1.3f",Estimate)," [",sprintf("%1.3f",abs(l95ci)),"-",sprintf("%1.3f",abs(u95ci)),"]")) %>%
  dplyr::arrange(time, state_from,state_to) %>% 
  dplyr::select(time, setting, state_from_lab, state_to_lab, est_ci) %>% 
  tidyr::pivot_wider(names_from=setting,values_from = est_ci) %>% 
  dplyr::select(-time) %>% 
      #2021-04-27: drop from/actual state, readmission
  knitr::kable(format = "html", format.args = list(decimal.mark = ".", big.mark = ","),
               caption = paste0("Table 1b. Estimated transition probabilities, Ten-states model"),
               col.names = c("State from","State to","Outpatient","Residential"),
               align =rep('l', 2),rep('c', 2)) %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"),font_size = 13) %>%
  kableExtra::add_footnote("Note. We removed Readmission because it was an absorbing state", notation="none") %>% 
  #kableExtra::add_header_above(c(" ", "Women-specific: Transition to" = 4,"General Population: Transition to" = 4)) %>% 
  kableExtra::pack_rows("At 90 days", 1, 3) %>% 
  kableExtra::pack_rows("At ~1 year", 4, 6) %>% 
  kableExtra::pack_rows("At ~3 years", 7, 9) %>%
  #kableExtra::pack_rows("At 90 days", 1, 9) %>% 
  #kableExtra::pack_rows("At ~1 year", 10, 18) %>% 
  #kableExtra::pack_rows("At ~3 years", 19, 27) %>%
  kableExtra::scroll_box(width = "100%", height = "375px") 
```

```{r lmaj_plot_ci95, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 4a. State Occupancies & 95% CIs, landmark Aalen-Johansen estimator from Admission (state 1)", fig.align="center", error=T}
lmaj_ci_df %>% 
  ggplot(aes(time, Estimate, color= setting, linetype =setting, fill=setting))+
  geom_step(size=1, alpha=.65) + 
  geom_ribbon(aes(ymin=l95ci, ymax=u95ci, fill=setting), alpha=.5)+
  facet_wrap(state_to~., ncol=1, scales="free_y", labeller = as_labeller(states_trans_lab)) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 2))+
  #facet_wrap(state~., ncol=1, scales="free_y") + #type_of_program
  scale_color_manual(name= "Type of\nprogram",values=c("gray65","gray35"), labels=c("Outpatient","Residential")) +
  scale_fill_manual(name= "Type of\nprogram",values=c("gray65","gray35"), labels=c("Outpatient","Residential")) +
  scale_linetype_manual(name= "Type of\nprogram",values=c(1,4), labels=c("Outpatient","Residential")) +
  scale_x_continuous(breaks=seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11),
                     label=round(seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11)/365.25,2))+
  xlab("Years") + 
  ylab("") + 
  theme_minimal()
```


```{r lmaj_plot_ci95, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 4b. State Occupancies & 95% CIs, landmark Aalen-Johansen estimator from Admission (state 1)", fig.align="center", error=T}
lmaj_ci_df2 %>% 
  ggplot(aes(time, Estimate, color= setting, linetype =setting, fill=setting))+
  geom_step(size=1, alpha=.65) + 
  geom_ribbon(aes(ymin=l95ci, ymax=u95ci, fill=setting), alpha=.5)+
  facet_wrap(state_to~., ncol=1, scales="free_y", labeller = as_labeller(states_trans_lab)) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 2))+
  #facet_wrap(state~., ncol=1, scales="free_y") + #type_of_program
  scale_color_manual(name= "Type of\nprogram",values=c("gray65","gray35"), labels=c("Outpatient","Residential")) +
  scale_fill_manual(name= "Type of\nprogram",values=c("gray65","gray35"), labels=c("Outpatient","Residential")) +
  scale_linetype_manual(name= "Type of\nprogram",values=c(1,4), labels=c("Outpatient","Residential")) +
  scale_x_continuous(breaks=seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11),
                     label=round(seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11)/365.25,2))+
  xlab("Years") + 
  ylab("") + 
  theme_minimal()
```

<br>

## Transition Probabilities, Markov


```{r probtrans_mark_ci951_mssample,eval=T, echo=T, paged.print=TRUE, error=T}
#, fig.height=13, fig.width=10, fig.cap="Figure 12a. Aalen-Johansen estimator with confidence intervals", fig.align="center"
#n_iter=1000

set.seed(1234)
pt_markov_0 <- probtrans(msfx0,
                predt=0,#his is either the time at which the prediction is made (if direction= "forward")
                direction="forward",#One of "forward" (default) or "fixedhorizon", indicating whether prediction is forward or for a fixed horizon
                method="aalen",# character string specifying the type of variances to be computed (so only needed if either variance or covariance is TRUE). 
                variance=T,#Logical value indicating whether standard errors are to be calculated (default is TRUE)
                covariance=F)#Logical value indicating whether covariances of transition probabilities for different states are to be calculated (default is FALSE)
                
pt_markov_1 <- probtrans(msfx1,
                predt=0,#his is either the time at which the prediction is made (if direction= "forward")
                direction="forward",#One of "forward" (default) or "fixedhorizon", indicating whether prediction is forward or for a fixed horizon
                method="aalen",# character string specifying the type of variances to be computed (so only needed if either variance or covariance is TRUE). 
                variance=T,#Logical value indicating whether standard errors are to be calculated (default is TRUE)
                covariance=F)#Logical value indicating whether covariances of transition probabilities for different states are to be calculated (default is FALSE)
```

<br>

```{r probtrans_plot, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 5. Estimate of State Occupancies at Baseline, Ten-states model", fig.align="center", error=T}
#states_trans_lab<-paste0(1:10,") ",states_trans)
#attr(states_trans_lab,"names")<-1:10

ab_pmatrix_probtrans<-
  pt_markov_0[[1]] %>% 
  dplyr::left_join(pt_markov_1[[1]], by="time", suffix=c("",".w_covs.res.s01")) %>%
  dplyr::left_join(pt_markov_0[[2]], by="time", suffix=c("",".w_covs.out.s02")) %>% 
  dplyr::left_join(pt_markov_1[[2]], by="time", suffix=c("",".w_covs.res.s02")) %>% 
  dplyr::left_join(pt_markov_0[[3]], by="time", suffix=c("",".w_covs.out.s03")) %>% 
  dplyr::left_join(pt_markov_1[[3]], by="time", suffix=c("",".w_covs.res.s03")) %>% 
  dplyr::left_join(pt_markov_0[[4]], by="time", suffix=c("",".w_covs.out.s04")) %>% 
  dplyr::left_join(pt_markov_1[[4]], by="time", suffix=c("",".w_covs.res.s04")) %>% 
  dplyr::left_join(pt_markov_0[[5]], by="time", suffix=c("",".w_covs.out.s05")) %>% 
  dplyr::left_join(pt_markov_1[[5]], by="time", suffix=c("",".w_covs.res.s05")) %>% 
  dplyr::left_join(pt_markov_0[[6]], by="time", suffix=c("",".w_covs.out.s06")) %>% 
  dplyr::left_join(pt_markov_1[[6]], by="time", suffix=c("",".w_covs.res.s06")) %>% 
  dplyr::left_join(pt_markov_0[[7]], by="time", suffix=c("",".w_covs.out.s07")) %>% 
  dplyr::left_join(pt_markov_1[[7]], by="time", suffix=c("",".w_covs.res.s07")) %>% 
  dplyr::left_join(pt_markov_0[[8]], by="time", suffix=c("",".w_covs.out.s08")) %>% 
  dplyr::left_join(pt_markov_1[[8]], by="time", suffix=c("",".w_covs.res.s08")) %>% 
  dplyr::left_join(pt_markov_0[[9]], by="time", suffix=c("",".w_covs.out.s09")) %>% 
  dplyr::left_join(pt_markov_1[[9]], by="time", suffix=c("",".w_covs.res.s09")) %>% 
  dplyr::left_join(pt_markov_0[[10]], by="time", suffix=c("",".w_covs.out.s10")) %>% 
  dplyr::left_join(pt_markov_1[[10]], by="time", suffix=c("",".w_covs.res.s10")) %>% 
  dplyr::select(-starts_with("se")) %>% 
  dplyr::rename("pstate1.w_covs.out.s1"="pstate1",
                "pstate2.w_covs.out.s1"="pstate2",
                "pstate3.w_covs.out.s1"="pstate3",
                "pstate4.w_covs.out.s1"="pstate4",
                "pstate5.w_covs.out.s1"="pstate5",
                "pstate6.w_covs.out.s1"="pstate6",
                "pstate7.w_covs.out.s1"="pstate7",
                "pstate8.w_covs.out.s1"="pstate8",
                "pstate9.w_covs.out.s1"="pstate9",
                "pstate10.w_covs.out.s1"="pstate10") %>% 
  #pstate1–pstate3 are close to the first rows of the matrices returned by pmatrix.fs
  reshape2::melt(id.vars="time") %>% #janitor::tabyl(variable)
  dplyr::mutate(start=stri_sub(variable,-1,-1)) %>% 
  dplyr::mutate(state=stringi::stri_match_first_regex(variable, "(.*?)\\.")[,2]) %>%
  dplyr::mutate(state=gsub("pstate", "", state), state=as.numeric(state)) %>% 
  dplyr::mutate(setting= dplyr::case_when(grepl(".out",variable)~"Outpatient",
                                               grepl(".res",variable)~"Residential",
                                               T~NA_character_))

fig_ab_pmatrix_probtrans<-
  #janitor::tabyl(start)
  ggplot(ab_pmatrix_probtrans, aes(time, value, color= start, linetype =setting))+
    geom_step(size=1, alpha=.65) + 
    scale_y_continuous(labels = scales::percent_format(accuracy = 2))+
    facet_wrap(state~., ncol=1, scales="free_y", labeller = as_labeller(states_trans_lab)) + 
    #facet_wrap(state~., ncol=1, scales="free_y") + #type_of_program
    scale_color_manual(name = "Starting from\nState", values=c("#54478C","#2C699A","#048BA8","#0DB39E",
                                                        "#16DB93","#83E377","#EFEA5A","#F1C453","#F29E4C","red"), labels= as.character(c(1:10))) + # "#A65100" #"Cox",
    scale_linetype_manual(name= "Type of\nprogram",values=c(1,4), labels=c("Outpatient","Residential")) +
    scale_x_continuous(breaks=seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11),
                       label=round(seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11)/365.25,2))+
    xlab("Years") + 
    ylab("") + 
    theme_minimal()

fig_ab_pmatrix_probtrans

if(no_mostrar==1){
jpeg(paste0(gsub("SUD_CL/Matching_Process_APR_21.Rmd","",path),"_mult_state_ags/probtrans_states.jpg"), height=20, width= 10, res= 320, units = "in")
fig_ab_pmatrix_probtrans
dev.off()
}
```

```{r probtrans_plot2, eval=T, echo=T, paged.print=TRUE, fig.height=20, fig.width=10, fig.cap="Figure 6. Estimate of State Occupancies at Baseline, Ten-states model", fig.align="center", error=T}
myplots<- vector("list")

for (i in rep(1:7,2)){
  myplots[[paste0("pt_0_",i)]]<- plot(pt_markov_0, from= i,type="single",use.ggplot= TRUE)
  myplots[[paste0("pt_1_",i)]]<- plot(pt_markov_1, from= i,type="single",use.ggplot= TRUE)
}

for (i in rep(8:9,1)){
  #myplots[[paste0("pt_0_",i)]]<- plot(pt_markov_0, from= i,type="single",use.ggplot= TRUE)
  myplots[[paste0("pt_1_",i)]]<- plot(pt_markov_1, from= i,type="single",use.ggplot= TRUE)
}

probtrans_df<-
rbind(cbind(subset(myplots$pt_0_1$data,state_num %in% c(2,3,4))[,c("time","state","prob","CI_low","CI_upp")],res=0, st=1),
      cbind(subset(myplots$pt_1_1$data,state_num %in% c(2,3,4))[,c("time","state","prob","CI_low","CI_upp")],res=1, st=1),
      cbind(subset(myplots$pt_0_2$data,state_num %in% c(4))[,c("time","state","prob","CI_low","CI_upp")],res=0, st=2),
      cbind(subset(myplots$pt_1_2$data,state_num %in% c(4))[,c("time","state","prob","CI_low","CI_upp")],res=1, st=2),
      cbind(subset(myplots$pt_0_3$data,state_num %in% c(4))[,c("time","state","prob","CI_low","CI_upp")],res=0, st=3),
      cbind(subset(myplots$pt_1_3$data,state_num %in% c(4))[,c("time","state","prob","CI_low","CI_upp")],res=1, st=3),
      cbind(subset(myplots$pt_0_4$data,state_num %in% c(5,6,7))[,c("time","state","prob","CI_low","CI_upp")],res=0, st=4),
      cbind(subset(myplots$pt_1_4$data,state_num %in% c(5,6,7))[,c("time","state","prob","CI_low","CI_upp")],res=1, st=4),
      cbind(subset(myplots$pt_0_5$data,state_num %in% c(7))[,c("time","state","prob","CI_low","CI_upp")],res=0, st=5),
      cbind(subset(myplots$pt_1_5$data,state_num %in% c(7))[,c("time","state","prob","CI_low","CI_upp")],res=1, st=5),
      cbind(subset(myplots$pt_0_5$data,state_num %in% c(7))[,c("time","state","prob","CI_low","CI_upp")],res=0, st=6),
      cbind(subset(myplots$pt_1_5$data,state_num %in% c(7))[,c("time","state","prob","CI_low","CI_upp")],res=1, st=6),
      cbind(subset(myplots$pt_0_5$data,state_num %in% c(8,9,10))[,c("time","state","prob","CI_low","CI_upp")],res=0, st=7),
      cbind(subset(myplots$pt_1_5$data,state_num %in% c(8,9,10))[,c("time","state","prob","CI_low","CI_upp")],res=1, st=7)

)

probtrans_df_plot<-
probtrans_df %>% 
  dplyr::mutate(res=factor(res), state=factor(state)) %>% 
 ggplot()+
    geom_step(aes(time, prob, color= state, fill=state, linetype =res),size=1, alpha=.75) + 
    geom_ribbon(aes(x=time, fill=state, color= state, linetype =res, ymin=CI_low, ymax=CI_upp), alpha=.35)+
    scale_y_continuous(labels = scales::percent_format(accuracy = 2))+
    facet_wrap(st~., ncol=1, scales="free_y", labeller = as_labeller(states_trans_lab)) + 
    #facet_wrap(state~., ncol=1, scales="free_y") + #type_of_program
    scale_color_manual(name = "Exit\nState", values=c26) +
    scale_fill_manual(name = "Exit\nState", values=c26) +  
    scale_linetype_manual(name= "Type of\nprogram",values=c(1,4), labels=c("Outpatient","Residential")) +
    scale_x_continuous(breaks=seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11),
                       label=round(seq(0,max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T),by=max(c(msf0$Haz$time,msf1$Haz$time),na.rm=T)/11)/365.25,2))+
    xlab("Years") + 
    ylab("") + 
    theme_minimal()

probtrans_df_plot

if(no_mostrar==1){
jpeg(paste0(gsub("SUD_CL/Matching_Process_APR_21.Rmd","",path),"_mult_state_ags/probtrans_states_trans.jpg"), height=20, width= 10, res= 320, units = "in")
probtrans_df_plot
dev.off()
}
```

<br>

## Clustered multistate

```{r clus_mstate,eval=T, echo=T, paged.print=TRUE, error=T}
## Function that calculates the working independence Aalen-Johansen estimator 
## of the population-averaged transition probabilities. Standard errors and
## and 95% confidence intervals and bands are also calculated.

patp <- function(data, tmat, cid, id, h, j, s=0, weighted=FALSE,
                 LMAJ=FALSE, B=100, cband=FALSE){
  check.ic <- aggregate(data[,cid], by=list(data[,id]), 
                        FUN=sd, na.rm=TRUE)$x
  check.ic <- check.ic[!is.na(check.ic)]
  if(length(check.ic)>0){
    if(max(check.ic)>0){
      stop("Same unit(s) in more than 1 cluster (violation of the independent clusters assumption)")
    }
  }
  
  if(B<=0 & cband==TRUE){
    stop("Condidence bands cannot be caclulated based on <=0 bootstrap samples")
  } else if (B<1000 & cband==TRUE){
    warning("It is recommended to use at least 1000 bootstrap samples for confidence band calculation")
  }
  if(LMAJ==FALSE){
    c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), data=data,
                method = "breslow")
    
    A0 <- msfit(object = c0, trans = tmat, variance=FALSE)
    if(weighted==TRUE){
      ## msfit does not currently support weights and thus
      ## the weighted by cluster size cumulative transition
      ## intensities need to be manually inserted into A0
      M0 <- aggregate(rep(1,times=nrow(data)),
                      by = list( data[,cid], data[,id]),
                      FUN = mean)
      
      M <- aggregate(M0$x,
                     by = list( M0$Group.1),
                     FUN = sum)
      colnames(M) <- c(cid, "clust.size")
      data <- merge(data, M, by=cid)
      data <- data[order(data[,cid],data[,id]),]
      class(data) <- c("msdata", "data.frame")
      
      c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
                  weights=(1/clust.size), data=data,
                  method = "breslow")
      A.wt <- basehaz(c0, centered=FALSE)
      A.wt$strata <- as.numeric(A.wt$strata)
      for(trn in sort(unique(A.wt$strata))){
        fun <- stepfun(A.wt[A.wt$strata==trn,"time"], 
                       c(0,A.wt[A.wt$strata==trn,"hazard"]))
        A0$Haz[A0$Haz$trans==trn,"Haz"] <- fun(A0$Haz[A0$Haz$trans==trn,"time"])
      }
    }
    P0 <- probtrans(A0, predt = s, 
                    variance=FALSE)[[h]][,c("time",
                                            paste("pstate", j, sep=""))]
  } else {
    if(weighted==TRUE){
      M0 <- aggregate(rep(1,times=nrow(data)),
                      by = list( data[,cid], data[,id]),
                      FUN = mean)
      
      M <- aggregate(M0$x,
                     by = list( M0$Group.1),
                     FUN = sum)
      colnames(M) <- c(cid, "clust.size")
      data <- merge(data, M, by=cid)
      data <- data[order(data[,cid],data[,id]),]
      class(data) <- c("msdata", "data.frame")
    }
    P0 <- LMAJ2(msdata=data, tmat=tmat, id=id, s=s, h=h, j=j, weighted=weighted)
  }
  
  colnames(P0) <- c("time", paste("P", h, j, sep=""))
  if(B==0){
    return(P0)
  } else {
    n <- length(unique(data[,cid]))
    boot <- msboot(patp_b, data=data, 
                   id=cid, B=B, verbose=0,
                   tmat=tmat, id2=id, h=h, j=j, s=s, times=P0$time,
                   wiaj_hat=P0[,paste("P", h, j, sep="")],
                   n=n, weighted=weighted, LMAJ=LMAJ)
    sigma <- apply(boot, 1, sd)
    se <- sigma/sqrt(n)
    
    ## cloglog transformation
    ll <- exp(-exp(log(-log(P0[,paste("P", h, j, sep="")]))-qnorm(0.975)*se/
                     (P0[,paste("P", h, j, sep="")]*
                        log(P0[,paste("P", h, j, sep="")]))))
    ul <- exp(-exp(log(-log(P0[,paste("P", h, j, sep="")]))+qnorm(0.975)*se/
                     (P0[,paste("P", h, j, sep="")]*
                        log(P0[,paste("P", h, j, sep="")]))))
    
    res <- cbind(P0, se, ll, ul)
    
    if(cband==TRUE){
      q_t <- 1/(1+sigma^2)
      
      jump.times <- P0$time[diff(c(P0[1,paste("P", h, j, sep="")],
                                   P0[,paste("P", h, j, sep="")]), lag=1)!=0]
      quant <- quantile(jump.times, probs=c(.05,.95))
      range <- (P0$time>=quant[1] & P0$time<=quant[2] & 
                  P0[,paste("P", h, j, sep="")]>0)
      
      B_t <- q_t[range]*boot[range,]/(log(P0[range, paste("P", h, j, sep="")])*
                                        P0[range, paste("P", h, j, sep="")])
      B_t <- abs(B_t)
      c_a <- apply(B_t, 2, max)
      c_a <- quantile(c_a, probs=0.95)
      
      ## cloglog transformation
      ll.band <- exp(-exp(log(-log(P0[,paste("P", h, j, sep="")]))+c_a/(sqrt(n)*q_t)))
      ll.band[!range] <- NA
      ul.band <- exp(-exp(log(-log(P0[,paste("P", h, j, sep="")]))-c_a/(sqrt(n)*q_t)))
      ul.band[!range] <- NA
      
      res <- cbind(res, ll.band, ul.band)
    }
    return(res)
  }
}

patp_b <- function(data, tmat, id2, h, j, s, times, wiaj_hat, n, weighted, LMAJ){
  if(LMAJ==FALSE){
    c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), data=data,
                method = "breslow")
    
    A0 <- msfit(object = c0, trans = tmat, variance=FALSE)
    if(weighted==TRUE){
      c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
                  weights=(1/clust.size), data=data,
                  method = "breslow")
      A.wt <- basehaz(c0, centered=FALSE)
      A.wt$strata <- as.numeric(A.wt$strata)
      for(trn in sort(unique(A.wt$strata))){
        fun <- stepfun(A.wt[A.wt$strata==trn,"time"], 
                       c(0,A.wt[A.wt$strata==trn,"hazard"]))
        A0$Haz[A0$Haz$trans==trn,"Haz"] <- fun(A0$Haz[A0$Haz$trans==trn,"time"])
      }
    }
    
    P0 <- probtrans(A0, predt = s, 
                    variance=FALSE)[[h]][,c("time",
                                            paste("pstate", j, sep=""))]
  } else {
    P0 <- LMAJ2(msdata=data, tmat=tmat, id=id2, s=s, h=h, j=j, weighted=weighted)
  }
  
  P0_t <-stepfun(P0$time, c(P0[1,paste("pstate", j, sep="")], 
                            P0[,paste("pstate", j, sep="")]))                
  
  return(sqrt(n)*(P0_t(times)-wiaj_hat))
}

patp_test <- function(data, tmat, cid, id, group, h, j, s=0,
                      weighted=FALSE, LMAJ=FALSE, B=1000){
  check.ic <- aggregate(data[,cid], by=list(data[,id]), 
                        FUN=sd, na.rm=TRUE)$x
  check.ic <- check.ic[!is.na(check.ic)]
  if(length(check.ic)>0){
    if(max(check.ic)>0){
      stop("Same unit(s) in more than 1 cluster (violation of the independent clusters assumption)")
    }
  }
  
  if(B<=0){
    stop("Tests cannot be performed based on <=0 bootstrap samples")
  } else if (B<1000){
    warning("It is recommended to use at least 1000 bootstrap samples for two-sample testing")
  }
  n <- length(unique(data[,cid]))
  groups <- unique(data[,group])
  groups <- sort(groups[!is.na(groups)])
  if(length(groups)!=2){
    stop("Number of groups != 2")
  }
  
  if(weighted==TRUE){
    M0 <- aggregate(rep(1,times=nrow(data)),
                    by = list(data[,cid],
                              data[,group],
                              data[,id]),
                    FUN = mean)
    
    M <- aggregate(M0$x,
                   by = list(M0$Group.1, M0$Group.2),
                   FUN = sum)
    colnames(M) <- c(cid, group, "clust.size")
    data <- merge(data, M, by=c(cid,group))
    data <- data[order(data[,cid],data[,id]),]
    class(data) <- c("msdata", "data.frame")
  }
  
  Pt <- list()
  tms <- list()
  for(g in groups){
    if(LMAJ==FALSE){
      c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans),
                  data=data[data[,group]==g,], method = "breslow")
      
      A0 <- msfit(object = c0, trans = tmat, variance=FALSE)
      if(weighted==TRUE){
        c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
                    weights=(1/clust.size), data=data[data[,group]==g,], 
                    method = "breslow")
        A.wt <- basehaz(c0, centered=FALSE)
        A.wt$strata <- as.numeric(A.wt$strata)
        for(trn in sort(unique(A.wt$strata))){
          fun <- stepfun(A.wt[A.wt$strata==trn,"time"], 
                         c(0,A.wt[A.wt$strata==trn,"hazard"]))
          A0$Haz[A0$Haz$trans==trn,"Haz"] <- fun(A0$Haz[A0$Haz$trans==trn,"time"])
        }
      }
      
      P0 <- probtrans(A0, predt = s, variance=FALSE)[[h]][,c("time",
                                                             paste("pstate", j, sep=""))]
    } else {
      P0 <- LMAJ2(msdata=data[data[,group]==g,], tmat=tmat, 
                  id=id, s=s, h=h, j=j, weighted=weighted)
    }
    if(length(Pt)==0){
      Pt[[1]] <- stepfun(P0$time, c(P0[1,paste("pstate", j, sep="")], 
                                    P0[,paste("pstate", j, sep="")]))
      tms[[1]] <- P0$time[diff(c(P0[1,paste("pstate", j, sep="")],
                                 P0[,paste("pstate", j, sep="")]), lag=1)!=0]
    } else {
      Pt[[2]] <- stepfun(P0$time, c(P0[1,paste("pstate", j, sep="")], 
                                    P0[,paste("pstate", j, sep="")]))
      tms[[2]] <- P0$time[diff(c(P0[1,paste("pstate", j, sep="")],
                                 P0[,paste("pstate", j, sep="")]), lag=1)!=0]
    }
  }
  
  tms <- sort(unique(c(tms[[1]], tms[[2]])))
  
  if(nrow(data[data$from==j,])>0){
    tS <- sort(unique(c(data[data$to==j,"from"],j)))
  } else {
    tS <- sort(unique(data[data$to==j,"from"]))
  }
  
  EY <- NULL
  EY.t <- function(t,dt){
    sum(dt$Tstart<t & dt$Tstop>=t)/n
  }
  for(i in tS){
    for(g in groups){
      dat <- unique(data[data$from==i & data[,group]==g,
                         c(id, "from", "Tstart", "Tstop")])
      if(is.null(EY)){
        EY <- sapply(tms, EY.t, dt=dat)
      } else {
        EY <- cbind(EY, sapply(tms, EY.t, dt=dat))
      }
    }
  }
  Wt <- rowprods(EY)/rowSums(EY)
  tms <- tms[!is.na(Wt)]
  if(length(tms)==0 | max(Wt, na.rm=TRUE)==0){
    stop("Weights NA or 0 for all timepoints")
  }
  Wt <- Wt[!is.na(Wt)]
  D_hat=(Pt[[1]](tms) - Pt[[2]](tms))
  
  Diff_boot <- msboot(patp_test_b, data=data, 
                      id=cid, B=B, verbose=0,
                      tmat=tmat, id2=id, group=group, h=h, j=j, s=s, 
                      times=tms, D_hat=D_hat, Wt=Wt,
                      n=n, weighted=weighted, LMAJ=LMAJ)
  
  KS <- max(abs(sqrt(n)*Wt*D_hat))
  KS.b <- apply(abs(Diff_boot),2,max)
  pval <- mean(KS.b >= KS)
  names(pval) <- "p-value"
  return(pval)
}
patp_test_b <- function(data, tmat, id2, h, j, s, group, times, D_hat, 
                        Wt, n, weighted, LMAJ){
  
  groups <- unique(data[,group])
  groups <- sort(groups[!is.na(groups)])
  
  Pt <- list()
  for(g in groups){
    if(LMAJ==FALSE){
      c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
                  data=data[data[,group]==g,], method = "breslow")
      
      A0 <- msfit(object = c0, trans = tmat, variance=FALSE)
      if(weighted==TRUE){
        c0 <- coxph(Surv(Tstart, Tstop, status) ~ strata(trans), 
                    weights=(1/clust.size), data=data[data[,group]==g,],
                    method = "breslow")
        A.wt <- basehaz(c0, centered=FALSE)
        A.wt$strata <- as.numeric(A.wt$strata)
        for(trn in sort(unique(A.wt$strata))){
          fun <- stepfun(A.wt[A.wt$strata==trn,"time"], 
                         c(0,A.wt[A.wt$strata==trn,"hazard"]))
          A0$Haz[A0$Haz$trans==trn,"Haz"] <- fun(A0$Haz[A0$Haz$trans==trn,"time"])
        }
      }
      P0 <- probtrans(A0, predt = s, variance=FALSE)[[h]][,c("time",
                                                             paste("pstate", j, sep=""))]
    } else {
      P0 <- LMAJ2(msdata=data[data[,group]==g,], tmat=tmat, 
                  id=id2, s=s, h=h, j=j, weighted=weighted)
    }
    if(length(Pt)==0){
      Pt[[1]] <- stepfun(P0$time, c(P0[1,paste("pstate", j, sep="")], 
                                    P0[,paste("pstate", j, sep="")]))
    } else {
      Pt[[2]] <- stepfun(P0$time, c(P0[1,paste("pstate", j, sep="")], 
                                    P0[,paste("pstate", j, sep="")]))
    }
  }          
  D_boot <- Pt[[1]](times) - Pt[[2]](times)
  return(sqrt(n)*Wt*(D_boot-D_hat))
}


#data: a data.frame in the long format required by the mstate package.
#tmat: a matrix of possible transitions between states of the process where different transitions are identified by a different integer. If a direct transition between two states is not possible it is indicated as NA. This matrix can be obtained via the mstate function transMat().
#cid: variable name that identifies the clusters.
#id: variable name that identifies the individual observations.
#h: the state h in Pr(X(t) = j| X(s) = h).
#j: the state j in Pr(X(t) = j| X(s) = h).
#s: the time s in Pr(X(t) = j| X(s) = h). The default value is 0.
#weighted: logical value. If TRUE, the estimator is weighted by the inverse of the cluster sizes. This is useful when cluster size is random and expected to be informative. The default value is FALSE.
#LMAJ: logical value. If TRUE, the landmark version of the estimator is returned. This is useful when s>0 and the Markov assumption is not plausible. The default value is FALSE.
#B: number of nonparametric cluster bootstrap replications. If B=0, no standard errors or confidence intervals/bands are returned. The default value is 100.
#cband: logical value. If TRUE, the limits of the 95% simultaneous confidence band are returned. The default value is FALSE.

#https://github.com/gbakoyannis/clustered-multistate/tree/master/R

ms_d_match_surv$cid<-
  as.numeric(unlist(ms_d_match_surv %>% #119356
  dplyr::left_join(d_match_surv_msprep[,c("id","group_match")], by="id") %>% select(group_match)))#119356

set.seed(2125)
P12 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=1, j=2, s=0, B=1000, LMAJ=T, cband=T)
set.seed(2125)
P13 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=1, j=3, s=0, B=1000, LMAJ=T, cband=T)

set.seed(2125)
P24 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=2, j=4, s=0, B=1000, LMAJ=T, cband=T)
set.seed(2125) 
P34 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=3, j=4, s=0, B=1000, LMAJ=T, cband=T)

set.seed(2125)
P45 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=4, j=5, s=0, B=1000, LMAJ=T, cband=T)
set.seed(2125) 
P46 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=4, j=6, s=0, B=1000, LMAJ=T, cband=T)

set.seed(2125)
P57 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=5, j=7, s=0, B=1000, LMAJ=T, cband=T)
set.seed(2125) 
P67 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=6, j=7, s=0, B=1000, LMAJ=T, cband=T)

set.seed(2125)
P78 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=7, j=8, s=0, B=1000, LMAJ=T, cband=T)
set.seed(2125) 
P79 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=7, j=9, s=0, B=1000, LMAJ=T, cband=T)

set.seed(2125)
P810 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=8, j=10, s=0, B=1000, LMAJ=T, cband=T)
set.seed(2125) 
P910 <- patp(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", 
             h=9, j=10, s=0, B=1000, LMAJ=T, cband=T)
```

```{r clus_mstate_group,eval=T, echo=T, paged.print=TRUE, error=T}

P12_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=1, j=2, s=365*3, B=1000, LMAJ=T)
 
P13_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=1, j=3, s=365*3, B=1000, LMAJ=T)


P24_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=2, j=4, s=365*3, B=1000, LMAJ=T)
 
P34_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=3, j=4, s=365*3, B=1000, LMAJ=T)


P45_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=4, j=5, s=365*3, B=1000, LMAJ=T)
 
P46_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=4, j=6, s=365*3, B=1000, LMAJ=T)


P57_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=5, j=7, s=365*3, B=1000, LMAJ=T)
 
P67_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=6, j=7, s=365*3, B=1000, LMAJ=T)


P78_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=7, j=8, s=365*3, B=1000, LMAJ=T)
 
P79_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=7, j=9, s=365*3, B=1000, LMAJ=T)


P810_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=8, j=10, s=365*3, B=1000, LMAJ=T)
 
P910_clus_0 <- patp_test(data=ms_d_match_surv, tmat=trans_matrix, cid="cid", id="id", group="tipo_de_plan_res_1",
             h=9, j=10, s=365*3, B=1000, LMAJ=T)

```



# Session Info

```{r session_info, echo=T, error=T, paged.print=TRUE}
Sys.getenv("R_LIBS_USER")

rstudioapi::getSourceEditorContext()
#save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_carla.RData")

if (grepl("CISS Fondecyt",rstudioapi::getSourceEditorContext()$path)==T){
    save.image("C:/Users/CISS Fondecyt/OneDrive/Escritorio/SUD_CL/mult_state_2.RData")
  } else if (grepl("andre",rstudioapi::getSourceEditorContext()$path)==T){
    save.image("C:/Users/andre/Desktop/SUD_CL/mult_state_2.RData")
  } else if (grepl("E:",rstudioapi::getSourceEditorContext()$path)==T){
    save.image("E:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2.RData")
  } else {
    save.image("G:/Mi unidad/Alvacast/SISTRAT 2019 (github)/mult_state_2.RData")
  }

sessionInfo()
```
